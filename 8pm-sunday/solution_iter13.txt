 % ./bb
 % Args:
DEBUG P1READ: Terminal 0 battery=100.00
DEBUG P1READ: Terminal 1 battery=84.60
DEBUG P1READ: Terminal 2 battery=93.70
DEBUG P1READ: Terminal 3 battery=100.00
DEBUG P1READ: Terminal 4 battery=100.00
DEBUG P1READ: Terminal 5 battery=99.50
DEBUG P1READ: Terminal 6 battery=100.00
DEBUG P1READ: Terminal 7 battery=98.00
DEBUG P1READ: Terminal 8 battery=98.00
DEBUG P1READ: Terminal 9 battery=98.00
DEBUG P1READ: Terminal 10 battery=100.00
DEBUG P1READ: Terminal 11 battery=48.00
DEBUG P1READ: Terminal 12 battery=65.00
DEBUG P1READ: Terminal 13 battery=100.00
DEBUG P1READ: Terminal 14 battery=72.30
DEBUG P1READ: Terminal 15 battery=100.00
DEBUG P1READ: Terminal 16 battery=70.00
DEBUG P1READ: Terminal 17 battery=98.00
DEBUG P1READ: Terminal 18 battery=98.00
DEBUG P1READ: Terminal 19 battery=100.00
DEBUG HG: num_verts=20, num_edges=40
 % Phase 1: 0.00 seconds

%%BeginSetup

0 1 0 1 SetAxes

20 DefineTerminals
	.4588350000000000	.2373240000000000	DT
	.1270640000000000	.3509960000000000	DT
	.1544540000000000	.4808220000000000	DT
	.9474030000000000	.1441120000000000	DT
	.2867390000000000	.0565890000000000	DT
	.1326890000000000	.1166050000000000	DT
	.6273950000000000	.2122140000000000	DT
	.0794880000000000	.7970990000000000	DT
	.0327480000000000	.8803250000000000	DT
	.3110550000000000	.8689670000000000	DT
	.0916180000000000	.0221720000000000	DT
	.3600710000000000	.6382240000000000	DT
	.7197120000000000	.7181670000000000	DT
	.4424420000000000	.1450340000000000	DT
	.9983770000000000	.5729870000000000	DT
	.9654920000000000	.1935700000000000	DT
	.1600100000000000	.4187950000000000	DT
	.2909450000000000	.9620800000000000	DT
	.3330000000000000	.9414120000000000	DT
	.9512590000000000	.5074670000000000	DT

%%EndSetup

DEBUG ALGO: num_verts=20 <= 8? NO, num_edges=40 <= 12? NO
DEBUG ALGO: Forcing BRANCH-AND-CUT for multi-objective optimization (vertices=20 > 1)
DEBUG SPANNING: Adding modified spanning constraint for budget mode
DEBUG SPANNING: Added modified spanning constraint: Σ(|FST|-1)*x + Σnot_covered = 19
DEBUG CONSTRAINT: Adding soft cutset constraints with not_covered variables
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[27] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[31] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[0] ≤ 3 for terminal 0
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[24] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[33] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[1] ≤ 3 for terminal 1
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[23] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[36] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[2] ≤ 5 for terminal 2
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[22] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[39] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 6·not_covered[3] ≤ 6 for terminal 3
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[30] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[32] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 4·not_covered[4] ≤ 4 for terminal 4
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[29] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[30] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[33] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[5] ≤ 5 for terminal 5
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[31] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[39] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 9·not_covered[6] ≤ 9 for terminal 6
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[28] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[35] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 10·not_covered[7] ≤ 10 for terminal 7
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[28] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[8] ≤ 5 for terminal 8
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[25] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[34] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[35] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 13·not_covered[9] ≤ 13 for terminal 9
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[10] ≤ 1 for terminal 10
DEBUG CONSTRAINT: Added constraint x[29] + not_covered[10] ≤ 1 for terminal 10
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[10] ≤ 2 for terminal 10
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[34] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[36] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 8·not_covered[11] ≤ 8 for terminal 11
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[37] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[12] ≤ 5 for terminal 12
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint x[27] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint x[32] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[13] ≤ 3 for terminal 13
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[14] ≤ 1 for terminal 14
DEBUG CONSTRAINT: Added constraint x[26] + not_covered[14] ≤ 1 for terminal 14
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[14] ≤ 2 for terminal 14
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[22] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[38] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 7·not_covered[15] ≤ 7 for terminal 15
DEBUG CONSTRAINT: Added constraint x[23] + not_covered[16] ≤ 1 for terminal 16
DEBUG CONSTRAINT: Added constraint x[24] + not_covered[16] ≤ 1 for terminal 16
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[16] ≤ 2 for terminal 16
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[21] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 4·not_covered[17] ≤ 4 for terminal 17
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[21] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[25] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 6·not_covered[18] ≤ 6 for terminal 18
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[26] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[37] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[38] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 9·not_covered[19] ≤ 9 for terminal 19
DEBUG CONSTRAINT: Added source terminal constraint: not_covered[0] = 0
DEBUG BUDGET: Adding budget constraint ≤ 1000000.000 to constraint pool
DEBUG BUDGET: Using raw tree costs directly
DEBUG BUDGET: Budget limit: 1000000.000
DEBUG BUDGET: Building raw cost constraint coefficients:
DEBUG BUDGET:   x[0] coefficient = 398991 (raw=398991.100)
DEBUG BUDGET:   x[1] coefficient = 260889 (raw=260889.712)
DEBUG BUDGET:   x[2] coefficient = 256773 (raw=256773.057)
DEBUG BUDGET:   x[3] coefficient = 376541 (raw=376541.557)
DEBUG BUDGET:   x[4] coefficient = 646084 (raw=646084.462)
DEBUG BUDGET:   x[5] coefficient = 520973 (raw=520973.020)
DEBUG BUDGET:   x[6] coefficient = 334575 (raw=334575.182)
DEBUG BUDGET:   x[7] coefficient = 494448 (raw=494448.457)
DEBUG BUDGET:   x[8] coefficient = 455905 (raw=455905.519)
DEBUG BUDGET:   x[9] coefficient = 584020 (raw=584020.499)
DEBUG BUDGET:   x[10] coefficient = 380918 (raw=380918.244)
DEBUG BUDGET:   x[11] coefficient = 621357 (raw=621357.781)
DEBUG BUDGET:   x[12] coefficient = 120675 (raw=120675.719)
DEBUG BUDGET:   x[13] coefficient = 551354 (raw=551354.477)
DEBUG BUDGET:   x[14] coefficient = 410262 (raw=410262.679)
DEBUG BUDGET:   x[15] coefficient = 362962 (raw=362962.653)
DEBUG BUDGET:   x[16] coefficient = 702244 (raw=702244.403)
DEBUG BUDGET:   x[17] coefficient = 673894 (raw=673894.542)
DEBUG BUDGET:   x[18] coefficient = 933994 (raw=933994.022)
DEBUG BUDGET:   x[19] coefficient = 454199 (raw=454199.906)
DEBUG BUDGET:   x[20] coefficient = 986439 (raw=986439.144)
DEBUG BUDGET:   x[21] coefficient = 46859 (raw=46859.249)
DEBUG BUDGET:   x[22] coefficient = 52662 (raw=52662.185)
DEBUG BUDGET:   x[23] coefficient = 62275 (raw=62275.339)
DEBUG BUDGET:   x[24] coefficient = 75379 (raw=75379.993)
DEBUG BUDGET:   x[25] coefficient = 75695 (raw=75695.846)
DEBUG BUDGET:   x[26] coefficient = 80703 (raw=80703.013)
DEBUG BUDGET:   x[27] coefficient = 93734 (raw=93734.596)
DEBUG BUDGET:   x[28] coefficient = 95452 (raw=95452.578)
DEBUG BUDGET:   x[29] coefficient = 102977 (raw=102977.757)
DEBUG BUDGET:   x[30] coefficient = 165327 (raw=165327.925)
DEBUG BUDGET:   x[31] coefficient = 170420 (raw=170420.027)
DEBUG BUDGET:   x[32] coefficient = 179069 (raw=179069.657)
DEBUG BUDGET:   x[33] coefficient = 234458 (raw=234458.486)
DEBUG BUDGET:   x[34] coefficient = 235891 (raw=235891.713)
DEBUG BUDGET:   x[35] coefficient = 242462 (raw=242462.956)
DEBUG BUDGET:   x[36] coefficient = 258947 (raw=258947.370)
DEBUG BUDGET:   x[37] coefficient = 313063 (raw=313063.098)
DEBUG BUDGET:   x[38] coefficient = 314219 (raw=314219.517)
DEBUG BUDGET:   x[39] coefficient = 327174 (raw=327174.269)
DEBUG BUDGET: Constraint: Σ tree_cost[i] * x[i] ≤ 1000000
DEBUG BUDGET: Budget constraint added to pool with 40 FSTs
DEBUG CONSTRAINT: Adding 'at least one FST' constraint: Σ x[i] ≥ 1
DEBUG CONSTRAINT: Added 'at least one FST' constraint: Σ x[i] ≥ 1
 % _gst_initialize_constraint_pool: 0.00 seconds.
 % Constraint pool initialized with:
 % 	1	Total degree rows	40	coeffs.
 % 	20	Cutset rows		111	coeffs.
 % 	0	Incompatibility rows	0	coeffs.
 % 	29	2-terminal SEC rows	102	coeffs.
 % 	1	At least one FST rows	40	coeffs.
 % 	163	Total rows in pool	135	in LP
 % @PMEM 163 rows, 1 blocks, 415 nzfree, 0 nzwasted, 1172 nztotal
DEBUG SOFT: Found 20 terminals, 40 FSTs
DEBUG SOFT: Adding space for 20 not_covered variables in soft constraints, total ncoeff=514
DEBUG LP_SETUP: Created LP with 0 rows, 60 columns (nedges=40 + nterms=20)
DEBUG SOFT: Set bounds for 40 FST vars [1-40] and 20 coverage vars [41-60]
DEBUG OBJ: Using raw costs - alpha=10000.0 (battery weight), beta=1500000 (coverage penalty)
DEBUG OBJ: Allocated rowvec[0-60] for ncols=60 LP variables
DEBUG OBJ: Full_trees battery_score=0.000 for FST 0
DEBUG OBJ: Recalculating for FST 0 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=99.50, running_total=99.50
DEBUG OBJ: Terminal 1 (idx 1): battery=84.60, running_total=184.10
DEBUG OBJ: Terminal 2 (idx 4): battery=100.00, running_total=284.10
DEBUG OBJ: Recalculated battery_score=284.100 for FST 0
DEBUG OBJ: FST 0: tree_cost=398991.100, battery_cost=284.100 (weighted=2841000.0), combined=3239991.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 1
DEBUG OBJ: Recalculating for FST 1 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 10): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 5): battery=99.50, running_total=199.50
DEBUG OBJ: Terminal 2 (idx 4): battery=100.00, running_total=299.50
DEBUG OBJ: Recalculated battery_score=299.500 for FST 1
DEBUG OBJ: FST 1: tree_cost=260889.712, battery_cost=299.500 (weighted=2995000.0), combined=3255889.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 2
DEBUG OBJ: Recalculating for FST 2 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 13): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 0): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 2
DEBUG OBJ: FST 2: tree_cost=256773.057, battery_cost=300.000 (weighted=3000000.0), combined=3256773.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 3
DEBUG OBJ: Recalculating for FST 3 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 3): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 3
DEBUG OBJ: FST 3: tree_cost=376541.557, battery_cost=300.000 (weighted=3000000.0), combined=3376541.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 4
DEBUG OBJ: Recalculating for FST 4 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 3): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 4
DEBUG OBJ: FST 4: tree_cost=646084.462, battery_cost=300.000 (weighted=3000000.0), combined=3646084.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 5
DEBUG OBJ: Recalculating for FST 5 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=48.00, running_total=48.00
DEBUG OBJ: Terminal 1 (idx 2): battery=93.70, running_total=141.70
DEBUG OBJ: Terminal 2 (idx 7): battery=98.00, running_total=239.70
DEBUG OBJ: Recalculated battery_score=239.700 for FST 5
DEBUG OBJ: FST 5: tree_cost=520973.020, battery_cost=239.700 (weighted=2397000.0), combined=2917973.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 6
DEBUG OBJ: Recalculating for FST 6 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 9): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 7): battery=98.00, running_total=196.00
DEBUG OBJ: Terminal 2 (idx 8): battery=98.00, running_total=294.00
DEBUG OBJ: Recalculated battery_score=294.000 for FST 6
DEBUG OBJ: FST 6: tree_cost=334575.182, battery_cost=294.000 (weighted=2940000.0), combined=3274575.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 7
DEBUG OBJ: Recalculating for FST 7 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=48.00, running_total=48.00
DEBUG OBJ: Terminal 1 (idx 2): battery=93.70, running_total=141.70
DEBUG OBJ: Terminal 2 (idx 9): battery=98.00, running_total=239.70
DEBUG OBJ: Recalculated battery_score=239.700 for FST 7
DEBUG OBJ: FST 7: tree_cost=494448.457, battery_cost=239.700 (weighted=2397000.0), combined=2891448.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 8
DEBUG OBJ: Recalculating for FST 8 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=48.00, running_total=48.00
DEBUG OBJ: Terminal 1 (idx 7): battery=98.00, running_total=146.00
DEBUG OBJ: Terminal 2 (idx 9): battery=98.00, running_total=244.00
DEBUG OBJ: Recalculated battery_score=244.000 for FST 8
DEBUG OBJ: FST 8: tree_cost=455905.519, battery_cost=244.000 (weighted=2440000.0), combined=2895905.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 9
DEBUG OBJ: Recalculating for FST 9 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 12): battery=65.00, running_total=65.00
DEBUG OBJ: Terminal 1 (idx 11): battery=48.00, running_total=113.00
DEBUG OBJ: Terminal 2 (idx 9): battery=98.00, running_total=211.00
DEBUG OBJ: Recalculated battery_score=211.000 for FST 9
DEBUG OBJ: FST 9: tree_cost=584020.499, battery_cost=211.000 (weighted=2110000.0), combined=2694020.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 10
DEBUG OBJ: Recalculating for FST 10 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 12): battery=65.00, running_total=165.00
DEBUG OBJ: Terminal 2 (idx 14): battery=72.30, running_total=237.30
DEBUG OBJ: Recalculated battery_score=237.300 for FST 10
DEBUG OBJ: FST 10: tree_cost=380918.244, battery_cost=237.300 (weighted=2373000.0), combined=2753918.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 11
DEBUG OBJ: Recalculating for FST 11 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 15): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 11
DEBUG OBJ: FST 11: tree_cost=621357.781, battery_cost=300.000 (weighted=3000000.0), combined=3621357.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 12
DEBUG OBJ: Recalculating for FST 12 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 9): battery=98.00, running_total=196.00
DEBUG OBJ: Terminal 2 (idx 17): battery=98.00, running_total=294.00
DEBUG OBJ: Recalculated battery_score=294.000 for FST 12
DEBUG OBJ: FST 12: tree_cost=120675.719, battery_cost=294.000 (weighted=2940000.0), combined=3060675.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 13
DEBUG OBJ: Recalculating for FST 13 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=48.00, running_total=48.00
DEBUG OBJ: Terminal 1 (idx 7): battery=98.00, running_total=146.00
DEBUG OBJ: Terminal 2 (idx 8): battery=98.00, running_total=244.00
DEBUG OBJ: Terminal 3 (idx 9): battery=98.00, running_total=342.00
DEBUG OBJ: Recalculated battery_score=342.000 for FST 13
DEBUG OBJ: FST 13: tree_cost=551354.477, battery_cost=342.000 (weighted=3420000.0), combined=3971354.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 14
DEBUG OBJ: Recalculating for FST 14 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 9): battery=98.00, running_total=196.00
DEBUG OBJ: Terminal 2 (idx 7): battery=98.00, running_total=294.00
DEBUG OBJ: Terminal 3 (idx 8): battery=98.00, running_total=392.00
DEBUG OBJ: Recalculated battery_score=392.000 for FST 14
DEBUG OBJ: FST 14: tree_cost=410262.679, battery_cost=392.000 (weighted=3920000.0), combined=4330262.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 15
DEBUG OBJ: Recalculating for FST 15 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 9): battery=98.00, running_total=196.00
DEBUG OBJ: Terminal 2 (idx 7): battery=98.00, running_total=294.00
DEBUG OBJ: Terminal 3 (idx 17): battery=98.00, running_total=392.00
DEBUG OBJ: Recalculated battery_score=392.000 for FST 15
DEBUG OBJ: FST 15: tree_cost=362962.653, battery_cost=392.000 (weighted=3920000.0), combined=4282962.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 16
DEBUG OBJ: Recalculating for FST 16 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=48.00, running_total=48.00
DEBUG OBJ: Terminal 1 (idx 2): battery=93.70, running_total=141.70
DEBUG OBJ: Terminal 2 (idx 7): battery=98.00, running_total=239.70
DEBUG OBJ: Terminal 3 (idx 9): battery=98.00, running_total=337.70
DEBUG OBJ: Recalculated battery_score=337.700 for FST 16
DEBUG OBJ: FST 16: tree_cost=702244.403, battery_cost=337.700 (weighted=3377000.0), combined=4079244.4
DEBUG OBJ: Full_trees battery_score=0.000 for FST 17
DEBUG OBJ: Recalculating for FST 17 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 15): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 3): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 6): battery=100.00, running_total=400.00
DEBUG OBJ: Recalculated battery_score=400.000 for FST 17
DEBUG OBJ: FST 17: tree_cost=673894.542, battery_cost=400.000 (weighted=4000000.0), combined=4673894.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 18
DEBUG OBJ: Recalculating for FST 18 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 15): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 12): battery=65.00, running_total=365.00
DEBUG OBJ: Recalculated battery_score=365.000 for FST 18
DEBUG OBJ: FST 18: tree_cost=933994.022, battery_cost=365.000 (weighted=3650000.0), combined=4583994.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 19
DEBUG OBJ: Recalculating for FST 19 with 5 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 9): battery=98.00, running_total=196.00
DEBUG OBJ: Terminal 2 (idx 7): battery=98.00, running_total=294.00
DEBUG OBJ: Terminal 3 (idx 8): battery=98.00, running_total=392.00
DEBUG OBJ: Terminal 4 (idx 17): battery=98.00, running_total=490.00
DEBUG OBJ: Recalculated battery_score=490.000 for FST 19
DEBUG OBJ: FST 19: tree_cost=454199.906, battery_cost=490.000 (weighted=4900000.0), combined=5354199.9
DEBUG OBJ: Full_trees battery_score=0.000 for FST 20
DEBUG OBJ: Recalculating for FST 20 with 5 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 15): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 3): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 6): battery=100.00, running_total=400.00
DEBUG OBJ: Terminal 4 (idx 12): battery=65.00, running_total=465.00
DEBUG OBJ: Recalculated battery_score=465.000 for FST 20
DEBUG OBJ: FST 20: tree_cost=986439.144, battery_cost=465.000 (weighted=4650000.0), combined=5636439.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 21
DEBUG OBJ: Recalculating for FST 21 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 17): battery=98.00, running_total=196.00
DEBUG OBJ: Recalculated battery_score=196.000 for FST 21
DEBUG OBJ: FST 21: tree_cost=46859.249, battery_cost=196.000 (weighted=1960000.0), combined=2006859.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 22
DEBUG OBJ: Recalculating for FST 22 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 3): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 22
DEBUG OBJ: FST 22: tree_cost=52662.185, battery_cost=200.000 (weighted=2000000.0), combined=2052662.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 23
DEBUG OBJ: Recalculating for FST 23 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 16): battery=70.00, running_total=70.00
DEBUG OBJ: Terminal 1 (idx 2): battery=93.70, running_total=163.70
DEBUG OBJ: Recalculated battery_score=163.700 for FST 23
DEBUG OBJ: FST 23: tree_cost=62275.339, battery_cost=163.700 (weighted=1637000.0), combined=1699275.3
DEBUG OBJ: Full_trees battery_score=0.000 for FST 24
DEBUG OBJ: Recalculating for FST 24 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 16): battery=70.00, running_total=70.00
DEBUG OBJ: Terminal 1 (idx 1): battery=84.60, running_total=154.60
DEBUG OBJ: Recalculated battery_score=154.600 for FST 24
DEBUG OBJ: FST 24: tree_cost=75379.993, battery_cost=154.600 (weighted=1546000.0), combined=1621380.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 25
DEBUG OBJ: Recalculating for FST 25 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 9): battery=98.00, running_total=196.00
DEBUG OBJ: Recalculated battery_score=196.000 for FST 25
DEBUG OBJ: FST 25: tree_cost=75695.846, battery_cost=196.000 (weighted=1960000.0), combined=2035695.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 26
DEBUG OBJ: Recalculating for FST 26 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 14): battery=72.30, running_total=72.30
DEBUG OBJ: Terminal 1 (idx 19): battery=100.00, running_total=172.30
DEBUG OBJ: Recalculated battery_score=172.300 for FST 26
DEBUG OBJ: FST 26: tree_cost=80703.013, battery_cost=172.300 (weighted=1723000.0), combined=1803703.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 27
DEBUG OBJ: Recalculating for FST 27 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 0): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 13): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 27
DEBUG OBJ: FST 27: tree_cost=93734.596, battery_cost=200.000 (weighted=2000000.0), combined=2093734.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 28
DEBUG OBJ: Recalculating for FST 28 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 8): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 7): battery=98.00, running_total=196.00
DEBUG OBJ: Recalculated battery_score=196.000 for FST 28
DEBUG OBJ: FST 28: tree_cost=95452.578, battery_cost=196.000 (weighted=1960000.0), combined=2055452.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 29
DEBUG OBJ: Recalculating for FST 29 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=99.50, running_total=99.50
DEBUG OBJ: Terminal 1 (idx 10): battery=100.00, running_total=199.50
DEBUG OBJ: Recalculated battery_score=199.500 for FST 29
DEBUG OBJ: FST 29: tree_cost=102977.757, battery_cost=199.500 (weighted=1995000.0), combined=2097977.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 30
DEBUG OBJ: Recalculating for FST 30 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 4): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 5): battery=99.50, running_total=199.50
DEBUG OBJ: Recalculated battery_score=199.500 for FST 30
DEBUG OBJ: FST 30: tree_cost=165327.925, battery_cost=199.500 (weighted=1995000.0), combined=2160327.9
DEBUG OBJ: Full_trees battery_score=0.000 for FST 31
DEBUG OBJ: Recalculating for FST 31 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 6): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 0): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 31
DEBUG OBJ: FST 31: tree_cost=170420.027, battery_cost=200.000 (weighted=2000000.0), combined=2170420.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 32
DEBUG OBJ: Recalculating for FST 32 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 13): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 4): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 32
DEBUG OBJ: FST 32: tree_cost=179069.657, battery_cost=200.000 (weighted=2000000.0), combined=2179069.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 33
DEBUG OBJ: Recalculating for FST 33 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=99.50, running_total=99.50
DEBUG OBJ: Terminal 1 (idx 1): battery=84.60, running_total=184.10
DEBUG OBJ: Recalculated battery_score=184.100 for FST 33
DEBUG OBJ: FST 33: tree_cost=234458.486, battery_cost=184.100 (weighted=1841000.0), combined=2075458.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 34
DEBUG OBJ: Recalculating for FST 34 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=48.00, running_total=48.00
DEBUG OBJ: Terminal 1 (idx 9): battery=98.00, running_total=146.00
DEBUG OBJ: Recalculated battery_score=146.000 for FST 34
DEBUG OBJ: FST 34: tree_cost=235891.713, battery_cost=146.000 (weighted=1460000.0), combined=1695891.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 35
DEBUG OBJ: Recalculating for FST 35 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 9): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 7): battery=98.00, running_total=196.00
DEBUG OBJ: Recalculated battery_score=196.000 for FST 35
DEBUG OBJ: FST 35: tree_cost=242462.956, battery_cost=196.000 (weighted=1960000.0), combined=2202463.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 36
DEBUG OBJ: Recalculating for FST 36 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 2): battery=93.70, running_total=93.70
DEBUG OBJ: Terminal 1 (idx 11): battery=48.00, running_total=141.70
DEBUG OBJ: Recalculated battery_score=141.700 for FST 36
DEBUG OBJ: FST 36: tree_cost=258947.370, battery_cost=141.700 (weighted=1417000.0), combined=1675947.4
DEBUG OBJ: Full_trees battery_score=0.000 for FST 37
DEBUG OBJ: Recalculating for FST 37 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 12): battery=65.00, running_total=165.00
DEBUG OBJ: Recalculated battery_score=165.000 for FST 37
DEBUG OBJ: FST 37: tree_cost=313063.098, battery_cost=165.000 (weighted=1650000.0), combined=1963063.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 38
DEBUG OBJ: Recalculating for FST 38 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 19): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 38
DEBUG OBJ: FST 38: tree_cost=314219.517, battery_cost=200.000 (weighted=2000000.0), combined=2314219.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 39
DEBUG OBJ: Recalculating for FST 39 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 3): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 6): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 39
DEBUG OBJ: FST 39: tree_cost=327174.269, battery_cost=200.000 (weighted=2000000.0), combined=2327174.3
DEBUG OBJ: Added penalty terms beta=1500000 for 20 not_covered variables [41-60]
DEBUG LP_MATRIX: LP has 0 rows, 60 columns after setup
DEBUG EXTRA_COEFF: Calculated extra_coeff=1 for 135 rows
DEBUG SOFT: Added not_covered_0 (RC_var 43 -> matrix_idx 40) to soft constraint 134
DEBUG MATRIX_CHECK: nzi=495, ncoeff=514, extra_coeff=1, expected=515
ERROR: Matrix coefficient count mismatch! nzi=495 != ncoeff=514 + extra_coeff=1
WARNING: Allowing discrepancy in budget mode (nzi=495 vs expected=515)
DEBUG MATRIX: Total matrix has 495 entries (nzi=495)
DEBUG MATRIX: matbeg[135] = 495 (should equal nzi)
DEBUG LP: Calling add_rows with 135 rows
DEBUG LP: Before add_rows: LP has 0 rows, 60 cols, 60 nonzeros
DEBUG LP: After add_rows: LP has 135 rows, 60 cols, 555 nonzeros
DEBUG NLPROWS: nrows=135, extra_rows=0, setting nlprows=135
 % _gst_build_initial_formulation: 0.00 seconds.
DEBUG BB: Expected nlprows=135, total rows=163
DEBUG BB: Row 0 (uid=0) has lprow=0 (included, j=0)
DEBUG BB: Row 1 (uid=1) has lprow=1 (included, j=1)
DEBUG BB: Row 2 (uid=2) has lprow=2 (included, j=2)
DEBUG BB: Row 3 (uid=3) has lprow=3 (included, j=3)
DEBUG BB: Row 4 (uid=4) has lprow=4 (included, j=4)
DEBUG BB: Row 5 (uid=5) has lprow=5 (included, j=5)
DEBUG BB: Row 6 (uid=6) has lprow=6 (included, j=6)
DEBUG BB: Row 7 (uid=7) has lprow=7 (included, j=7)
DEBUG BB: Row 8 (uid=8) has lprow=8 (included, j=8)
DEBUG BB: Row 9 (uid=9) has lprow=9 (included, j=9)
DEBUG BB: Row 10 (uid=10) has lprow=10 (included, j=10)
DEBUG BB: Row 11 (uid=11) has lprow=11 (included, j=11)
DEBUG BB: Row 12 (uid=12) has lprow=12 (included, j=12)
DEBUG BB: Row 13 (uid=13) has lprow=13 (included, j=13)
DEBUG BB: Row 14 (uid=14) has lprow=14 (included, j=14)
DEBUG BB: Row 15 (uid=15) has lprow=15 (included, j=15)
DEBUG BB: Row 16 (uid=16) has lprow=16 (included, j=16)
DEBUG BB: Row 17 (uid=17) has lprow=17 (included, j=17)
DEBUG BB: Row 18 (uid=18) has lprow=18 (included, j=18)
DEBUG BB: Row 19 (uid=19) has lprow=19 (included, j=19)
DEBUG BB: Row 20 (uid=20) has lprow=20 (included, j=20)
DEBUG BB: Row 21 (uid=21) has lprow=21 (included, j=21)
DEBUG BB: Row 22 (uid=22) has lprow=22 (included, j=22)
DEBUG BB: Row 23 (uid=23) has lprow=23 (included, j=23)
DEBUG BB: Row 24 (uid=24) has lprow=24 (included, j=24)
DEBUG BB: Row 25 (uid=25) has lprow=25 (included, j=25)
DEBUG BB: Row 26 (uid=26) has lprow=26 (included, j=26)
DEBUG BB: Row 27 (uid=27) has lprow=27 (included, j=27)
DEBUG BB: Row 28 (uid=28) has lprow=28 (included, j=28)
DEBUG BB: Row 29 (uid=29) has lprow=29 (included, j=29)
DEBUG BB: Row 30 (uid=30) has lprow=30 (included, j=30)
DEBUG BB: Row 31 (uid=31) has lprow=31 (included, j=31)
DEBUG BB: Row 32 (uid=32) has lprow=32 (included, j=32)
DEBUG BB: Row 33 (uid=33) has lprow=33 (included, j=33)
DEBUG BB: Row 34 (uid=34) has lprow=34 (included, j=34)
DEBUG BB: Row 35 (uid=35) has lprow=35 (included, j=35)
DEBUG BB: Row 36 (uid=36) has lprow=36 (included, j=36)
DEBUG BB: Row 37 (uid=37) has lprow=37 (included, j=37)
DEBUG BB: Row 38 (uid=38) has lprow=38 (included, j=38)
DEBUG BB: Row 39 (uid=39) has lprow=39 (included, j=39)
DEBUG BB: Row 40 (uid=40) has lprow=40 (included, j=40)
DEBUG BB: Row 41 (uid=41) has lprow=41 (included, j=41)
DEBUG BB: Row 42 (uid=42) has lprow=42 (included, j=42)
DEBUG BB: Row 43 (uid=43) has lprow=43 (included, j=43)
DEBUG BB: Row 44 (uid=44) has lprow=44 (included, j=44)
DEBUG BB: Row 45 (uid=45) has lprow=45 (included, j=45)
DEBUG BB: Row 46 (uid=46) has lprow=46 (included, j=46)
DEBUG BB: Row 47 (uid=47) has lprow=47 (included, j=47)
DEBUG BB: Row 48 (uid=48) has lprow=48 (included, j=48)
DEBUG BB: Row 49 (uid=49) has lprow=49 (included, j=49)
DEBUG BB: Row 50 (uid=50) has lprow=50 (included, j=50)
DEBUG BB: Row 51 (uid=51) has lprow=51 (included, j=51)
DEBUG BB: Row 52 (uid=52) has lprow=52 (included, j=52)
DEBUG BB: Row 53 (uid=53) has lprow=53 (included, j=53)
DEBUG BB: Row 54 (uid=54) has lprow=54 (included, j=54)
DEBUG BB: Row 55 (uid=55) has lprow=55 (included, j=55)
DEBUG BB: Row 56 (uid=56) has lprow=56 (included, j=56)
DEBUG BB: Row 57 (uid=57) has lprow=57 (included, j=57)
DEBUG BB: Row 58 (uid=58) has lprow=58 (included, j=58)
DEBUG BB: Row 59 (uid=59) has lprow=59 (included, j=59)
DEBUG BB: Row 60 (uid=60) has lprow=60 (included, j=60)
DEBUG BB: Row 61 (uid=61) has lprow=61 (included, j=61)
DEBUG BB: Row 62 (uid=62) has lprow=62 (included, j=62)
DEBUG BB: Row 63 (uid=63) has lprow=63 (included, j=63)
DEBUG BB: Row 64 (uid=64) has lprow=64 (included, j=64)
DEBUG BB: Row 65 (uid=65) has lprow=65 (included, j=65)
DEBUG BB: Row 66 (uid=66) has lprow=66 (included, j=66)
DEBUG BB: Row 67 (uid=67) has lprow=67 (included, j=67)
DEBUG BB: Row 68 (uid=68) has lprow=68 (included, j=68)
DEBUG BB: Row 69 (uid=69) has lprow=69 (included, j=69)
DEBUG BB: Row 70 (uid=70) has lprow=70 (included, j=70)
DEBUG BB: Row 71 (uid=71) has lprow=71 (included, j=71)
DEBUG BB: Row 72 (uid=72) has lprow=72 (included, j=72)
DEBUG BB: Row 73 (uid=73) has lprow=73 (included, j=73)
DEBUG BB: Row 74 (uid=74) has lprow=74 (included, j=74)
DEBUG BB: Row 75 (uid=75) has lprow=75 (included, j=75)
DEBUG BB: Row 76 (uid=76) has lprow=76 (included, j=76)
DEBUG BB: Row 77 (uid=77) has lprow=77 (included, j=77)
DEBUG BB: Row 78 (uid=78) has lprow=78 (included, j=78)
DEBUG BB: Row 79 (uid=79) has lprow=79 (included, j=79)
DEBUG BB: Row 80 (uid=80) has lprow=80 (included, j=80)
DEBUG BB: Row 81 (uid=81) has lprow=81 (included, j=81)
DEBUG BB: Row 82 (uid=82) has lprow=82 (included, j=82)
DEBUG BB: Row 83 (uid=83) has lprow=83 (included, j=83)
DEBUG BB: Row 84 (uid=84) has lprow=84 (included, j=84)
DEBUG BB: Row 85 (uid=85) has lprow=85 (included, j=85)
DEBUG BB: Row 86 (uid=86) has lprow=86 (included, j=86)
DEBUG BB: Row 87 (uid=87) has lprow=87 (included, j=87)
DEBUG BB: Row 88 (uid=88) has lprow=88 (included, j=88)
DEBUG BB: Row 89 (uid=89) has lprow=89 (included, j=89)
DEBUG BB: Row 90 (uid=90) has lprow=90 (included, j=90)
DEBUG BB: Row 91 (uid=91) has lprow=91 (included, j=91)
DEBUG BB: Row 92 (uid=92) has lprow=92 (included, j=92)
DEBUG BB: Row 93 (uid=93) has lprow=93 (included, j=93)
DEBUG BB: Row 94 (uid=94) has lprow=94 (included, j=94)
DEBUG BB: Row 95 (uid=95) has lprow=95 (included, j=95)
DEBUG BB: Row 96 (uid=96) has lprow=96 (included, j=96)
DEBUG BB: Row 97 (uid=97) has lprow=97 (included, j=97)
DEBUG BB: Row 98 (uid=98) has lprow=98 (included, j=98)
DEBUG BB: Row 99 (uid=99) has lprow=99 (included, j=99)
DEBUG BB: Row 100 (uid=100) has lprow=100 (included, j=100)
DEBUG BB: Row 101 (uid=101) has lprow=101 (included, j=101)
DEBUG BB: Row 102 (uid=102) has lprow=102 (included, j=102)
DEBUG BB: Row 103 (uid=103) has lprow=103 (included, j=103)
DEBUG BB: Row 104 (uid=104) has lprow=104 (included, j=104)
DEBUG BB: Row 105 (uid=105) has lprow=105 (included, j=105)
DEBUG BB: Row 106 (uid=106) has lprow=106 (included, j=106)
DEBUG BB: Row 107 (uid=107) has lprow=107 (included, j=107)
DEBUG BB: Row 108 (uid=108) has lprow=108 (included, j=108)
DEBUG BB: Row 109 (uid=109) has lprow=109 (included, j=109)
DEBUG BB: Row 110 (uid=110) has lprow=110 (included, j=110)
DEBUG BB: Row 111 (uid=111) has lprow=111 (included, j=111)
DEBUG BB: Row 112 (uid=112) has lprow=112 (included, j=112)
DEBUG BB: Row 113 (uid=113) has lprow=113 (included, j=113)
DEBUG BB: Row 114 (uid=114) has lprow=114 (included, j=114)
DEBUG BB: Row 115 (uid=115) has lprow=115 (included, j=115)
DEBUG BB: Row 116 (uid=116) has lprow=116 (included, j=116)
DEBUG BB: Row 117 (uid=117) has lprow=117 (included, j=117)
DEBUG BB: Row 118 (uid=118) has lprow=118 (included, j=118)
DEBUG BB: Row 119 (uid=119) has lprow=119 (included, j=119)
DEBUG BB: Row 120 (uid=120) has lprow=120 (included, j=120)
DEBUG BB: Row 121 (uid=121) has lprow=121 (included, j=121)
DEBUG BB: Row 122 (uid=122) has lprow=122 (included, j=122)
DEBUG BB: Row 123 (uid=123) has lprow=123 (included, j=123)
DEBUG BB: Row 124 (uid=124) has lprow=124 (included, j=124)
DEBUG BB: Row 125 (uid=125) has lprow=125 (included, j=125)
DEBUG BB: Row 126 (uid=126) has lprow=126 (included, j=126)
DEBUG BB: Row 127 (uid=127) has lprow=127 (included, j=127)
DEBUG BB: Row 128 (uid=128) has lprow=128 (included, j=128)
DEBUG BB: Row 129 (uid=129) has lprow=129 (included, j=129)
DEBUG BB: Row 130 (uid=130) has lprow=130 (included, j=130)
DEBUG BB: Row 131 (uid=131) has lprow=131 (included, j=131)
DEBUG BB: Row 132 (uid=132) has lprow=132 (included, j=132)
DEBUG BB: Row 133 (uid=133) has lprow=-1 (skipped)
DEBUG BB: Row 134 (uid=134) has lprow=-1 (skipped)
DEBUG BB: Row 135 (uid=135) has lprow=-1 (skipped)
DEBUG BB: Row 136 (uid=136) has lprow=-1 (skipped)
DEBUG BB: Row 137 (uid=137) has lprow=-1 (skipped)
DEBUG BB: Row 138 (uid=138) has lprow=-1 (skipped)
DEBUG BB: Row 139 (uid=139) has lprow=-1 (skipped)
DEBUG BB: Row 140 (uid=140) has lprow=-1 (skipped)
DEBUG BB: Row 141 (uid=141) has lprow=-1 (skipped)
DEBUG BB: Row 142 (uid=142) has lprow=-1 (skipped)
DEBUG BB: Row 143 (uid=143) has lprow=-1 (skipped)
DEBUG BB: Row 144 (uid=144) has lprow=-1 (skipped)
DEBUG BB: Row 145 (uid=145) has lprow=-1 (skipped)
DEBUG BB: Row 146 (uid=146) has lprow=-1 (skipped)
DEBUG BB: Row 147 (uid=147) has lprow=-1 (skipped)
DEBUG BB: Row 148 (uid=148) has lprow=-1 (skipped)
DEBUG BB: Row 149 (uid=149) has lprow=-1 (skipped)
DEBUG BB: Row 150 (uid=150) has lprow=-1 (skipped)
DEBUG BB: Row 151 (uid=151) has lprow=-1 (skipped)
DEBUG BB: Row 152 (uid=152) has lprow=-1 (skipped)
DEBUG BB: Row 153 (uid=153) has lprow=-1 (skipped)
DEBUG BB: Row 154 (uid=154) has lprow=-1 (skipped)
DEBUG BB: Row 155 (uid=155) has lprow=-1 (skipped)
DEBUG BB: Row 156 (uid=156) has lprow=-1 (skipped)
DEBUG BB: Row 157 (uid=157) has lprow=-1 (skipped)
DEBUG BB: Row 158 (uid=158) has lprow=-1 (skipped)
DEBUG BB: Row 159 (uid=159) has lprow=-1 (skipped)
DEBUG BB: Row 160 (uid=160) has lprow=-1 (skipped)
DEBUG BB: Row 161 (uid=161) has lprow=133 (included, j=133)
DEBUG BB: Row 162 (uid=162) has lprow=134 (included, j=134)
DEBUG BB: Found 135 actual LP rows, expected 135
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6038600
% Resuming node 0
DEBUG CONSTRNT: LP rows=135, pool->nlprows=135, pool->npend=0
DEBUG CONSTRNT: Checking 135 LP rows (pool tracks 135, total LP rows 135)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 1
DEBUG CONSTRNT: Pool row 1 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 2
DEBUG CONSTRNT: Pool row 2 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 4
DEBUG CONSTRNT: Pool row 4 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=64, expected 64
DEBUG CONSTRNT: Checking LP row 65 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=65, expected 65
DEBUG CONSTRNT: Checking LP row 66 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=66, expected 66
DEBUG CONSTRNT: Checking LP row 67 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=67, expected 67
DEBUG CONSTRNT: Checking LP row 68 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=68, expected 68
DEBUG CONSTRNT: Checking LP row 69 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=69, expected 69
DEBUG CONSTRNT: Checking LP row 70 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=70, expected 70
DEBUG CONSTRNT: Checking LP row 71 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=71, expected 71
DEBUG CONSTRNT: Checking LP row 72 -> pool row 72
DEBUG CONSTRNT: Pool row 72 has lprow=72, expected 72
DEBUG CONSTRNT: Checking LP row 73 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=73, expected 73
DEBUG CONSTRNT: Checking LP row 74 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=74, expected 74
DEBUG CONSTRNT: Checking LP row 75 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=75, expected 75
DEBUG CONSTRNT: Checking LP row 76 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=76, expected 76
DEBUG CONSTRNT: Checking LP row 77 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=77, expected 77
DEBUG CONSTRNT: Checking LP row 78 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=78, expected 78
DEBUG CONSTRNT: Checking LP row 79 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=79, expected 79
DEBUG CONSTRNT: Checking LP row 80 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=80, expected 80
DEBUG CONSTRNT: Checking LP row 81 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=81, expected 81
DEBUG CONSTRNT: Checking LP row 82 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=82, expected 82
DEBUG CONSTRNT: Checking LP row 83 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=83, expected 83
DEBUG CONSTRNT: Checking LP row 84 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=84, expected 84
DEBUG CONSTRNT: Checking LP row 85 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=85, expected 85
DEBUG CONSTRNT: Checking LP row 86 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=86, expected 86
DEBUG CONSTRNT: Checking LP row 87 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=87, expected 87
DEBUG CONSTRNT: Checking LP row 88 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=88, expected 88
DEBUG CONSTRNT: Checking LP row 89 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=89, expected 89
DEBUG CONSTRNT: Checking LP row 90 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=90, expected 90
DEBUG CONSTRNT: Checking LP row 91 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=91, expected 91
DEBUG CONSTRNT: Checking LP row 92 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=92, expected 92
DEBUG CONSTRNT: Checking LP row 93 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=93, expected 93
DEBUG CONSTRNT: Checking LP row 94 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=94, expected 94
DEBUG CONSTRNT: Checking LP row 95 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=95, expected 95
DEBUG CONSTRNT: Checking LP row 96 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=96, expected 96
DEBUG CONSTRNT: Checking LP row 97 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=97, expected 97
DEBUG CONSTRNT: Checking LP row 98 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=98, expected 98
DEBUG CONSTRNT: Checking LP row 99 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=99, expected 99
DEBUG CONSTRNT: Checking LP row 100 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=100, expected 100
DEBUG CONSTRNT: Checking LP row 101 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=101, expected 101
DEBUG CONSTRNT: Checking LP row 102 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=102, expected 102
DEBUG CONSTRNT: Checking LP row 103 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=103, expected 103
DEBUG CONSTRNT: Checking LP row 104 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=104, expected 104
DEBUG CONSTRNT: Checking LP row 105 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=105, expected 105
DEBUG CONSTRNT: Checking LP row 106 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=106, expected 106
DEBUG CONSTRNT: Checking LP row 107 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=107, expected 107
DEBUG CONSTRNT: Checking LP row 108 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=108, expected 108
DEBUG CONSTRNT: Checking LP row 109 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=109, expected 109
DEBUG CONSTRNT: Checking LP row 110 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=110, expected 110
DEBUG CONSTRNT: Checking LP row 111 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=111, expected 111
DEBUG CONSTRNT: Checking LP row 112 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=112, expected 112
DEBUG CONSTRNT: Checking LP row 113 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=113, expected 113
DEBUG CONSTRNT: Checking LP row 114 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=114, expected 114
DEBUG CONSTRNT: Checking LP row 115 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=115, expected 115
DEBUG CONSTRNT: Checking LP row 116 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=116, expected 116
DEBUG CONSTRNT: Checking LP row 117 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=117, expected 117
DEBUG CONSTRNT: Checking LP row 118 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=118, expected 118
DEBUG CONSTRNT: Checking LP row 119 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=119, expected 119
DEBUG CONSTRNT: Checking LP row 120 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=120, expected 120
DEBUG CONSTRNT: Checking LP row 121 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=121, expected 121
DEBUG CONSTRNT: Checking LP row 122 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=122, expected 122
DEBUG CONSTRNT: Checking LP row 123 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=123, expected 123
DEBUG CONSTRNT: Checking LP row 124 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=124, expected 124
DEBUG CONSTRNT: Checking LP row 125 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=125, expected 125
DEBUG CONSTRNT: Checking LP row 126 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=126, expected 126
DEBUG CONSTRNT: Checking LP row 127 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=127, expected 127
DEBUG CONSTRNT: Checking LP row 128 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=128, expected 128
DEBUG CONSTRNT: Checking LP row 129 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=129, expected 129
DEBUG CONSTRNT: Checking LP row 130 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=130, expected 130
DEBUG CONSTRNT: Checking LP row 131 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=131, expected 131
DEBUG CONSTRNT: Checking LP row 132 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=132, expected 132
DEBUG CONSTRNT: Checking LP row 133 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=133, expected 133
DEBUG CONSTRNT: Checking LP row 134 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=134, expected 134
 % @PAP adding 135 rows, 494 nz to LP
DEBUG BB: Processing node 0, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=149, theta=6.333333, up=1.000000
ITER 2: row=1, varin=155, theta=4.000000, up=1.000000
ITER 3: row=1, varin=145, theta=6.000000, up=1.000000
ITER 4: row=1, varin=152, theta=3.333333, up=1.000000
ITER 5: row=1, varin=146, theta=3.500000, up=1.000000
ITER 6: row=1, varin=156, theta=1.250000, up=1.000000
ITER 7: row=1, varin=151, theta=0.333333, up=1.000000
ITER 8: row=134, varin=156, theta=5.532773, up=1.000000
ITER 9: row=134, varin=145, theta=6.658976, up=1.000000
ITER 10: row=134, varin=176, theta=15.998587, up=1.000000
LP PHASE: Switching to primal (iter=46)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=135)
DEBUG SOLUTION: LP solution array indices: FST[136-175], not_covered[176-195]
DEBUG SOLUTION: lp->best_solution[0] = 27330878.672661
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 135 rows, 60 cols, 554 nonzeros, 61 slack, 74 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 61 slack rows
  % @PAP adding 3 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=75, varin=88, theta=1.432857, up=1.000000
ITER 2: row=75, varin=87, theta=0.282324, up=1.000000
ITER 3: row=52, varin=130, theta=0.256465, up=1.000000
ITER 4: row=57, varin=132, theta=1.000000, up=1.000000
ITER 5: row=48, varin=52, theta=3.717676, up=999999999999999983222784.000000
ITER 6: row=1, varin=88, theta=0.333738, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=77)
DEBUG SOLUTION: LP solution array indices: FST[78-117], not_covered[118-137]
DEBUG SOLUTION: lp->best_solution[0] = 27537255.354412
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 77 rows, 60 cols, 361 nonzeros, 7 slack, 70 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 4 rows, 23 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=73, varin=134, theta=0.377144, up=1.000000
ITER 2: row=71, varin=46, theta=0.960392, up=999999999999999983222784.000000
ITER 3: row=74, varin=94, theta=0.017070, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=74)
DEBUG SOLUTION: LP solution array indices: FST[75-114], not_covered[115-134]
DEBUG SOLUTION: lp->best_solution[0] = 27571112.843334
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 74 rows, 60 cols, 365 nonzeros, 2 slack, 72 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=74, varin=72, theta=1.577871, up=999999999999999983222784.000000
ITER 2: row=73, varin=74, theta=1.621386, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=74)
DEBUG SOLUTION: LP solution array indices: FST[75-114], not_covered[115-134]
DEBUG SOLUTION: lp->best_solution[0] = 27585120.458537
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 74 rows, 60 cols, 362 nonzeros, 2 slack, 72 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 0 LP 1 Solution, length = 27585120.458537, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.540462 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.540462 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.250000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.750000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.250000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.250000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.250000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.459538 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.459538 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.459538 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.250000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.250000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.459538 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27585120.458537, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.58512045853663963157 99.9000000000
 % @LN 0.00  27.58512045853663963157 99.9000000000
DEBUG CG: Second cutoff check: z=27585120.458537, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 0 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 0
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.540462
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.540462)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.540462
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.540462)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.250000
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.750000
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.750000)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
  % Initial guess is x19, Z0 = 27610208.0810889        , Z1 = 27585120.4585366        

DEBUG EVAL: Testing var 13 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=66, varin=93, theta=0.270968, up=1.000000
ITER 2: row=36, varin=85, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 13 = 0 gives z=27606793.920966
  % 	x13 = 0,	Z0 = 27606793.9209661        
DEBUG EVAL: First branch cutoff check: z=27606793.920966, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 1
ITER 1: row=66, varin=72, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=46, varin=59, theta=14.811780, up=999999999999999983222784.000000
ITER 3: row=59, varin=40, theta=1.115969, up=999999999999999983222784.000000
ITER 4: row=41, varin=64, theta=0.115969, up=999999999999999983222784.000000
  % 	x13 = 1,	Z1 = 27689788.6973298        
DEBUG EVAL: Second branch cutoff check: z=27689788.697330, best_z=INF, threshold=INF
  %   New best:  x13, Z = 27606793.9209661        
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=46, theta=1.164098, up=999999999999999983222784.000000
ITER 2: row=46, varin=67, theta=0.130636, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=27658047.668953
  % 	x9 = 1,	Z1 = 27658047.6689534        
DEBUG EVAL: First branch cutoff check: z=27658047.668953, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=1, varin=72, theta=1.287028, up=999999999999999983222784.000000
ITER 2: row=46, varin=93, theta=0.129689, up=1.000000
ITER 3: row=36, varin=119, theta=0.126269, up=1.000000
ITER 4: row=56, varin=59, theta=0.740870, up=999999999999999983222784.000000
ITER 5: row=15, varin=18, theta=0.604404, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 27619207.4707006        
DEBUG EVAL: Second branch cutoff check: z=27619207.470701, best_z=INF, threshold=INF
  %   New best:  x9, Z = 27619207.4707006        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=46, varin=72, theta=0.792212, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27597030.700869
  % 	x10 = 1,	Z1 = 27597030.7008689        
DEBUG EVAL: First branch cutoff check: z=27597030.700869, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=93, theta=0.270968, up=1.000000
ITER 2: row=36, varin=85, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27606793.920966
  % 	x19 = 1,	Z1 = 27606793.9209661        
DEBUG EVAL: First branch cutoff check: z=27606793.920966, best_z=INF, threshold=INF
  % Best branch is x9, Z0 = 27619207.4707006        , Z1 = 27658047.6689534        

DEBUG CAREFUL: Final result - returning best.var = 9
DEBUG BB: Branching variable chosen: j=9
 % @NC    1    0	x9 = 0	27619207.470701
 % @NC    2    0	x9 = 1	27658047.668953
 %       0     2 27585120.4585               27619207.4707
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60410f0
% @LO 0.00  27.58512045853663963157 99.9000000000
% @LN 0.00  27.61920747070061210593 99.9000000000
% Resuming node 1 at  27.61920747070061210593
DEBUG CONSTRNT: LP rows=72, pool->nlprows=72, pool->npend=0
DEBUG CONSTRNT: Checking 72 LP rows (pool tracks 72, total LP rows 72)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=64, expected 64
DEBUG CONSTRNT: Checking LP row 65 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=65, expected 65
DEBUG CONSTRNT: Checking LP row 66 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=66, expected 66
DEBUG CONSTRNT: Checking LP row 67 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=67, expected 67
DEBUG CONSTRNT: Checking LP row 68 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=68, expected 68
DEBUG CONSTRNT: Checking LP row 69 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=69, expected 69
DEBUG CONSTRNT: Checking LP row 70 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=70, expected 70
DEBUG CONSTRNT: Checking LP row 71 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=71, expected 71
 % @PAP adding 72 rows, 286 nz to LP
DEBUG BB: Processing node 1, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=72, theta=1.287028, up=999999999999999983222784.000000
ITER 2: row=46, varin=93, theta=0.129689, up=1.000000
ITER 3: row=36, varin=119, theta=0.126269, up=1.000000
ITER 4: row=56, varin=59, theta=0.740870, up=999999999999999983222784.000000
ITER 5: row=15, varin=18, theta=0.604404, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=72)
DEBUG SOLUTION: LP solution array indices: FST[73-112], not_covered[113-132]
DEBUG SOLUTION: lp->best_solution[0] = 27619207.470701
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.879119
DEBUG SOLUTION: lp->best_solution[13] = 0.879119
DEBUG SOLUTION: lp->best_solution[14] = 0.879119
  % @PL 72 rows, 60 cols, 346 nonzeros, 23 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=73, varin=70, theta=0.631689, up=999999999999999983222784.000000
ITER 2: row=75, varin=83, theta=0.229535, up=1.000000
ITER 3: row=7, varin=86, theta=0.185137, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=75)
DEBUG SOLUTION: LP solution array indices: FST[76-115], not_covered[116-135]
DEBUG SOLUTION: lp->best_solution[0] = 27650011.711940
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.814863
DEBUG SOLUTION: lp->best_solution[13] = 0.814863
DEBUG SOLUTION: lp->best_solution[14] = 0.814863
  % @PL 75 rows, 60 cols, 361 nonzeros, 25 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 25 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=66, theta=0.072342, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 27650213.744181
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 291 nonzeros, 0 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 1 LP 1 Solution, length = 27650213.744181, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.822342 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.072342 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.500000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.500000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.177658 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.822342 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.822342 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.177658 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.177658 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.822342 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.177658 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27650213.744181, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.61920747070061210593 99.9000000000
 % @LN 0.00  27.65021374418139288309 99.9000000000
DEBUG CG: Second cutoff check: z=27650213.744181, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 1 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 1
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.822342
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.822342)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.072342
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.072342)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.500000
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.500000
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.177658
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.177658)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
DEBUG CAREFUL: Testing fvar[1] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[4] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
  % Initial guess is x20, Z0 = 27650213.7441814        , Z1 = 27913128.6048456        

DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=44, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=52, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=53, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=31, varin=50, theta=0.077444, up=999999999999999983222784.000000
ITER 5: row=12, varin=7, theta=0.035893, up=999999999999999983222784.000000
ITER 6: row=1, varin=66, theta=0.059996, up=1.000000
DEBUG EVAL: Branch var 13 = 1 gives z=27811835.918645
  % 	x13 = 1,	Z1 = 27811835.9186447        
DEBUG EVAL: First branch cutoff check: z=27811835.918645, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
ITER 1: row=44, varin=51, theta=1.000000, up=999999999999999983222784.000000
  % 	x13 = 0,	Z0 = 27652549.8079414        
DEBUG EVAL: Second branch cutoff check: z=27652549.807941, best_z=INF, threshold=INF
  %   New best:  x13, Z = 27652549.8079414        
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=51, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27652549.807941
  % 	x19 = 1,	Z1 = 27652549.8079414        
DEBUG EVAL: First branch cutoff check: z=27652549.807941, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=25, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=52, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=53, varin=70, theta=1.000000, up=1.000000
ITER 4: row=31, varin=27, theta=0.468705, up=999999999999999983222784.000000
ITER 5: row=8, varin=11, theta=1.857737, up=999999999999999983222784.000000
ITER 6: row=7, varin=50, theta=0.222083, up=999999999999999983222784.000000
ITER 7: row=24, varin=69, theta=0.270211, up=1.000000
  % 	x19 = 0,	Z0 = 27809350.9054241        
DEBUG EVAL: Second branch cutoff check: z=27809350.905424, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=59, theta=0.169285, up=1.000000
ITER 2: row=6, varin=11, theta=0.309693, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27652795.356101
  % 	x10 = 1,	Z1 = 27652795.3561007        
DEBUG EVAL: First branch cutoff check: z=27652795.356101, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=7, varin=7, theta=0.826682, up=999999999999999983222784.000000
ITER 2: row=1, varin=50, theta=0.430524, up=999999999999999983222784.000000
ITER 3: row=31, varin=51, theta=0.692094, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 27676589.02105          
DEBUG EVAL: Second branch cutoff check: z=27676589.021050, best_z=INF, threshold=INF
  %   New best:  x10, Z = 27652795.3561007        
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=51, theta=1.109004, up=999999999999999983222784.000000
ITER 2: row=45, varin=49, theta=0.039688, up=999999999999999983222784.000000
ITER 3: row=25, varin=7, theta=0.700035, up=999999999999999983222784.000000
ITER 4: row=1, varin=5, theta=0.438049, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=27660216.931507
  % 	x12 = 1,	Z1 = 27660216.9315069        
DEBUG EVAL: First branch cutoff check: z=27660216.931507, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=31, varin=50, theta=0.051303, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 27652963.9044802        
DEBUG EVAL: Second branch cutoff check: z=27652963.904480, best_z=INF, threshold=INF
  %   New best:  x12, Z = 27652963.9044802        
DEBUG EVAL: Testing var 20 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=7, theta=0.826682, up=999999999999999983222784.000000
ITER 2: row=1, varin=50, theta=0.903579, up=999999999999999983222784.000000
ITER 3: row=31, varin=51, theta=1.710759, up=999999999999999983222784.000000
ITER 4: row=7, varin=69, theta=1.995851, up=1.000000
ITER 5: row=7, varin=45, theta=0.451846, up=999999999999999983222784.000000
ITER 6: row=44, varin=69, theta=1.255360, up=1.000000
ITER 7: row=44, varin=5, theta=2.910429, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 1 gives z=28117157.518643
  % 	x20 = 1,	Z1 = 28117157.5186427        
DEBUG EVAL: First branch cutoff check: z=28117157.518643, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 0
ITER 1: row=12, varin=59, theta=0.169285, up=1.000000
ITER 2: row=6, varin=11, theta=0.309693, up=999999999999999983222784.000000
  % 	x20 = 0,	Z0 = 27652795.3561007        
DEBUG EVAL: Second branch cutoff check: z=27652795.356101, best_z=INF, threshold=INF
  % Best branch is x12, Z0 = 27652963.9044802        , Z1 = 27660216.9315069        

DEBUG CAREFUL: Final result - returning best.var = 12
DEBUG BB: Branching variable chosen: j=12
 % @NC    3    1	x12 = 0	27652963.904480
 % @NC    4    1	x12 = 1	27660216.931507
 %       1     3 27650213.7442               27652963.9045    x9 D     0     1
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6038600
% @LO 0.00  27.65021374418139288309 99.9000000000
% @LN 0.00  27.65296390448016339292 99.9000000000
% Resuming node 3 at  27.65296390448016339292
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=52, expected 52
 % @PAP adding 53 rows, 231 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=50, theta=0.051303, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 27652963.904480
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 291 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 3 LP 1 Solution, length = 27652963.904480, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.724349 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.500000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.500000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.224349 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.775651 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.775651 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.275651 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.275651 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.775651 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.275651 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27652963.904480, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.65296390448016339292 99.9000000000
 % @LN 0.00  27.65296390448016694563 99.9000000000
DEBUG CG: Second cutoff check: z=27652963.904480, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.724349
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.724349)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.500000
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.500000
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.224349
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.224349)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
DEBUG CAREFUL: Testing fvar[1] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
  % Initial guess is x20, Z0 = 27652963.9044802        , Z1 = 28117157.5186427        

DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=51, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=52, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=7, varin=58, theta=0.341477, up=1.000000
ITER 5: row=6, varin=11, theta=0.829972, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 13 = 1 gives z=27856813.966936
  % 	x13 = 1,	Z1 = 27856813.9669363        
DEBUG EVAL: First branch cutoff check: z=27856813.966936, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
ITER 1: row=31, varin=50, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=7, varin=58, theta=0.279787, up=1.000000
ITER 3: row=6, varin=69, theta=0.101397, up=1.000000
ITER 4: row=8, varin=11, theta=0.156210, up=999999999999999983222784.000000
  % 	x13 = 0,	Z0 = 27692102.5898079        
DEBUG EVAL: Second branch cutoff check: z=27692102.589808, best_z=INF, threshold=INF
  %   New best:  x13, Z = 27692102.5898079        
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=50, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=7, varin=58, theta=0.279787, up=1.000000
ITER 3: row=6, varin=11, theta=0.680033, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27694672.622643
  % 	x19 = 1,	Z1 = 27694672.6226427        
DEBUG EVAL: First branch cutoff check: z=27694672.622643, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=25, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=51, varin=69, theta=1.000000, up=1.000000
ITER 3: row=36, varin=26, theta=0.686599, up=999999999999999983222784.000000
ITER 4: row=52, varin=7, theta=1.256825, up=999999999999999983222784.000000
ITER 5: row=1, varin=27, theta=0.470435, up=999999999999999983222784.000000
ITER 6: row=8, varin=60, theta=0.873707, up=1.000000
ITER 7: row=52, varin=11, theta=1.333250, up=999999999999999983222784.000000
ITER 8: row=24, varin=68, theta=0.270211, up=1.000000
  % 	x19 = 0,	Z0 = 27809350.9054241        
DEBUG EVAL: Second branch cutoff check: z=27809350.905424, best_z=INF, threshold=INF
  %   New best:  x19, Z = 27694672.6226427        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=58, theta=0.239325, up=1.000000
ITER 2: row=6, varin=11, theta=0.581689, up=999999999999999983222784.000000
ITER 3: row=12, varin=69, theta=0.081846, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27661555.513020
  % 	x10 = 1,	Z1 = 27661555.5130204        
DEBUG EVAL: First branch cutoff check: z=27661555.513020, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 20 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=7, theta=0.718985, up=999999999999999983222784.000000
ITER 2: row=1, varin=50, theta=1.710759, up=999999999999999983222784.000000
ITER 3: row=7, varin=68, theta=1.995851, up=1.000000
ITER 4: row=7, varin=45, theta=0.451846, up=999999999999999983222784.000000
ITER 5: row=31, varin=68, theta=1.255360, up=1.000000
ITER 6: row=31, varin=11, theta=4.850715, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 1 gives z=28117157.518643
  % 	x20 = 1,	Z1 = 28117157.5186427        
DEBUG EVAL: First branch cutoff check: z=28117157.518643, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 0
ITER 1: row=12, varin=58, theta=0.204285, up=1.000000
ITER 2: row=6, varin=11, theta=0.426422, up=999999999999999983222784.000000
  % 	x20 = 0,	Z0 = 27657712.6519971        
DEBUG EVAL: Second branch cutoff check: z=27657712.651997, best_z=INF, threshold=INF
  % Best branch is x19, Z0 = 27809350.9054241        , Z1 = 27694672.6226427        

DEBUG CAREFUL: Final result - returning best.var = 19
DEBUG BB: Branching variable chosen: j=19
 % @NC    5    3	x19 = 1	27694672.622643
 % @NC    6    3	x19 = 0	27809350.905424
 %       3     4 27652963.9045               27658047.6690   x12 D     1     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6043950
% @LO 0.00  27.65296390448016694563 99.9000000000
% @LN 0.00  27.65804766895335831123 99.9000000000
% Resuming node 2 at  27.65804766895335831123
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=51, expected 51
 % @PAP adding 72 rows, 286 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=46, theta=1.164098, up=999999999999999983222784.000000
ITER 2: row=46, varin=67, theta=0.130636, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=72)
DEBUG SOLUTION: LP solution array indices: FST[73-112], not_covered[113-132]
DEBUG SOLUTION: lp->best_solution[0] = 27658047.668953
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 72 rows, 60 cols, 346 nonzeros, 4 slack, 68 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=69, varin=42, theta=0.488781, up=999999999999999983222784.000000
ITER 2: row=70, varin=86, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=70)
DEBUG SOLUTION: LP solution array indices: FST[71-110], not_covered[111-130]
DEBUG SOLUTION: lp->best_solution[0] = 27702241.182465
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 70 rows, 60 cols, 335 nonzeros, 1 slack, 69 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 2 LP 1 Solution, length = 27702241.182465, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.649479 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.350521 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.350521 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.350521 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.350521 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=27702241.182465, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 2 at  27.70224118246524014353
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60478a0
% @LO 0.00  27.65804766895335831123 99.9000000000
% @LN 0.00  27.66021693150694460428 99.9000000000
% Resuming node 4 at  27.66021693150694460428
DEBUG CONSTRNT: LP rows=69, pool->nlprows=69, pool->npend=0
DEBUG CONSTRNT: Checking 69 LP rows (pool tracks 69, total LP rows 69)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=64, expected 64
DEBUG CONSTRNT: Checking LP row 65 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=65, expected 65
DEBUG CONSTRNT: Checking LP row 66 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=66, expected 66
DEBUG CONSTRNT: Checking LP row 67 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=67, expected 67
DEBUG CONSTRNT: Checking LP row 68 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=68, expected 68
 % @PAP adding 53 rows, 231 nz to LP
DEBUG BB: Processing node 4, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=51, theta=1.109004, up=999999999999999983222784.000000
ITER 2: row=45, varin=49, theta=0.039688, up=999999999999999983222784.000000
ITER 3: row=25, varin=7, theta=0.700035, up=999999999999999983222784.000000
ITER 4: row=1, varin=5, theta=0.438049, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=7, varin=61, theta=0.000000, up=1.000000
ITER 6: row=31, varin=11, theta=0.357635, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 27659088.406781
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.910591
DEBUG SOLUTION: lp->best_solution[3] = 0.910591
DEBUG SOLUTION: lp->best_solution[4] = 0.910591
DEBUG SOLUTION: lp->best_solution[5] = 2.731774
DEBUG SOLUTION: lp->best_solution[6] = 0.910591
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.910591
DEBUG SOLUTION: lp->best_solution[9] = 0.910591
DEBUG SOLUTION: lp->best_solution[10] = 0.910591
DEBUG SOLUTION: lp->best_solution[11] = 4.642365
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 291 nonzeros, 12 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 23 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=78, theta=1.000000, up=1.000000
ITER 2: row=1, varin=7, theta=2.892917, up=999999999999999983222784.000000
ITER 3: row=7, varin=12, theta=1.785834, up=999999999999999983222784.000000
ITER 4: row=49, varin=110, theta=1.000000, up=1.000000
ITER 5: row=51, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=52, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=7, varin=100, theta=1.214166, up=1.000000
ITER 8: row=7, varin=101, theta=0.214166, up=1.000000
ITER 9: row=53, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=11, varin=75, theta=0.059295, up=1.000000
LP PHASE: Switching to primal (iter=13)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 27820153.415751
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 314 nonzeros, 7 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=54, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=72, theta=0.263158, up=1.000000
ITER 4: row=8, varin=11, theta=1.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 27888609.523550
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.666667
DEBUG SOLUTION: lp->best_solution[7] = 0.666667
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.666667
DEBUG SOLUTION: lp->best_solution[10] = 0.666667
DEBUG SOLUTION: lp->best_solution[11] = 3.666667
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 307 nonzeros, 11 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 11 slack rows
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=100, theta=0.643935, up=1.000000
ITER 2: row=45, varin=55, theta=0.564274, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 27939143.777382
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 278 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=39, theta=0.326826, up=999999999999999983222784.000000
ITER 2: row=49, varin=55, theta=0.552607, up=1.000000
ITER 3: row=48, varin=70, theta=0.518437, up=1.000000
ITER 4: row=33, varin=47, theta=0.086304, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 27963232.242270
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 286 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 6 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=46, theta=1.445603, up=999999999999999983222784.000000
ITER 2: row=49, varin=106, theta=0.184682, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 27973385.243150
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 308 nonzeros, 4 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 4 LP 1 Solution, length = 27973385.243150, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.184682 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.500000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.500000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.184682 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.815318 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.815318 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.815318 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.815318 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.815318 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.815318 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27973385.243150, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 4 at  27.97338524315036423218
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60410f0
% @LO 0.00  27.66021693150694460428 99.9000000000
% @LN 0.00  27.69467262264269891148 99.9000000000
% Resuming node 5 at  27.69467262264269891148
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=48, expected 48
 % @PAP adding 52 rows, 227 nz to LP
DEBUG BB: Processing node 5, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=50, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=7, varin=58, theta=0.279787, up=1.000000
ITER 3: row=6, varin=11, theta=0.680033, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 27694672.622643
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.773322
DEBUG SOLUTION: lp->best_solution[9] = 0.773322
DEBUG SOLUTION: lp->best_solution[10] = 0.773322
DEBUG SOLUTION: lp->best_solution[11] = 4.319967
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 287 nonzeros, 7 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=49, theta=0.064903, up=999999999999999983222784.000000
ITER 2: row=56, varin=70, theta=0.129123, up=1.000000
ITER 3: row=53, varin=6, theta=0.750000, up=999999999999999983222784.000000
ITER 4: row=54, varin=55, theta=3.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 27741927.813786
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.500000
DEBUG SOLUTION: lp->best_solution[9] = 0.500000
DEBUG SOLUTION: lp->best_solution[10] = 0.500000
DEBUG SOLUTION: lp->best_solution[11] = 3.500000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 320 nonzeros, 11 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 11 slack rows
  % Node 5 LP 1 Solution, length = 27741927.813786, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.027857 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.027857 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.972143 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.972143 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.972143 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.972143 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.972143 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.972143 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27741927.813786, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 5 at  27.74192781378586047936
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6043950
% @LO 0.00  27.69467262264269891148 99.9000000000
% @LN 0.00  27.70224118246524014353 99.9000000000
% Resuming node 2 at  27.70224118246524014353
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=47, expected 47
 % @PAP adding 69 rows, 273 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 2 LP 2 Solution, length = 27702241.182465, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.649479 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.350521 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.350521 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.350521 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.350521 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=27702241.182465, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27702241.182465, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.333333
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.649479
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.649479)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
  % Initial guess is x15, Z0 = 27702241.1824652        , Z1 = 27788945.6228819        

DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=69, theta=0.666667, up=999999999999999983222784.000000
ITER 2: row=69, varin=57, theta=14.000000, up=999999999999999983222784.000000
ITER 3: row=57, varin=62, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=64, varin=49, theta=0.116729, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=27901599.830762
  % 	x15 = 1,	Z1 = 27901599.8307617        
DEBUG EVAL: First branch cutoff check: z=27901599.830762, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=1, varin=82, theta=0.500000, up=1.000000
  % 	x15 = 0,	Z0 = 27718690.2265498        
DEBUG EVAL: Second branch cutoff check: z=27718690.226550, best_z=INF, threshold=INF
  %   New best:  x15, Z = 27718690.2265498        
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=69, theta=0.845080, up=999999999999999983222784.000000
ITER 2: row=69, varin=82, theta=1.312504, up=1.000000
ITER 3: row=69, varin=91, theta=0.511365, up=1.000000
ITER 4: row=1, varin=82, theta=4.156063, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x19 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=80, theta=0.774426, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=69)
DEBUG SOLUTION: LP solution array indices: FST[70-109], not_covered[110-129]
DEBUG SOLUTION: lp->best_solution[0] = 27931102.695356
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 69 rows, 60 cols, 333 nonzeros, 0 slack, 69 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 6 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=70, varin=40, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=72, varin=61, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=74, varin=90, theta=0.333333, up=1.000000
ITER 4: row=71, varin=62, theta=0.037037, up=999999999999999983222784.000000
ITER 5: row=75, varin=71, theta=0.266667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=75)
DEBUG SOLUTION: LP solution array indices: FST[76-115], not_covered[116-135]
DEBUG SOLUTION: lp->best_solution[0] = 27958217.959780
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 75 rows, 60 cols, 362 nonzeros, 5 slack, 70 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 4 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=72, varin=40, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=74, varin=70, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=74)
DEBUG SOLUTION: LP solution array indices: FST[75-114], not_covered[115-134]
DEBUG SOLUTION: lp->best_solution[0] = 27981660.764305
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 74 rows, 60 cols, 352 nonzeros, 3 slack, 71 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 2 at  27.98166076430477744452
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60410f0
% @LO 0.00  27.70224118246524014353 99.9000000000
% @LN 0.00  27.74192781378586047936 99.9000000000
% Resuming node 5 at  27.74192781378586047936
DEBUG CONSTRNT: LP rows=71, pool->nlprows=71, pool->npend=0
DEBUG CONSTRNT: Checking 71 LP rows (pool tracks 71, total LP rows 71)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=64, expected 64
DEBUG CONSTRNT: Checking LP row 65 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=65, expected 65
DEBUG CONSTRNT: Checking LP row 66 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=66, expected 66
DEBUG CONSTRNT: Checking LP row 67 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=67, expected 67
DEBUG CONSTRNT: Checking LP row 68 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=68, expected 68
DEBUG CONSTRNT: Checking LP row 69 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=69, expected 69
DEBUG CONSTRNT: Checking LP row 70 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=70, expected 70
 % @PAP adding 48 rows, 215 nz to LP
DEBUG BB: Processing node 5, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 5 LP 2 Solution, length = 27741927.813786, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.027857 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.027857 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.972143 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.972143 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.972143 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.972143 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.972143 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.972143 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27741927.813786, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27741927.813786, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 5 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 5
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.027857
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.027857)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.027857
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.027857)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[2] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x20, Z0 = 27741927.8137859        , Z1 = 28117157.5186427        

DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=6, varin=66, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 7 = 0 gives z=27768969.731957
  % 	x7 = 0,	Z0 = 27768969.7319574        
DEBUG EVAL: First branch cutoff check: z=27768969.731957, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=7, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=8, varin=45, theta=0.663028, up=999999999999999983222784.000000
ITER 3: row=7, varin=27, theta=0.549025, up=999999999999999983222784.000000
ITER 4: row=27, varin=51, theta=0.791573, up=1.000000
ITER 5: row=28, varin=50, theta=0.804100, up=1.000000
ITER 6: row=10, varin=64, theta=1.110098, up=1.000000
ITER 7: row=10, varin=75, theta=0.115369, up=1.000000
ITER 8: row=41, varin=64, theta=1.000000, up=1.000000
ITER 9: row=10, varin=70, theta=0.137389, up=1.000000
ITER 10: row=1, varin=10, theta=0.175569, up=999999999999999983222784.000000
  % 	x7 = 1,	Z1 = 28225531.3643297        
DEBUG EVAL: Second branch cutoff check: z=28225531.364330, best_z=INF, threshold=INF
  %   New best:  x7, Z = 27768969.7319574        
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=6, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=8, varin=7, theta=0.677027, up=999999999999999983222784.000000
ITER 4: row=6, varin=27, theta=0.583842, up=999999999999999983222784.000000
ITER 5: row=27, varin=51, theta=0.935715, up=1.000000
ITER 6: row=28, varin=50, theta=0.952205, up=1.000000
ITER 7: row=10, varin=64, theta=1.180496, up=1.000000
ITER 8: row=10, varin=75, theta=0.204202, up=1.000000
ITER 9: row=41, varin=64, theta=1.000000, up=1.000000
ITER 10: row=10, varin=70, theta=0.278866, up=1.000000
DEBUG EVAL: Branch var 5 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x5 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=66, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 27768969.731957
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 4.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 48 rows, 60 cols, 275 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=71, theta=0.121576, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 27772138.771384
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 4.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 283 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 5 at  27.77213877138399311661
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60410f0
% @LO 0.00  27.74192781378586047936 99.9000000000
% @LN 0.00  27.77213877138399311661 99.9000000000
% Resuming node 5 at  27.77213877138399311661
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=51, expected 51
 % @PAP adding 52 rows, 223 nz to LP
DEBUG BB: Processing node 5, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 5 LP 3 Solution, length = 27772138.771384, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.211757 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.211757 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.121576 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.211757 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.788243 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.788243 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.788243 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.788243 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.788243 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.788243 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27772138.771384, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27772138.771384, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 5 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 5
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.211757
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.211757)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.211757
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.211757)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.121576
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.121576)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.211757
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.211757)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[2] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x18, Z0 = 27772138.771384         , Z1 = 28310398.5212177        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=47, theta=1.292812, up=999999999999999983222784.000000
ITER 2: row=49, varin=55, theta=2.385384, up=1.000000
ITER 3: row=49, varin=54, theta=1.401146, up=1.000000
ITER 4: row=49, varin=44, theta=0.380985, up=999999999999999983222784.000000
ITER 5: row=40, varin=54, theta=3.000000, up=1.000000
ITER 6: row=40, varin=55, theta=2.000000, up=1.000000
ITER 7: row=40, varin=46, theta=2.000000, up=999999999999999983222784.000000
ITER 8: row=6, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=50, varin=7, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=27, varin=20, theta=1.599850, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=52, theta=0.171477, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 27777658.498742
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 4.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 283 nonzeros, 4 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=55, theta=0.173247, up=1.000000
ITER 2: row=28, varin=54, theta=0.173807, up=1.000000
ITER 3: row=10, varin=27, theta=0.581007, up=999999999999999983222784.000000
ITER 4: row=48, varin=53, theta=0.251628, up=1.000000
ITER 5: row=9, varin=56, theta=0.191170, up=1.000000
LP PHASE: Switching to primal (iter=5)
ITER 6: row=27, varin=48, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 27817959.211907
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 4.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 283 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 5 at  27.81795921190714793170
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6049c70
% @LO 0.00  27.77213877138399311661 99.9000000000
% @LN 0.00  27.80935090542410748071 99.9000000000
% Resuming node 6 at  27.80935090542410748071
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=51, expected 51
 % @PAP adding 52 rows, 227 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=51, varin=69, theta=1.000000, up=1.000000
ITER 3: row=36, varin=26, theta=0.686599, up=999999999999999983222784.000000
ITER 4: row=52, varin=7, theta=1.256825, up=999999999999999983222784.000000
ITER 5: row=1, varin=27, theta=0.470435, up=999999999999999983222784.000000
ITER 6: row=8, varin=60, theta=0.873707, up=1.000000
ITER 7: row=52, varin=11, theta=1.333250, up=999999999999999983222784.000000
ITER 8: row=24, varin=68, theta=0.270211, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 27809350.905424
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.816168
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.816168
DEBUG SOLUTION: lp->best_solution[10] = 0.816168
DEBUG SOLUTION: lp->best_solution[11] = 4.448505
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 287 nonzeros, 9 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=7, theta=0.805742, up=999999999999999983222784.000000
ITER 2: row=1, varin=109, theta=0.076216, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 27813213.665948
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.358739
DEBUG SOLUTION: lp->best_solution[7] = 0.358739
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.358739
DEBUG SOLUTION: lp->best_solution[10] = 0.358739
DEBUG SOLUTION: lp->best_solution[11] = 2.434954
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 303 nonzeros, 10 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 10 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=57, theta=0.145462, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 27814877.149598
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 280 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=65, theta=0.091736, up=1.000000
ITER 2: row=46, varin=34, theta=0.015793, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 27819826.382704
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 286 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=33, theta=0.096891, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 27820370.816113
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 284 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=54, theta=0.142455, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 27820462.504580
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 279 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=93, theta=0.133646, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 27820782.173689
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 283 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 6 LP 1 Solution, length = 27820782.173689, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.633646 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.500000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.500000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.133646 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.866354 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.866354 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.366354 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.366354 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.866354 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.366354 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27820782.173689, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 6 at  27.82078217368943739984
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60410f0
% @LO 0.00  27.80935090542410748071 99.9000000000
% @LN 0.00  27.81795921190714793170 99.9000000000
% Resuming node 5 at  27.81795921190714793170
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=48, expected 48
 % @PAP adding 52 rows, 223 nz to LP
DEBUG BB: Processing node 5, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 5 LP 4 Solution, length = 27817959.211907, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.191170 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.205887 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.205887 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.205887 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.794113 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.794113 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.794113 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.794113 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.794113 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.794113 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27817959.211907, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27817959.211907, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 5 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 5
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.191170
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.191170)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.205887
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.205887)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.205887
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.205887)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.205887
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.205887)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x18, Z0 = 27817959.2119071        , Z1 = 28310398.5212177        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=9, theta=1.064625, up=999999999999999983222784.000000
ITER 2: row=9, varin=10, theta=0.735368, up=999999999999999983222784.000000
ITER 3: row=10, varin=28, theta=0.732999, up=999999999999999983222784.000000
ITER 4: row=28, varin=49, theta=0.684808, up=999999999999999983222784.000000
ITER 5: row=40, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=6, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=20, varin=7, theta=0.168479, up=999999999999999983222784.000000
ITER 8: row=46, varin=8, theta=0.121067, up=999999999999999983222784.000000
ITER 9: row=28, varin=20, theta=0.099408, up=999999999999999983222784.000000
ITER 10: row=51, varin=33, theta=0.084322, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28121395.624196
  % 	x3 = 1,	Z1 = 28121395.6241958        
DEBUG EVAL: First branch cutoff check: z=28121395.624196, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=1, varin=27, theta=0.581007, up=999999999999999983222784.000000
ITER 2: row=52, varin=89, theta=0.435516, up=1.000000
  % 	x3 = 0,	Z0 = 27831920.9464266        
DEBUG EVAL: Second branch cutoff check: z=27831920.946427, best_z=INF, threshold=INF
  %   New best:  x3, Z = 27831920.9464266        
DEBUG EVAL: Testing var 20 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=27, theta=3.620225, up=999999999999999983222784.000000
ITER 2: row=52, varin=9, theta=16.184254, up=999999999999999983222784.000000
ITER 3: row=9, varin=49, theta=1.838432, up=999999999999999983222784.000000
ITER 4: row=48, varin=46, theta=4.503953, up=999999999999999983222784.000000
ITER 5: row=6, varin=79, theta=12.819941, up=1.000000
ITER 6: row=6, varin=52, theta=3.443938, up=999999999999999983222784.000000
ITER 7: row=1, varin=53, theta=5.472620, up=1.000000
ITER 8: row=1, varin=68, theta=2.846420, up=1.000000
ITER 9: row=1, varin=74, theta=1.315263, up=1.000000
ITER 10: row=1, varin=76, theta=0.892792, up=1.000000
DEBUG EVAL: Branch var 20 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x20 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=8, varin=20, theta=0.641364, up=999999999999999983222784.000000
ITER 2: row=50, varin=47, theta=0.317342, up=999999999999999983222784.000000
ITER 3: row=51, varin=33, theta=0.271905, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=40, varin=45, theta=0.723090, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 27963978.127721
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.276910
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 4.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 283 nonzeros, 2 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=70, theta=5.000000, up=1.000000
ITER 2: row=1, varin=73, theta=4.000000, up=1.000000
ITER 3: row=1, varin=67, theta=4.500000, up=1.000000
ITER 4: row=1, varin=72, theta=2.333333, up=1.000000
ITER 5: row=1, varin=71, theta=1.333333, up=1.000000
ITER 6: row=1, varin=64, theta=0.500000, up=1.000000
ITER 7: row=39, varin=65, theta=54.722336, up=1.000000
ITER 8: row=39, varin=97, theta=8.375481, up=1.000000
ITER 9: row=39, varin=98, theta=7.375481, up=1.000000
ITER 10: row=39, varin=99, theta=6.375481, up=1.000000
LP PHASE: Switching to primal (iter=52)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 27967171.099336
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 310 nonzeros, 0 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=96, theta=0.566957, up=1.000000
ITER 2: row=51, varin=94, theta=0.608525, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 27976227.544824
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 59 rows, 60 cols, 318 nonzeros, 2 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 1 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=54, theta=0.311248, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 27979537.486081
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 320 nonzeros, 8 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 8 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 5 at  27.97953748608053814451
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6049c70
% @LO 0.00  27.81795921190714793170 99.9000000000
% @LN 0.00  27.82078217368943739984 99.9000000000
% Resuming node 6 at  27.82078217368943739984
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=49, expected 49
 % @PAP adding 49 rows, 223 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 6 LP 2 Solution, length = 27820782.173689, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.633646 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.500000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.500000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.133646 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.866354 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.866354 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.366354 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.366354 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.866354 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.366354 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27820782.173689, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27820782.173689, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 6 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 6
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.633646
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.633646)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.500000
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.500000
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.133646
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.133646)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
DEBUG CAREFUL: Testing fvar[1] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 16
DEBUG CAREFUL: Testing fvar[2] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x20, Z0 = 27820782.1736894        , Z1 = 28117157.5186427        

DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=48, theta=0.666667, up=999999999999999983222784.000000
ITER 2: row=23, varin=43, theta=1.164879, up=999999999999999983222784.000000
ITER 3: row=6, varin=67, theta=0.235314, up=1.000000
DEBUG EVAL: Branch var 13 = 1 gives z=27905366.856858
  % 	x13 = 1,	Z1 = 27905366.8568576        
DEBUG EVAL: First branch cutoff check: z=27905366.856858, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
ITER 1: row=35, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=23, varin=49, theta=2.857793, up=999999999999999983222784.000000
ITER 3: row=1, varin=38, theta=0.970091, up=999999999999999983222784.000000
ITER 4: row=44, varin=46, theta=1.824462, up=999999999999999983222784.000000
ITER 5: row=34, varin=40, theta=0.532621, up=999999999999999983222784.000000
ITER 6: row=45, varin=37, theta=0.372192, up=999999999999999983222784.000000
  % 	x13 = 0,	Z0 = 27933524.1208214        
DEBUG EVAL: Second branch cutoff check: z=27933524.120821, best_z=INF, threshold=INF
  %   New best:  x13, Z = 27905366.8568576        
DEBUG EVAL: Testing var 16 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=23, varin=49, theta=2.857793, up=999999999999999983222784.000000
ITER 3: row=1, varin=43, theta=0.586061, up=999999999999999983222784.000000
ITER 4: row=7, varin=60, theta=0.143567, up=1.000000
DEBUG EVAL: Branch var 16 = 0 gives z=27844775.154671
  % 	x16 = 0,	Z0 = 27844775.1546715        
DEBUG EVAL: First branch cutoff check: z=27844775.154671, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 20 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=49, theta=0.923454, up=999999999999999983222784.000000
ITER 2: row=1, varin=48, theta=0.502475, up=999999999999999983222784.000000
ITER 3: row=28, varin=46, theta=1.426788, up=999999999999999983222784.000000
ITER 4: row=34, varin=47, theta=3.988293, up=999999999999999983222784.000000
ITER 5: row=1, varin=23, theta=2.017773, up=999999999999999983222784.000000
ITER 6: row=23, varin=43, theta=3.329995, up=999999999999999983222784.000000
ITER 7: row=6, varin=35, theta=1.053000, up=999999999999999983222784.000000
ITER 8: row=37, varin=48, theta=0.326225, up=999999999999999983222784.000000
ITER 9: row=41, varin=5, theta=2.926213, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 1 gives z=28123436.677726
  % 	x20 = 1,	Z1 = 28123436.6777257        
DEBUG EVAL: First branch cutoff check: z=28123436.677726, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 0
ITER 1: row=7, varin=42, theta=0.127334, up=999999999999999983222784.000000
  % 	x20 = 0,	Z0 = 27821865.4245956        
DEBUG EVAL: Second branch cutoff check: z=27821865.424596, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=42, theta=0.215448, up=999999999999999983222784.000000
ITER 2: row=7, varin=49, theta=0.327071, up=999999999999999983222784.000000
ITER 3: row=1, varin=46, theta=0.126133, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27830041.771926
  % 	x10 = 1,	Z1 = 27830041.7719262        
DEBUG EVAL: First branch cutoff check: z=27830041.771926, best_z=INF, threshold=INF
  % Best branch is x13, Z0 = 27933524.1208214        , Z1 = 27905366.8568576        

DEBUG CAREFUL: Final result - returning best.var = 13
DEBUG BB: Branching variable chosen: j=13
 % @NC    7    6	x13 = 1	27905366.856858
 % @NC    8    6	x13 = 0	27933524.120821
 %       6     5 27820782.1737               27905366.8569   x19 D     3     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6038600
% @LO 0.00  27.82078217368943739984 99.9000000000
% @LN 0.00  27.90536685685756879138 99.9000000000
% Resuming node 7 at  27.90536685685756879138
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=48, expected 48
 % @PAP adding 49 rows, 223 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=48, theta=0.666667, up=999999999999999983222784.000000
ITER 2: row=23, varin=43, theta=1.164879, up=999999999999999983222784.000000
ITER 3: row=6, varin=67, theta=0.235314, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 27905366.856858
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 283 nonzeros, 3 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=65, theta=0.064584, up=1.000000
ITER 2: row=52, varin=57, theta=0.288201, up=1.000000
ITER 3: row=24, varin=56, theta=0.288987, up=1.000000
ITER 4: row=9, varin=73, theta=0.239271, up=1.000000
ITER 5: row=51, varin=54, theta=0.276199, up=999999999999999983222784.000000
ITER 6: row=50, varin=9, theta=0.082449, up=999999999999999983222784.000000
ITER 7: row=24, varin=24, theta=0.081832, up=999999999999999983222784.000000
ITER 8: row=52, varin=51, theta=0.162720, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 27934897.518356
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 305 nonzeros, 5 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=56, theta=0.064258, up=1.000000
ITER 2: row=24, varin=55, theta=0.064620, up=1.000000
ITER 3: row=9, varin=54, theta=0.110484, up=1.000000
ITER 4: row=8, varin=57, theta=0.076768, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 27950636.239913
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 291 nonzeros, 0 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 7 LP 1 Solution, length = 27950636.239913, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.076768 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.141077 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.141077 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.141077 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.141077 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.858923 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.858923 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.858923 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.858923 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.858923 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.858923 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27950636.239913, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 7 at  27.95063623991340051589
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6041ff0
% @LO 0.00  27.90536685685756879138 99.9000000000
% @LN 0.00  27.93352412082139579752 99.9000000000
% Resuming node 8 at  27.93352412082139579752
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=52, expected 52
 % @PAP adding 49 rows, 223 nz to LP
DEBUG BB: Processing node 8, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=23, varin=49, theta=2.857793, up=999999999999999983222784.000000
ITER 3: row=1, varin=38, theta=0.970091, up=999999999999999983222784.000000
ITER 4: row=44, varin=46, theta=1.824462, up=999999999999999983222784.000000
ITER 5: row=34, varin=40, theta=0.532621, up=999999999999999983222784.000000
ITER 6: row=45, varin=37, theta=0.372192, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 27933524.120821
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 283 nonzeros, 6 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=47, theta=0.889229, up=999999999999999983222784.000000
ITER 2: row=52, varin=60, theta=0.307198, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 27940952.312376
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 295 nonzeros, 7 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=37, theta=0.260616, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 27947909.496855
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 274 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 8 LP 1 Solution, length = 27947909.496855, 0.01 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.239384 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.260616 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.369692 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.369692 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.630308 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.630308 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.739384 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.630308 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.630308 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.630308 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.630308 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27947909.496855, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.01  27.93352412082139579752 99.9000000000
 % @LN 0.01  27.94790949685460290652 99.9000000000
DEBUG CG: Second cutoff check: z=27947909.496855, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 8 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 8
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.239384
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.239384)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.260616
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.260616)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.369692
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.369692)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.369692
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.369692)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[3] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
  % Initial guess is x7, Z0 = 27947909.4968546        , Z1 = 27957078.6449998        

DEBUG EVAL: Testing var 16 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=39, theta=1.019895, up=999999999999999983222784.000000
ITER 2: row=44, varin=38, theta=0.656772, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 16 = 0 gives z=28000450.967655
  % 	x16 = 0,	Z0 = 28000450.9676548        
DEBUG EVAL: First branch cutoff check: z=28000450.967655, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 1
ITER 1: row=6, varin=45, theta=3.889148, up=999999999999999983222784.000000
ITER 2: row=35, varin=43, theta=0.781383, up=999999999999999983222784.000000
ITER 3: row=7, varin=56, theta=0.919553, up=1.000000
  % 	x16 = 1,	Z1 = 28000805.8362139        
DEBUG EVAL: Second branch cutoff check: z=28000805.836214, best_z=INF, threshold=INF
  %   New best:  x16, Z = 28000450.9676548        
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=45, theta=0.441196, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=27955869.679566
  % 	x15 = 0,	Z0 = 27955869.6795661        
DEBUG EVAL: First branch cutoff check: z=27955869.679566, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=43, theta=0.217454, up=999999999999999983222784.000000
ITER 2: row=7, varin=56, theta=0.255906, up=1.000000
DEBUG EVAL: Branch var 14 = 0 gives z=27957609.147766
  % 	x14 = 0,	Z0 = 27957609.1477658        
DEBUG EVAL: First branch cutoff check: z=27957609.147766, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=43, theta=0.447819, up=999999999999999983222784.000000
ITER 2: row=43, varin=56, theta=1.467219, up=1.000000
ITER 3: row=43, varin=5, theta=7.326669, up=999999999999999983222784.000000
ITER 4: row=5, varin=35, theta=0.165642, up=999999999999999983222784.000000
ITER 5: row=34, varin=56, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28070741.994139
  % 	x7 = 1,	Z1 = 28070741.9941394        
DEBUG EVAL: First branch cutoff check: z=28070741.994139, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=1, varin=56, theta=0.202854, up=1.000000
  % 	x7 = 0,	Z0 = 27955512.792039         
DEBUG EVAL: Second branch cutoff check: z=27955512.792039, best_z=INF, threshold=INF
  % Best branch is x16, Z0 = 28000450.9676548        , Z1 = 28000805.8362139        

DEBUG CAREFUL: Final result - returning best.var = 16
DEBUG BB: Branching variable chosen: j=16
 % @NC    9    8	x16 = 0	28000450.967655
 % @NC   10    8	x16 = 1	28000805.836214
 %       8     6 27947909.4969               27950636.2399   x13 D     6     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6038600
% @LO 0.01  27.94790949685460290652 99.9000000000
% @LN 0.01  27.95063623991340051589 99.9000000000
% Resuming node 7 at  27.95063623991340051589
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=44, expected 44
 % @PAP adding 53 rows, 231 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 7 LP 2 Solution, length = 27950636.239913, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.076768 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.141077 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.141077 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.141077 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.141077 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.858923 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.858923 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.858923 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.858923 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.858923 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.858923 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27950636.239913, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27950636.239913, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.076768
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.076768)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.141077
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.141077)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.141077
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.141077)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.141077
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.141077)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.141077
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.141077)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x18, Z0 = 27950636.2399134        , Z1 = 28310398.5212177        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=8, theta=1.328712, up=999999999999999983222784.000000
ITER 2: row=8, varin=9, theta=0.777139, up=999999999999999983222784.000000
ITER 3: row=9, varin=24, theta=0.772787, up=999999999999999983222784.000000
ITER 4: row=24, varin=50, theta=1.025921, up=999999999999999983222784.000000
ITER 5: row=48, varin=48, theta=0.550348, up=999999999999999983222784.000000
ITER 6: row=41, varin=70, theta=0.250000, up=1.000000
ITER 7: row=43, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=24, varin=46, theta=0.240732, up=999999999999999983222784.000000
ITER 9: row=46, varin=44, theta=0.721158, up=999999999999999983222784.000000
ITER 10: row=34, varin=19, theta=0.176639, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28301314.551376
  % 	x3 = 1,	Z1 = 28301314.551376         
DEBUG EVAL: First branch cutoff check: z=28301314.551376, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=1, varin=80, theta=0.113756, up=1.000000
  % 	x3 = 0,	Z0 = 27953945.8255267        
DEBUG EVAL: Second branch cutoff check: z=27953945.825527, best_z=INF, threshold=INF
  %   New best:  x3, Z = 27953945.8255267        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=48, varin=19, theta=1.230620, up=999999999999999983222784.000000
ITER 2: row=51, varin=47, theta=2.599199, up=999999999999999983222784.000000
ITER 3: row=52, varin=8, theta=18.604687, up=999999999999999983222784.000000
ITER 4: row=8, varin=80, theta=14.737225, up=1.000000
ITER 5: row=8, varin=23, theta=3.015668, up=999999999999999983222784.000000
ITER 6: row=49, varin=29, theta=1.620923, up=999999999999999983222784.000000
ITER 7: row=53, varin=49, theta=3.504703, up=999999999999999983222784.000000
ITER 8: row=19, varin=36, theta=5.481781, up=999999999999999983222784.000000
ITER 9: row=36, varin=75, theta=6.466081, up=1.000000
ITER 10: row=36, varin=76, theta=5.382228, up=1.000000
DEBUG EVAL: Branch var 18 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=36, theta=0.875644, up=999999999999999983222784.000000
ITER 2: row=1, varin=50, theta=0.108402, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 27982789.676495
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 291 nonzeros, 6 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 6 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=54, theta=0.235470, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 27983172.772257
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 285 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=80, theta=0.086662, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 27986858.989557
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 291 nonzeros, 0 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 7 at  27.98685898955687534340
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60478a0
% @LO 0.01  27.95063623991340051589 99.9000000000
% @LN 0.01  27.97338524315036423218 99.9000000000
% Resuming node 4 at  27.97338524315036423218
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=52, expected 52
 % @PAP adding 49 rows, 224 nz to LP
DEBUG BB: Processing node 4, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 4 LP 2 Solution, length = 27973385.243150, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.184682 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.500000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.500000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.184682 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.815318 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.815318 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.815318 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.815318 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.815318 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.815318 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27973385.243150, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27973385.243150, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 4 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 4
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.184682
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.184682)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.500000
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.500000
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.184682
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.184682)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[1] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[2] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x20, Z0 = 27973385.2431504        , Z1 = 28117157.5186427        

DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=7, varin=49, theta=0.158899, up=999999999999999983222784.000000
ITER 3: row=1, varin=46, theta=0.162254, up=999999999999999983222784.000000
ITER 4: row=33, varin=42, theta=0.535120, up=999999999999999983222784.000000
ITER 5: row=42, varin=28, theta=0.535120, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 16 = 1 gives z=28025521.739149
  % 	x16 = 1,	Z1 = 28025521.7391486        
DEBUG EVAL: First branch cutoff check: z=28025521.739149, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=6, varin=34, theta=0.250000, up=999999999999999983222784.000000
  % 	x16 = 0,	Z0 = 28022046.137397         
DEBUG EVAL: Second branch cutoff check: z=28022046.137397, best_z=INF, threshold=INF
  %   New best:  x16, Z = 28022046.137397         
DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=67, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 13 = 1 gives z=28043920.562371
  % 	x13 = 1,	Z1 = 28043920.5623711        
DEBUG EVAL: First branch cutoff check: z=28043920.562371, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
ITER 1: row=34, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=7, varin=49, theta=0.158899, up=999999999999999983222784.000000
ITER 3: row=1, varin=46, theta=0.162254, up=999999999999999983222784.000000
ITER 4: row=33, varin=42, theta=0.535120, up=999999999999999983222784.000000
ITER 5: row=42, varin=34, theta=0.139225, up=999999999999999983222784.000000
  % 	x13 = 0,	Z0 = 28020939.8177181        
DEBUG EVAL: Second branch cutoff check: z=28020939.817718, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 20 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=49, theta=3.012381, up=999999999999999983222784.000000
ITER 2: row=1, varin=46, theta=3.244957, up=999999999999999983222784.000000
ITER 3: row=33, varin=45, theta=2.926696, up=999999999999999983222784.000000
ITER 4: row=48, varin=34, theta=2.021988, up=999999999999999983222784.000000
ITER 5: row=34, varin=35, theta=28.163311, up=999999999999999983222784.000000
ITER 6: row=27, varin=58, theta=3.285546, up=1.000000
ITER 7: row=27, varin=57, theta=2.709479, up=1.000000
ITER 8: row=27, varin=52, theta=0.797410, up=1.000000
ITER 9: row=6, varin=57, theta=3.368861, up=1.000000
ITER 10: row=6, varin=58, theta=2.827366, up=1.000000
DEBUG EVAL: Branch var 20 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x20 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=7, varin=47, theta=0.553345, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 27979657.303451
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 284 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=68, theta=0.121597, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28006420.273589
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 284 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=71, theta=0.139007, up=1.000000
ITER 2: row=51, varin=19, theta=0.015560, up=999999999999999983222784.000000
ITER 3: row=53, varin=34, theta=0.164901, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28011089.616660
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 306 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 4 at  28.01108961665976337940
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60410f0
% @LO 0.01  27.97338524315036423218 99.9000000000
% @LN 0.01  27.97953748608053814451 99.9000000000
% Resuming node 5 at  27.97953748608053814451
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=51, expected 51
 % @PAP adding 50 rows, 230 nz to LP
DEBUG BB: Processing node 5, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 5 LP 5 Solution, length = 27979537.486081, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.038906 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.038906 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.500000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.961094 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.961094 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.961094 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.961094 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.961094 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27979537.486081, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27979537.486081, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 5 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 5
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.038906
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.038906)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.038906
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.038906)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.500000
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[2] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[3] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x18, Z0 = 27979537.4860805        , Z1 = 28310398.5212177        

DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=47, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=47, varin=49, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28011889.359219
  % 	x34 = 1,	Z1 = 28011889.3592188        
DEBUG EVAL: First branch cutoff check: z=28011889.359219, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=37, varin=50, theta=1.000000, up=999999999999999983222784.000000
  % 	x34 = 0,	Z0 = 27994787.1032374        
DEBUG EVAL: Second branch cutoff check: z=27994787.103237, best_z=INF, threshold=INF
  %   New best:  x34, Z = 27994787.1032374        
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=75, theta=2.000000, up=1.000000
ITER 2: row=1, varin=95, theta=0.500000, up=1.000000
ITER 3: row=3, varin=92, theta=1.000000, up=1.000000
ITER 4: row=12, varin=75, theta=0.454545, up=1.000000
ITER 5: row=18, varin=104, theta=1.000000, up=1.000000
ITER 6: row=30, varin=44, theta=0.303328, up=999999999999999983222784.000000
ITER 7: row=18, varin=77, theta=0.240739, up=1.000000
ITER 8: row=25, varin=18, theta=0.662574, up=999999999999999983222784.000000
ITER 9: row=2, varin=104, theta=1.166695, up=1.000000
ITER 10: row=2, varin=25, theta=0.077051, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28225531.364330
  % 	x7 = 1,	Z1 = 28225531.3643297        
DEBUG EVAL: First branch cutoff check: z=28225531.364330, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=1, varin=50, theta=1.000000, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 27994787.1032373        
DEBUG EVAL: Second branch cutoff check: z=27994787.103237, best_z=INF, threshold=INF
  %   New best:  x7, Z = 27994787.1032373        
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=43, varin=75, theta=2.000000, up=1.000000
ITER 2: row=43, varin=49, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=3, varin=75, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 36 = 0 gives z=28011889.359219
  % 	x36 = 0,	Z0 = 28011889.3592188        
DEBUG EVAL: First branch cutoff check: z=28011889.359219, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 1
ITER 1: row=43, varin=50, theta=1.000000, up=999999999999999983222784.000000
  % 	x36 = 1,	Z1 = 27994787.1032374        
DEBUG EVAL: Second branch cutoff check: z=27994787.103237, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=50, theta=5.361797, up=999999999999999983222784.000000
ITER 2: row=1, varin=75, theta=24.151810, up=1.000000
ITER 3: row=1, varin=25, theta=2.587149, up=999999999999999983222784.000000
ITER 4: row=46, varin=77, theta=6.350307, up=1.000000
ITER 5: row=46, varin=49, theta=36.012470, up=999999999999999983222784.000000
ITER 6: row=43, varin=72, theta=4.270428, up=1.000000
ITER 7: row=43, varin=66, theta=3.281538, up=1.000000
ITER 8: row=43, varin=74, theta=7.720849, up=1.000000
ITER 9: row=43, varin=73, theta=2.041997, up=1.000000
ITER 10: row=43, varin=76, theta=1.191815, up=1.000000
DEBUG EVAL: Branch var 18 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=75, theta=0.679556, up=1.000000
ITER 2: row=3, varin=44, theta=0.134233, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
ITER 3: row=3, varin=3, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 27985053.519843
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 290 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=93, theta=0.065595, up=1.000000
ITER 2: row=8, varin=76, theta=0.192441, up=1.000000
ITER 3: row=3, varin=37, theta=51158.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 27985843.675614
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 292 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 5 at  27.98584367561350916276
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6043950
% @LO 0.01  27.97953748608053814451 99.9000000000
% @LN 0.01  27.98166076430477744452 99.9000000000
% Resuming node 2 at  27.98166076430477744452
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=49, expected 49
 % @PAP adding 71 rows, 277 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 2 LP 3 Solution, length = 27981660.764305, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.077098 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.922902 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.922902 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=27981660.764305, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27981660.764305, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.077098
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.077098)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x14, Z0 = 27981660.7643048        , Z1 = 28008959.6042819        

DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=47, varin=68, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=69, varin=66, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=1, varin=84, theta=0.725433, up=1.000000
ITER 4: row=68, varin=65, theta=0.147484, up=999999999999999983222784.000000
ITER 5: row=65, varin=67, theta=0.300190, up=999999999999999983222784.000000
ITER 6: row=60, varin=93, theta=4.052343, up=1.000000
DEBUG EVAL: Branch var 14 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x14 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=84, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=71)
DEBUG SOLUTION: LP solution array indices: FST[72-111], not_covered[112-131]
DEBUG SOLUTION: lp->best_solution[0] = 27994605.155276
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 71 rows, 60 cols, 337 nonzeros, 0 slack, 71 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=72, varin=96, theta=0.270968, up=1.000000
ITER 2: row=36, varin=71, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=75)
DEBUG SOLUTION: LP solution array indices: FST[76-115], not_covered[116-135]
DEBUG SOLUTION: lp->best_solution[0] = 28003327.366141
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 75 rows, 60 cols, 353 nonzeros, 4 slack, 71 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 2 at  28.00332736614068807057
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60410f0
% @LO 0.01  27.98166076430477744452 99.9000000000
% @LN 0.01  27.98584367561350916276 99.9000000000
% Resuming node 5 at  27.98584367561350916276
DEBUG CONSTRNT: LP rows=71, pool->nlprows=71, pool->npend=0
DEBUG CONSTRNT: Checking 71 LP rows (pool tracks 71, total LP rows 71)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=64, expected 64
DEBUG CONSTRNT: Checking LP row 65 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=65, expected 65
DEBUG CONSTRNT: Checking LP row 66 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=66, expected 66
DEBUG CONSTRNT: Checking LP row 67 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=67, expected 67
DEBUG CONSTRNT: Checking LP row 68 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=68, expected 68
DEBUG CONSTRNT: Checking LP row 69 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=69, expected 69
DEBUG CONSTRNT: Checking LP row 70 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=70, expected 70
 % @PAP adding 50 rows, 192 nz to LP
DEBUG BB: Processing node 5, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 5 LP 6 Solution, length = 27985843.675614, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.500000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=27985843.675614, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27985843.675614, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 5 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 5
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.500000
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[2] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x7, Z0 = 27994787.1032373        , Z1 = 28225531.3643297        

DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=6, varin=95, theta=0.400000, up=1.000000
ITER 3: row=18, varin=104, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28002421.419595
  % 	x34 = 0,	Z0 = 28002421.4195953        
DEBUG EVAL: First branch cutoff check: z=28002421.419595, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 1
ITER 1: row=25, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=48, varin=66, theta=0.500000, up=1.000000
ITER 3: row=37, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=6, varin=95, theta=0.400000, up=1.000000
ITER 5: row=18, varin=104, theta=1.000000, up=1.000000
  % 	x34 = 1,	Z1 = 28306864.6758021        
DEBUG EVAL: Second branch cutoff check: z=28306864.675802, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28002421.4195953        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=48, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=6, varin=95, theta=0.400000, up=1.000000
ITER 4: row=18, varin=104, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28110972.962711
  % 	x7 = 0,	Z0 = 28110972.9627111        
DEBUG EVAL: First branch cutoff check: z=28110972.962711, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=1, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=6, varin=95, theta=0.400000, up=1.000000
ITER 3: row=18, varin=104, theta=1.000000, up=1.000000
  % 	x7 = 1,	Z1 = 28225531.3643297        
DEBUG EVAL: Second branch cutoff check: z=28225531.364330, best_z=INF, threshold=INF
  %   New best:  x7, Z = 28110972.9627111        
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=46, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=48, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=6, varin=95, theta=0.400000, up=1.000000
ITER 4: row=50, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=18, varin=104, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 36 = 1 gives z=28482812.045538
  % 	x36 = 1,	Z1 = 28482812.0455377        
DEBUG EVAL: First branch cutoff check: z=28482812.045538, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=46, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=6, varin=95, theta=0.400000, up=1.000000
ITER 3: row=18, varin=104, theta=1.000000, up=1.000000
  % 	x36 = 0,	Z0 = 28011889.3592188        
DEBUG EVAL: Second branch cutoff check: z=28011889.359219, best_z=INF, threshold=INF
  % Best branch is x7, Z0 = 28110972.9627111        , Z1 = 28225531.3643297        

DEBUG CAREFUL: Final result - returning best.var = 7
DEBUG BB: Branching variable chosen: j=7
 % @NC   11    5	x7 = 0	28110972.962711
 % @NC   12    5	x7 = 1	28225531.364330
 %       5     7 27985843.6756               27986858.9896   x19 U     3     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6038600
% @LO 0.01  27.98584367561350916276 99.9000000000
% @LN 0.01  27.98685898955687534340 99.9000000000
% Resuming node 7 at  27.98685898955687534340
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=49, expected 49
 % @PAP adding 53 rows, 231 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 7 LP 3 Solution, length = 27986858.989557, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.182668 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.182668 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.182668 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.182668 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.086662 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.817332 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.817332 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.817332 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.817332 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.817332 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.817332 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27986858.989557, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27986858.989557, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.182668
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.182668)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.182668
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.182668)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.182668
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.182668)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.182668
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.182668)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.086662
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.086662)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
  % Initial guess is x3, Z0 = 27986858.9895569        , Z1 = 28301314.551376         

DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=47, varin=51, theta=0.623024, up=999999999999999983222784.000000
ITER 2: row=1, varin=48, theta=0.535626, up=999999999999999983222784.000000
ITER 3: row=40, varin=8, theta=0.195721, up=999999999999999983222784.000000
ITER 4: row=8, varin=46, theta=0.965938, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28037357.881613
  % 	x26 = 1,	Z1 = 28102346.489367         
DEBUG EVAL: First branch cutoff check: z=28102346.489367, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=47, varin=90, theta=0.155435, up=1.000000
  % 	x26 = 0,	Z0 = 27988702.0455315        
DEBUG EVAL: Second branch cutoff check: z=27988702.045532, best_z=INF, threshold=INF
  %   New best:  x26, Z = 27988702.0455315        
DEBUG EVAL: Testing var 20 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=48, theta=3.212434, up=999999999999999983222784.000000
ITER 2: row=40, varin=8, theta=4.286979, up=999999999999999983222784.000000
ITER 3: row=8, varin=51, theta=5.270393, up=999999999999999983222784.000000
ITER 4: row=47, varin=23, theta=4.210506, up=999999999999999983222784.000000
ITER 5: row=23, varin=75, theta=4.631952, up=1.000000
ITER 6: row=23, varin=76, theta=3.576235, up=1.000000
ITER 7: row=23, varin=45, theta=2.418850, up=999999999999999983222784.000000
ITER 8: row=45, varin=77, theta=10.965367, up=1.000000
ITER 9: row=45, varin=79, theta=3.032692, up=1.000000
ITER 10: row=45, varin=82, theta=2.292721, up=1.000000
DEBUG EVAL: Branch var 20 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x20 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=7, varin=90, theta=2.064266, up=1.000000
ITER 2: row=7, varin=98, theta=0.426604, up=1.000000
ITER 3: row=47, varin=46, theta=0.498005, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28024751.946211
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 291 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=93, theta=1.000000, up=1.000000
ITER 2: row=18, varin=83, theta=1.000000, up=1.000000
ITER 3: row=56, varin=7, theta=0.149819, up=999999999999999983222784.000000
ITER 4: row=55, varin=56, theta=2.093924, up=999999999999999983222784.000000
ITER 5: row=48, varin=102, theta=0.308578, up=1.000000
ITER 6: row=20, varin=110, theta=2.089754, up=1.000000
ITER 7: row=20, varin=19, theta=0.151087, up=999999999999999983222784.000000
ITER 8: row=18, varin=110, theta=0.418112, up=1.000000
ITER 9: row=49, varin=34, theta=191873.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28228127.533854
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 309 nonzeros, 4 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=26, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28251918.176577
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.500000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 273 nonzeros, 5 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=77, theta=0.517995, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28263904.235445
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 287 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=65, theta=0.252685, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28270952.641310
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 294 nonzeros, 0 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=61, theta=0.094813, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28273485.350565
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 300 nonzeros, 0 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 7 at  28.27348535056453471270
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6049c70
% @LO 0.01  27.98685898955687534340 99.9000000000
% @LN 0.01  28.00045096765481034140 99.9000000000
% Resuming node 9 at  28.00045096765481034140
DEBUG CONSTRNT: LP rows=56, pool->nlprows=56, pool->npend=0
DEBUG CONSTRNT: Checking 56 LP rows (pool tracks 56, total LP rows 56)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=55, expected 55
 % @PAP adding 45 rows, 206 nz to LP
DEBUG BB: Processing node 9, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=39, theta=1.019895, up=999999999999999983222784.000000
ITER 2: row=44, varin=38, theta=0.656772, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28000450.967655
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 266 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=6, theta=0.469178, up=999999999999999983222784.000000
ITER 2: row=48, varin=60, theta=0.391274, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28010109.494301
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 285 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 9 LP 1 Solution, length = 28010109.494301, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.608726 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.405817 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.594183 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.391274 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.608726 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.608726 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.405817 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.594183 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.405817 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.391274 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.391274 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.608726 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.405817 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.405817 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.391274 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28010109.494301, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 9 at  28.01010949430112972891
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f605a1f0
% @LO 0.01  28.00045096765481034140 99.9000000000
% @LN 0.01  28.00080583621391738802 99.9000000000
% Resuming node 10 at  28.00080583621391738802
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=46, expected 46
 % @PAP adding 45 rows, 206 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=45, theta=3.889148, up=999999999999999983222784.000000
ITER 2: row=35, varin=43, theta=0.781383, up=999999999999999983222784.000000
ITER 3: row=7, varin=56, theta=0.919553, up=1.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=35, varin=61, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28000805.836214
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 266 nonzeros, 3 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=60, theta=1.584880, up=1.000000
ITER 2: row=43, varin=89, theta=0.183168, up=1.000000
ITER 3: row=35, varin=60, theta=1.000000, up=1.000000
ITER 4: row=23, varin=63, theta=0.301337, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28096747.690373
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 270 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=64, theta=0.048474, up=1.000000
ITER 2: row=51, varin=56, theta=0.387990, up=1.000000
ITER 3: row=24, varin=55, theta=0.389049, up=1.000000
ITER 4: row=9, varin=72, theta=0.322118, up=1.000000
ITER 5: row=49, varin=53, theta=0.188436, up=999999999999999983222784.000000
ITER 6: row=46, varin=23, theta=0.107955, up=999999999999999983222784.000000
ITER 7: row=49, varin=51, theta=0.164930, up=999999999999999983222784.000000
ITER 8: row=19, varin=57, theta=0.169153, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28155631.011265
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 298 nonzeros, 4 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 10 rows, 39 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=103, theta=0.051019, up=1.000000
ITER 2: row=50, varin=60, theta=0.305046, up=1.000000
ITER 3: row=8, varin=86, theta=0.273307, up=1.000000
ITER 4: row=53, varin=54, theta=0.417090, up=999999999999999983222784.000000
ITER 5: row=55, varin=53, theta=0.059068, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28177387.460383
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 329 nonzeros, 6 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 7 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=7, theta=0.167757, up=999999999999999983222784.000000
ITER 2: row=58, varin=95, theta=0.685788, up=1.000000
ITER 3: row=44, varin=105, theta=0.273218, up=1.000000
ITER 4: row=18, varin=82, theta=0.349875, up=1.000000
ITER 5: row=56, varin=49, theta=0.435817, up=999999999999999983222784.000000
ITER 6: row=54, varin=84, theta=6.458843, up=1.000000
ITER 7: row=54, varin=47, theta=0.140863, up=999999999999999983222784.000000
ITER 8: row=29, varin=84, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=8)
ITER 9: row=29, varin=29, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28233332.722518
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 60 rows, 60 cols, 313 nonzeros, 2 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=86, theta=0.651241, up=1.000000
ITER 2: row=29, varin=68, theta=0.702954, up=1.000000
ITER 3: row=42, varin=85, theta=0.254412, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 28247061.333939
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 62 rows, 60 cols, 313 nonzeros, 0 slack, 62 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=63, varin=92, theta=0.186053, up=1.000000
ITER 2: row=62, varin=120, theta=0.553280, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=66)
DEBUG SOLUTION: LP solution array indices: FST[67-106], not_covered[107-126]
DEBUG SOLUTION: lp->best_solution[0] = 28260674.710541
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 66 rows, 60 cols, 332 nonzeros, 5 slack, 61 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=62, varin=92, theta=0.173334, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=63)
DEBUG SOLUTION: LP solution array indices: FST[64-103], not_covered[104-123]
DEBUG SOLUTION: lp->best_solution[0] = 28261040.196669
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 63 rows, 60 cols, 321 nonzeros, 1 slack, 62 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=63, varin=7, theta=0.190486, up=999999999999999983222784.000000
ITER 2: row=46, varin=92, theta=0.172126, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=64)
DEBUG SOLUTION: LP solution array indices: FST[65-104], not_covered[105-124]
DEBUG SOLUTION: lp->best_solution[0] = 28267083.347522
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 64 rows, 60 cols, 319 nonzeros, 0 slack, 64 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=65, varin=82, theta=0.021971, up=1.000000
ITER 2: row=64, varin=37, theta=0.019127, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=66)
DEBUG SOLUTION: LP solution array indices: FST[67-106], not_covered[107-126]
DEBUG SOLUTION: lp->best_solution[0] = 28271227.394381
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 66 rows, 60 cols, 325 nonzeros, 3 slack, 63 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=64, varin=110, theta=0.135424, up=1.000000
ITER 2: row=20, varin=89, theta=0.290068, up=1.000000
ITER 3: row=3, varin=94, theta=0.143270, up=1.000000
ITER 4: row=21, varin=96, theta=0.146645, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=64)
DEBUG SOLUTION: LP solution array indices: FST[65-104], not_covered[105-124]
DEBUG SOLUTION: lp->best_solution[0] = 28300701.808735
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 64 rows, 60 cols, 319 nonzeros, 0 slack, 64 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=65, varin=41, theta=0.047172, up=999999999999999983222784.000000
ITER 2: row=49, varin=98, theta=0.080593, up=1.000000
ITER 3: row=11, varin=19, theta=0.036827, up=999999999999999983222784.000000
ITER 4: row=59, varin=96, theta=0.128125, up=1.000000
ITER 5: row=10, varin=45, theta=0.109063, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=65)
DEBUG SOLUTION: LP solution array indices: FST[66-105], not_covered[106-125]
DEBUG SOLUTION: lp->best_solution[0] = 28389592.828762
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 65 rows, 60 cols, 321 nonzeros, 3 slack, 62 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 10 LP 1 Solution, length = 28389592.828762, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.169207 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.060144 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.060144 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.060144 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.060144 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.060144 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.060144 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.060144 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.169207 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.169207 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.939856 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.830793 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.939856 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.830793 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.939856 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.939856 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.939856 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28389592.828762, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 10 at  28.38959282876225032055
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6043950
% @LO 0.01  28.00080583621391738802 99.9000000000
% @LN 0.01  28.00332736614068807057 99.9000000000
% Resuming node 2 at  28.00332736614068807057
DEBUG CONSTRNT: LP rows=62, pool->nlprows=62, pool->npend=0
DEBUG CONSTRNT: Checking 62 LP rows (pool tracks 62, total LP rows 62)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 138
DEBUG CONSTRNT: Pool row 138 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=61, expected 61
 % @PAP adding 71 rows, 277 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 2 LP 4 Solution, length = 28003327.366141, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.457215 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.542785 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.542785 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28003327.366141, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28003327.366141, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.457215
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.457215)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x12, Z0 = 28003327.3661407        , Z1 = 28058107.6151967        

DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=47, varin=36, theta=0.270968, up=999999999999999983222784.000000
ITER 2: row=36, varin=67, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=71, varin=68, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28072644.633304
  % 	x12 = 1,	Z1 = 28072644.6333042        
DEBUG EVAL: First branch cutoff check: z=28072644.633304, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=47, varin=118, theta=0.371681, up=1.000000
ITER 2: row=52, varin=77, theta=0.555556, up=1.000000
ITER 3: row=6, varin=55, theta=3.272727, up=999999999999999983222784.000000
ITER 4: row=15, varin=89, theta=0.312500, up=1.000000
ITER 5: row=34, varin=74, theta=0.500000, up=1.000000
ITER 6: row=43, varin=73, theta=0.500000, up=1.000000
ITER 7: row=20, varin=18, theta=1.000000, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 28146024.5995388        
DEBUG EVAL: Second branch cutoff check: z=28146024.599539, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28072644.6333042        
DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=60, varin=36, theta=0.270968, up=999999999999999983222784.000000
ITER 2: row=36, varin=70, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=1, varin=65, theta=0.019764, up=999999999999999983222784.000000
ITER 4: row=65, varin=93, theta=0.543050, up=1.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28266095.973275
  % 	x15 = 1,	Z1 = 28266095.973275         
DEBUG EVAL: First branch cutoff check: z=28266095.973275, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=60, varin=118, theta=0.371681, up=1.000000
ITER 2: row=52, varin=67, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=71, varin=77, theta=0.555556, up=1.000000
ITER 4: row=6, varin=55, theta=3.272727, up=999999999999999983222784.000000
ITER 5: row=15, varin=89, theta=0.312500, up=1.000000
ITER 6: row=14, varin=74, theta=0.500000, up=1.000000
ITER 7: row=43, varin=73, theta=0.500000, up=1.000000
ITER 8: row=20, varin=18, theta=1.000000, up=999999999999999983222784.000000
  % 	x15 = 0,	Z0 = 28146024.5995388        
DEBUG EVAL: Second branch cutoff check: z=28146024.599539, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28146024.5995388        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=70, theta=0.479834, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28011697.792397
  % 	x10 = 0,	Z0 = 28011697.7923973        
DEBUG EVAL: First branch cutoff check: z=28011697.792397, best_z=INF, threshold=INF
  % Best branch is x15, Z0 = 28146024.5995388        , Z1 = 28266095.973275         

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC   13    2	x15 = 0	28146024.599539
 % @NC   14    2	x15 = 1	28266095.973275
 %       2     8 28003327.3661               28010109.4943    x9 U     0     1
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6049c70
% @LO 0.01  28.00332736614068807057 99.9000000000
% @LN 0.01  28.01010949430112972891 99.9000000000
% Resuming node 9 at  28.01010949430112972891
DEBUG CONSTRNT: LP rows=71, pool->nlprows=71, pool->npend=0
DEBUG CONSTRNT: Checking 71 LP rows (pool tracks 71, total LP rows 71)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=64, expected 64
DEBUG CONSTRNT: Checking LP row 65 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=65, expected 65
DEBUG CONSTRNT: Checking LP row 66 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=66, expected 66
DEBUG CONSTRNT: Checking LP row 67 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=67, expected 67
DEBUG CONSTRNT: Checking LP row 68 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=68, expected 68
DEBUG CONSTRNT: Checking LP row 69 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=69, expected 69
DEBUG CONSTRNT: Checking LP row 70 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=70, expected 70
 % @PAP adding 47 rows, 221 nz to LP
DEBUG BB: Processing node 9, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 9 LP 2 Solution, length = 28010109.494301, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.608726 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.405817 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.594183 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.391274 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.608726 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.608726 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.405817 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.594183 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.405817 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.391274 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.391274 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.608726 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.405817 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.405817 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.391274 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28010109.494301, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28010109.494301, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 9 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 9
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.608726
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.608726)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.405817
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.405817)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.594183
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.594183)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.391274
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.391274)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[1] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[3] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
  % Initial guess is x20, Z0 = 28010109.4943011        , Z1 = 28123436.6777257        

DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=53, theta=0.458865, up=1.000000
ITER 2: row=45, varin=38, theta=0.091586, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28016870.560668
  % 	x10 = 1,	Z1 = 28016870.5606678        
DEBUG EVAL: First branch cutoff check: z=28016870.560668, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=1, varin=46, theta=0.729924, up=999999999999999983222784.000000
ITER 2: row=45, varin=44, theta=0.599743, up=999999999999999983222784.000000
ITER 3: row=46, varin=41, theta=0.359958, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28055943.6708589        
DEBUG EVAL: Second branch cutoff check: z=28055943.670859, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28016870.5606678        
DEBUG EVAL: Testing var 20 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=46, theta=0.729924, up=999999999999999983222784.000000
ITER 2: row=45, varin=44, theta=0.599743, up=999999999999999983222784.000000
ITER 3: row=46, varin=35, theta=0.922563, up=999999999999999983222784.000000
ITER 4: row=40, varin=40, theta=0.233066, up=999999999999999983222784.000000
ITER 5: row=23, varin=38, theta=0.962638, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 1 gives z=28128330.186703
  % 	x20 = 1,	Z1 = 28128330.1867025        
DEBUG EVAL: First branch cutoff check: z=28128330.186703, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 0
ITER 1: row=7, varin=53, theta=0.458865, up=1.000000
ITER 2: row=45, varin=38, theta=0.091586, up=999999999999999983222784.000000
  % 	x20 = 0,	Z0 = 28016870.5606678        
DEBUG EVAL: Second branch cutoff check: z=28016870.560668, best_z=INF, threshold=INF
  %   New best:  x20, Z = 28016870.5606678        
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=46, theta=1.822764, up=999999999999999983222784.000000
ITER 2: row=45, varin=56, theta=0.428535, up=1.000000
ITER 3: row=47, varin=38, theta=0.056174, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28046049.639102
  % 	x14 = 0,	Z0 = 28046049.6391023        
DEBUG EVAL: First branch cutoff check: z=28046049.639102, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=23, varin=38, theta=1.034650, up=999999999999999983222784.000000
ITER 2: row=7, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=38, varin=23, theta=0.422330, up=999999999999999983222784.000000
ITER 4: row=28, varin=7, theta=0.422330, up=999999999999999983222784.000000
  % 	x14 = 1,	Z1 = 28038336.3989008        
DEBUG EVAL: Second branch cutoff check: z=28038336.398901, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28038336.3989008        
DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=46, theta=1.822764, up=999999999999999983222784.000000
ITER 2: row=45, varin=41, theta=0.511060, up=999999999999999983222784.000000
ITER 3: row=1, varin=53, theta=0.221856, up=1.000000
ITER 4: row=47, varin=38, theta=0.038426, up=999999999999999983222784.000000
ITER 5: row=34, varin=44, theta=0.023096, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28080647.613559
  % 	x15 = 1,	Z1 = 28080647.613559         
DEBUG EVAL: First branch cutoff check: z=28080647.613559, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=34, varin=38, theta=1.034650, up=999999999999999983222784.000000
ITER 2: row=7, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=38, varin=19, theta=0.422330, up=999999999999999983222784.000000
  % 	x15 = 0,	Z0 = 28038336.3989008        
DEBUG EVAL: Second branch cutoff check: z=28038336.398901, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28038336.3989008        
  % Best branch is x15, Z0 = 28038336.3989008        , Z1 = 28080647.613559         

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC   15    9	x15 = 0	28038336.398901
 % @NC   16    9	x15 = 1	28080647.613559
 %       9     9 28010109.4943               28011089.6167   x16 D     8     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60478a0
% @LO 0.01  28.01010949430112972891 99.9000000000
% @LN 0.01  28.01108961665976337940 99.9000000000
% Resuming node 4 at  28.01108961665976337940
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=46, expected 46
 % @PAP adding 52 rows, 238 nz to LP
DEBUG BB: Processing node 4, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 4 LP 3 Solution, length = 28011089.616660, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.164901 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.164901 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.494704 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.417549 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.417549 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.582451 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.582451 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.582451 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.582451 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.505296 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.505296 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.505296 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28011089.616660, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28011089.616660, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 4 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 4
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.164901
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.164901)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.164901
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.164901)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.494704
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.494704)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.417549
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.417549)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.417549
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.417549)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[1] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[4] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x16, Z0 = 28022046.137397         , Z1 = 28025521.7391486        

DEBUG EVAL: Testing var 16 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=52, theta=0.709202, up=999999999999999983222784.000000
ITER 2: row=45, varin=49, theta=0.558760, up=999999999999999983222784.000000
ITER 3: row=46, varin=47, theta=0.643369, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 16 = 0 gives z=28047635.706644
  % 	x16 = 0,	Z0 = 28047635.7066443        
DEBUG EVAL: First branch cutoff check: z=28047635.706644, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 1
ITER 1: row=6, varin=28, theta=0.145724, up=999999999999999983222784.000000
ITER 2: row=33, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=48, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=27, varin=49, theta=0.303152, up=999999999999999983222784.000000
ITER 5: row=46, varin=54, theta=0.297166, up=1.000000
ITER 6: row=9, varin=55, theta=0.330438, up=1.000000
ITER 7: row=23, varin=59, theta=0.437317, up=1.000000
  % 	x16 = 1,	Z1 = 28267935.3808536        
DEBUG EVAL: Second branch cutoff check: z=28267935.380854, best_z=INF, threshold=INF
  %   New best:  x16, Z = 28047635.7066443        
DEBUG EVAL: Testing var 13 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=52, theta=0.709202, up=999999999999999983222784.000000
ITER 2: row=45, varin=49, theta=0.558760, up=999999999999999983222784.000000
ITER 3: row=46, varin=36, theta=0.878373, up=999999999999999983222784.000000
ITER 4: row=48, varin=35, theta=0.696219, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 13 = 0 gives z=28156905.791606
  % 	x13 = 0,	Z0 = 28156905.7916058        
DEBUG EVAL: First branch cutoff check: z=28156905.791606, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 1
ITER 1: row=35, varin=28, theta=0.145724, up=999999999999999983222784.000000
ITER 2: row=33, varin=47, theta=1.000000, up=999999999999999983222784.000000
  % 	x13 = 1,	Z1 = 28070633.5457098        
DEBUG EVAL: Second branch cutoff check: z=28070633.545710, best_z=INF, threshold=INF
  %   New best:  x13, Z = 28070633.5457098        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=28, theta=0.103942, up=999999999999999983222784.000000
ITER 2: row=33, varin=50, theta=4.404261, up=999999999999999983222784.000000
ITER 3: row=51, varin=33, theta=252526.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28047787.928039
  % 	x10 = 0,	Z0 = 28047787.9280386        
DEBUG EVAL: First branch cutoff check: z=28047787.928039, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=52, theta=0.709202, up=999999999999999983222784.000000
ITER 2: row=45, varin=49, theta=0.558760, up=999999999999999983222784.000000
ITER 3: row=46, varin=47, theta=2.802265, up=999999999999999983222784.000000
ITER 4: row=6, varin=45, theta=1.017962, up=999999999999999983222784.000000
ITER 5: row=33, varin=7, theta=0.059241, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28247145.136524
  % 	x5 = 1,	Z1 = 28247145.1365241        
DEBUG EVAL: First branch cutoff check: z=28247145.136524, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=1, varin=28, theta=0.020628, up=999999999999999983222784.000000
  % 	x5 = 0,	Z0 = 28012065.5740727        
DEBUG EVAL: Second branch cutoff check: z=28012065.574073, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=52, theta=0.709202, up=999999999999999983222784.000000
ITER 2: row=45, varin=49, theta=0.558760, up=999999999999999983222784.000000
ITER 3: row=46, varin=47, theta=2.802265, up=999999999999999983222784.000000
ITER 4: row=47, varin=46, theta=0.996914, up=999999999999999983222784.000000
ITER 5: row=27, varin=6, theta=0.006278, up=999999999999999983222784.000000
ITER 6: row=6, varin=7, theta=0.015198, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28205419.077712
  % 	x7 = 1,	Z1 = 28205419.077712         
DEBUG EVAL: First branch cutoff check: z=28205419.077712, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=33, varin=28, theta=0.020628, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 28012065.5740727        
DEBUG EVAL: Second branch cutoff check: z=28012065.574073, best_z=INF, threshold=INF
  % Best branch is x13, Z0 = 28156905.7916058        , Z1 = 28070633.5457098        

DEBUG CAREFUL: Final result - returning best.var = 13
DEBUG BB: Branching variable chosen: j=13
 % @NC   17    4	x13 = 1	28070633.545710
 % @NC   18    4	x13 = 0	28156905.791606
 %       4    10 28011089.6167               28038336.3989   x12 U     1     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6043950
% @LO 0.01  28.01108961665976337940 99.9000000000
% @LN 0.01  28.03833639890079254542 99.9000000000
% Resuming node 15 at  28.03833639890079254542
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=51, expected 51
 % @PAP adding 47 rows, 221 nz to LP
DEBUG BB: Processing node 15, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=38, theta=1.034650, up=999999999999999983222784.000000
ITER 2: row=7, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=38, varin=19, theta=0.422330, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28038336.398901
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.577670
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 281 nonzeros, 6 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=43, theta=0.109410, up=999999999999999983222784.000000
ITER 2: row=48, varin=42, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=53, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=19, varin=106, theta=1.687080, up=1.000000
ITER 5: row=19, varin=75, theta=0.790145, up=1.000000
ITER 6: row=45, varin=63, theta=0.209384, up=1.000000
ITER 7: row=51, varin=52, theta=6.021699, up=999999999999999983222784.000000
ITER 8: row=47, varin=106, theta=0.060121, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28079498.477347
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 321 nonzeros, 9 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=35, theta=0.556365, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28093818.433334
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 279 nonzeros, 1 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=41, theta=2.556378, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28095176.170002
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 275 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 15 LP 1 Solution, length = 28095176.170002, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.365197 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.365197 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.500000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.634803 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.634803 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.634803 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.634803 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.634803 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28095176.170002, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 15 at  28.09517617000187073018
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6049c70
% @LO 0.01  28.03833639890079254542 99.9000000000
% @LN 0.01  28.07063354570981417169 99.9000000000
% Resuming node 17 at  28.07063354570981417169
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=45, expected 45
 % @PAP adding 52 rows, 238 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=28, theta=0.145724, up=999999999999999983222784.000000
ITER 2: row=33, varin=47, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28070633.545710
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 298 nonzeros, 5 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=65, theta=0.659424, up=1.000000
ITER 2: row=6, varin=59, theta=0.693137, up=1.000000
ITER 3: row=9, varin=60, theta=0.579259, up=1.000000
ITER 4: row=23, varin=50, theta=3.455018, up=999999999999999983222784.000000
ITER 5: row=51, varin=58, theta=0.610676, up=1.000000
ITER 6: row=2, varin=7, theta=0.428362, up=999999999999999983222784.000000
ITER 7: row=57, varin=64, theta=0.407681, up=1.000000
ITER 8: row=55, varin=57, theta=0.293108, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28137429.330847
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 313 nonzeros, 3 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=50, theta=1.288588, up=999999999999999983222784.000000
ITER 2: row=27, varin=6, theta=0.216627, up=999999999999999983222784.000000
ITER 3: row=6, varin=61, theta=0.299103, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28179194.301817
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.866069
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 324 nonzeros, 6 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 8 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=70, theta=0.029463, up=1.000000
ITER 2: row=53, varin=96, theta=0.614123, up=1.000000
ITER 3: row=57, varin=59, theta=0.311490, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28191601.453722
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 321 nonzeros, 2 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=84, theta=1.195544, up=1.000000
ITER 2: row=58, varin=47, theta=0.092942, up=999999999999999983222784.000000
ITER 3: row=3, varin=84, theta=1.000000, up=1.000000
ITER 4: row=52, varin=86, theta=0.515763, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28235682.036095
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 313 nonzeros, 0 slack, 59 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=60, varin=116, theta=0.693689, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 28252547.436330
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 62 rows, 60 cols, 320 nonzeros, 3 slack, 59 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=60, varin=106, theta=0.646157, up=1.000000
ITER 2: row=13, varin=103, theta=0.608434, up=1.000000
ITER 3: row=11, varin=85, theta=0.751714, up=1.000000
ITER 4: row=56, varin=83, theta=0.303508, up=1.000000
ITER 5: row=34, varin=84, theta=0.307936, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28311655.926534
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 61 rows, 60 cols, 324 nonzeros, 1 slack, 60 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=61, varin=91, theta=0.220229, up=1.000000
ITER 2: row=47, varin=74, theta=0.395781, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 28322661.327244
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 62 rows, 60 cols, 318 nonzeros, 0 slack, 62 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=63, varin=96, theta=0.167810, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=68)
DEBUG SOLUTION: LP solution array indices: FST[69-108], not_covered[109-128]
DEBUG SOLUTION: lp->best_solution[0] = 28327954.879885
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 68 rows, 60 cols, 352 nonzeros, 3 slack, 65 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=66, varin=96, theta=0.078198, up=1.000000
ITER 2: row=14, varin=28, theta=0.166603, up=999999999999999983222784.000000
ITER 3: row=51, varin=41, theta=0.053850, up=999999999999999983222784.000000
ITER 4: row=45, varin=71, theta=0.397379, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=66)
DEBUG SOLUTION: LP solution array indices: FST[67-106], not_covered[107-126]
DEBUG SOLUTION: lp->best_solution[0] = 28344526.225333
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 66 rows, 60 cols, 326 nonzeros, 0 slack, 66 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=67, varin=104, theta=0.087375, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=72)
DEBUG SOLUTION: LP solution array indices: FST[73-112], not_covered[113-132]
DEBUG SOLUTION: lp->best_solution[0] = 28346345.745866
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 72 rows, 60 cols, 359 nonzeros, 3 slack, 69 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=70, varin=113, theta=0.011910, up=1.000000
ITER 2: row=23, varin=104, theta=0.018930, up=1.000000
ITER 3: row=4, varin=43, theta=0.004290, up=999999999999999983222784.000000
ITER 4: row=52, varin=116, theta=0.004232, up=1.000000
ITER 5: row=17, varin=101, theta=0.011787, up=1.000000
ITER 6: row=9, varin=103, theta=0.004152, up=1.000000
ITER 7: row=20, varin=50, theta=0.010205, up=999999999999999983222784.000000
ITER 8: row=64, varin=8, theta=0.006322, up=999999999999999983222784.000000
ITER 9: row=10, varin=63, theta=0.013016, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=70)
DEBUG SOLUTION: LP solution array indices: FST[71-110], not_covered[111-130]
DEBUG SOLUTION: lp->best_solution[0] = 28353988.061994
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 70 rows, 60 cols, 334 nonzeros, 5 slack, 65 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 17 LP 1 Solution, length = 28353988.061994, 0.01 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.087937 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.074921 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.074921 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.074921 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.074921 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.074921 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.074921 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.074921 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.074921 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.087937 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.087937 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.925079 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.912063 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.925079 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.912063 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.925079 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.925079 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.925079 (terminal 19)
 % 11 fractional variables
DEBUG CG: LP optimal, z=28353988.061994, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 17 at  28.35398806199393462180
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6057f50
% @LO 0.02  28.07063354570981417169 99.9000000000
% @LN 0.02  28.08064761355902660966 99.9000000000
% Resuming node 16 at  28.08064761355902660966
DEBUG CONSTRNT: LP rows=65, pool->nlprows=65, pool->npend=0
DEBUG CONSTRNT: Checking 65 LP rows (pool tracks 65, total LP rows 65)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=64, expected 64
 % @PAP adding 47 rows, 221 nz to LP
DEBUG BB: Processing node 16, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=46, theta=1.822764, up=999999999999999983222784.000000
ITER 2: row=45, varin=41, theta=0.511060, up=999999999999999983222784.000000
ITER 3: row=1, varin=53, theta=0.221856, up=1.000000
ITER 4: row=47, varin=38, theta=0.038426, up=999999999999999983222784.000000
ITER 5: row=34, varin=44, theta=0.023096, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28080647.613559
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.938411
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 281 nonzeros, 4 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=64, theta=0.239871, up=1.000000
ITER 2: row=49, varin=47, theta=2.307692, up=999999999999999983222784.000000
ITER 3: row=48, varin=49, theta=0.600000, up=999999999999999983222784.000000
ITER 4: row=44, varin=45, theta=1.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28130012.111797
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.500000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 305 nonzeros, 7 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % Node 16 LP 1 Solution, length = 28130012.111797, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.094582 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.094582 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.905418 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.905418 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.905418 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.905418 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.905418 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.905418 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28130012.111797, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 16 at  28.13001211179742000468
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6043950
% @LO 0.02  28.08064761355902660966 99.9000000000
% @LN 0.02  28.09517617000187073018 99.9000000000
% Resuming node 15 at  28.09517617000187073018
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=45, expected 45
 % @PAP adding 46 rows, 206 nz to LP
DEBUG BB: Processing node 15, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 15 LP 2 Solution, length = 28095176.170002, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.365197 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.365197 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.500000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.634803 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.634803 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.634803 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.634803 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.634803 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28095176.170002, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28095176.170002, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 15 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 15
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.365197
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.365197)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.365197
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.365197)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.500000
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[3] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 8
  % Initial guess is x20, Z0 = 28095176.1700019        , Z1 = 28128330.1867025        

DEBUG EVAL: Testing var 20 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=46, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=52, theta=1.160395, up=1.000000
ITER 4: row=42, varin=42, theta=0.149033, up=999999999999999983222784.000000
ITER 5: row=43, varin=52, theta=0.555556, up=1.000000
ITER 6: row=37, varin=49, theta=0.863152, up=1.000000
ITER 7: row=24, varin=48, theta=0.874536, up=1.000000
ITER 8: row=9, varin=53, theta=1.144854, up=1.000000
ITER 9: row=9, varin=73, theta=0.167810, up=1.000000
ITER 10: row=43, varin=38, theta=0.800463, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x20 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=7, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=52, theta=0.104089, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28098708.588719
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.973978
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 46 rows, 60 cols, 266 nonzeros, 3 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 6 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=58, theta=0.616010, up=1.000000
ITER 2: row=44, varin=39, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28101679.978943
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 284 nonzeros, 4 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=37, theta=0.008049, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28102341.404277
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 268 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 15 at  28.10234140427656868155
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6043950
% @LO 0.02  28.09517617000187073018 99.9000000000
% @LN 0.02  28.10234140427656868155 99.9000000000
% Resuming node 15 at  28.10234140427656868155
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=47, expected 47
 % @PAP adding 48 rows, 204 nz to LP
DEBUG BB: Processing node 15, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 15 LP 3 Solution, length = 28102341.404277, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.330650 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.330650 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.330650 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.991951 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.330650 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.669350 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.669350 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.669350 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.669350 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.669350 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.008049 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.008049 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.669350 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.008049 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28102341.404277, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28102341.404277, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 15 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 15
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.330650
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.330650)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.330650
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.330650)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.330650
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.330650)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.991951
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.991951)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.330650
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.330650)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[3] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[4] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
  % Initial guess is x8, Z0 = 28102341.4042766        , Z1 = 28113999.7431307        

DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=37, theta=0.953776, up=999999999999999983222784.000000
ITER 2: row=45, varin=38, theta=4.934266, up=999999999999999983222784.000000
ITER 3: row=44, varin=43, theta=0.808647, up=999999999999999983222784.000000
ITER 4: row=47, varin=41, theta=1.243451, up=999999999999999983222784.000000
ITER 5: row=46, varin=48, theta=0.701852, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28256572.528521
  % 	x5 = 1,	Z1 = 28256572.5285209        
DEBUG EVAL: First branch cutoff check: z=28256572.528521, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=1, varin=42, theta=0.574207, up=999999999999999983222784.000000
  % 	x5 = 0,	Z0 = 28139131.0982211        
DEBUG EVAL: Second branch cutoff check: z=28139131.098221, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28139131.0982211        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=38, theta=0.019778, up=999999999999999983222784.000000
ITER 2: row=44, varin=41, theta=0.033954, up=999999999999999983222784.000000
ITER 3: row=45, varin=66, theta=0.006719, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28103403.310689
  % 	x10 = 1,	Z1 = 28103403.3106891        
DEBUG EVAL: First branch cutoff check: z=28103403.310689, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=38, theta=0.382544, up=999999999999999983222784.000000
ITER 2: row=44, varin=41, theta=0.562665, up=999999999999999983222784.000000
ITER 3: row=46, varin=37, theta=1.108781, up=999999999999999983222784.000000
ITER 4: row=45, varin=39, theta=0.447796, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28147658.111830
  % 	x14 = 0,	Z0 = 28147658.1118297        
DEBUG EVAL: First branch cutoff check: z=28147658.111830, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=36, varin=43, theta=0.675908, up=999999999999999983222784.000000
  % 	x14 = 1,	Z1 = 28161830.2843151        
DEBUG EVAL: Second branch cutoff check: z=28161830.284315, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28147658.1118297        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=37, theta=1.108781, up=999999999999999983222784.000000
ITER 2: row=45, varin=48, theta=0.565592, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28159547.063368
  % 	x7 = 0,	Z0 = 28159547.0633681        
DEBUG EVAL: First branch cutoff check: z=28159547.063368, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=33, varin=38, theta=4.934266, up=999999999999999983222784.000000
ITER 2: row=44, varin=41, theta=1.623259, up=999999999999999983222784.000000
ITER 3: row=45, varin=42, theta=0.800169, up=999999999999999983222784.000000
ITER 4: row=46, varin=44, theta=0.955044, up=999999999999999983222784.000000
ITER 5: row=33, varin=45, theta=1.578054, up=999999999999999983222784.000000
ITER 6: row=1, varin=39, theta=0.455486, up=999999999999999983222784.000000
  % 	x7 = 1,	Z1 = 28220435.2405497        
DEBUG EVAL: Second branch cutoff check: z=28220435.240550, best_z=INF, threshold=INF
  %   New best:  x7, Z = 28159547.0633681        
DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=38, theta=4.934266, up=999999999999999983222784.000000
ITER 2: row=44, varin=48, theta=0.937988, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 1 gives z=28168569.868372
  % 	x8 = 1,	Z1 = 28168569.8683718        
DEBUG EVAL: First branch cutoff check: z=28168569.868372, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
ITER 1: row=37, varin=41, theta=0.562665, up=999999999999999983222784.000000
ITER 2: row=46, varin=37, theta=1.108781, up=999999999999999983222784.000000
ITER 3: row=45, varin=43, theta=0.553526, up=999999999999999983222784.000000
  % 	x8 = 0,	Z0 = 28164343.3716783        
DEBUG EVAL: Second branch cutoff check: z=28164343.371678, best_z=INF, threshold=INF
  %   New best:  x8, Z = 28164343.3716783        
  % Best branch is x8, Z0 = 28164343.3716783        , Z1 = 28168569.8683718        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   19   15	x8 = 0	28164343.371678
 % @NC   20   15	x8 = 1	28168569.868372
 %      15    11 28102341.4043               28110972.9627   x15 D     9     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6041ff0
% @LO 0.02  28.10234140427656868155 99.9000000000
% @LN 0.02  28.11097296271109513555 99.9000000000
% Resuming node 11 at  28.11097296271109513555
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=47, expected 47
 % @PAP adding 50 rows, 192 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=48, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=6, varin=95, theta=0.400000, up=1.000000
ITER 4: row=18, varin=104, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28110972.962711
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 252 nonzeros, 5 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=98, theta=0.190476, up=1.000000
ITER 2: row=22, varin=79, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28157902.918862
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 264 nonzeros, 2 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=66, theta=0.500000, up=1.000000
ITER 2: row=50, varin=42, theta=0.062500, up=999999999999999983222784.000000
ITER 3: row=54, varin=65, theta=0.071429, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28185042.916364
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 271 nonzeros, 4 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=59, theta=0.500000, up=1.000000
ITER 2: row=41, varin=98, theta=0.090909, up=1.000000
ITER 3: row=53, varin=52, theta=0.111111, up=999999999999999983222784.000000
ITER 4: row=26, varin=39, theta=0.013158, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28207948.746652
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.907895
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 275 nonzeros, 5 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 5 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=66, theta=0.450644, up=1.000000
ITER 2: row=50, varin=54, theta=0.076923, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28210492.378719
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 275 nonzeros, 4 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=39, theta=1.180723, up=999999999999999983222784.000000
ITER 2: row=53, varin=51, theta=0.032895, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28234831.030402
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 273 nonzeros, 2 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=47, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=50, varin=79, theta=2.000000, up=1.000000
ITER 3: row=50, varin=48, theta=0.625000, up=999999999999999983222784.000000
ITER 4: row=27, varin=79, theta=1.000000, up=1.000000
ITER 5: row=52, varin=93, theta=1.000000, up=1.000000
ITER 6: row=54, varin=51, theta=0.142857, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28325494.611770
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 272 nonzeros, 2 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=43, theta=1.153846, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28332888.746139
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 282 nonzeros, 4 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=46, theta=0.800000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28338488.148119
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 258 nonzeros, 1 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 11 LP 1 Solution, length = 28338488.148119, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.200000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.200000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.200000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.200000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.200000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.200000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.200000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.800000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.800000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.800000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.800000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.800000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.800000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.800000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28338488.148119, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 11 at  28.33848814811905825195
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6057f50
% @LO 0.02  28.11097296271109513555 99.9000000000
% @LN 0.02  28.13001211179742000468 99.9000000000
% Resuming node 16 at  28.13001211179742000468
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=53, expected 53
 % @PAP adding 46 rows, 206 nz to LP
DEBUG BB: Processing node 16, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 16 LP 2 Solution, length = 28130012.111797, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.094582 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.094582 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.905418 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.905418 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.905418 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.905418 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.905418 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.905418 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28130012.111797, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28130012.111797, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 16 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 16
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.094582
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.094582)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.094582
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.094582)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[2] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x5, Z0 = 28130012.1117974        , Z1 = 28130012.1117974        

DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=44, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=6, varin=42, theta=0.604402, up=999999999999999983222784.000000
ITER 4: row=22, varin=49, theta=0.551842, up=1.000000
ITER 5: row=23, varin=48, theta=0.561567, up=1.000000
ITER 6: row=8, varin=73, theta=0.787642, up=1.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28428619.170581
  % 	x5 = 1,	Z1 = 28428619.1705808        
DEBUG EVAL: First branch cutoff check: z=28428619.170581, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=1, varin=64, theta=0.333333, up=1.000000
  % 	x5 = 0,	Z0 = 28157054.029969         
DEBUG EVAL: Second branch cutoff check: z=28157054.029969, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28157054.029969         
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=6, varin=43, theta=0.591905, up=999999999999999983222784.000000
ITER 3: row=33, varin=22, theta=0.309506, up=999999999999999983222784.000000
ITER 4: row=46, varin=49, theta=0.446240, up=1.000000
ITER 5: row=23, varin=48, theta=0.453302, up=1.000000
ITER 6: row=8, varin=35, theta=0.978951, up=999999999999999983222784.000000
ITER 7: row=22, varin=73, theta=0.655769, up=1.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28359452.120349
  % 	x7 = 1,	Z1 = 28359452.1203487        
DEBUG EVAL: First branch cutoff check: z=28359452.120349, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=33, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=44, varin=64, theta=0.333333, up=1.000000
  % 	x7 = 0,	Z0 = 28157054.029969         
DEBUG EVAL: Second branch cutoff check: z=28157054.029969, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 20 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=45, theta=0.145536, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 0 gives z=28137991.595352
  % 	x20 = 0,	Z0 = 28137991.5953516        
DEBUG EVAL: First branch cutoff check: z=28137991.595352, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=22, theta=0.131105, up=999999999999999983222784.000000
ITER 2: row=46, varin=35, theta=0.086556, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28147957.193004
  % 	x10 = 0,	Z0 = 28147957.1930038        
DEBUG EVAL: First branch cutoff check: z=28147957.193004, best_z=INF, threshold=INF
  % Best branch is x5, Z0 = 28157054.029969         , Z1 = 28428619.1705808        

DEBUG CAREFUL: Final result - returning best.var = 5
DEBUG BB: Branching variable chosen: j=5
 % @NC   21   16	x5 = 0	28157054.029969
 % @NC   22   16	x5 = 1	28428619.170581
 %      16    12 28130012.1118               28146024.5995   x15 U     9     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60410f0
% @LO 0.02  28.13001211179742000468 99.9000000000
% @LN 0.02  28.14602459953875168708 99.9000000000
% Resuming node 13 at  28.14602459953875168708
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=45, expected 45
 % @PAP adding 71 rows, 277 nz to LP
DEBUG BB: Processing node 13, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=60, varin=118, theta=0.371681, up=1.000000
ITER 2: row=52, varin=67, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=71, varin=77, theta=0.555556, up=1.000000
ITER 4: row=6, varin=55, theta=3.272727, up=999999999999999983222784.000000
ITER 5: row=15, varin=89, theta=0.312500, up=1.000000
ITER 6: row=14, varin=74, theta=0.500000, up=1.000000
ITER 7: row=43, varin=73, theta=0.500000, up=1.000000
ITER 8: row=20, varin=18, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=71)
DEBUG SOLUTION: LP solution array indices: FST[72-111], not_covered[112-131]
DEBUG SOLUTION: lp->best_solution[0] = 28146024.599539
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.750000
DEBUG SOLUTION: lp->best_solution[13] = 0.750000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 71 rows, 60 cols, 337 nonzeros, 19 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 19 slack rows
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=74, theta=0.068377, up=1.000000
ITER 2: row=53, varin=55, theta=0.630857, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28150001.390436
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 294 nonzeros, 1 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=64, theta=0.017566, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28150358.377067
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 290 nonzeros, 0 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=65, theta=0.019122, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28152892.111383
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 61 rows, 60 cols, 311 nonzeros, 0 slack, 61 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 13 LP 1 Solution, length = 28152892.111383, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.019122 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.137394 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.137394 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.137394 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.137394 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.862606 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.862606 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.862606 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.862606 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.862606 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28152892.111383, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.02  28.14602459953875168708 99.9000000000
 % @LN 0.02  28.15289211138341229912 99.9000000000
DEBUG CG: Second cutoff check: z=28152892.111383, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 13 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 13
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.019122
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.019122)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.137394
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.137394)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.137394
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.137394)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.137394
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.137394)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.137394
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.137394)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x18, Z0 = 28152892.1113834        , Z1 = 28829430.8411315        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=58, theta=0.901025, up=999999999999999983222784.000000
ITER 2: row=58, varin=57, theta=1.361651, up=999999999999999983222784.000000
ITER 3: row=41, varin=53, theta=1.443229, up=999999999999999983222784.000000
ITER 4: row=55, varin=15, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=15, varin=30, theta=0.500000, up=999999999999999983222784.000000
ITER 6: row=30, varin=12, theta=0.333333, up=999999999999999983222784.000000
ITER 7: row=12, varin=6, theta=0.444444, up=999999999999999983222784.000000
ITER 8: row=6, varin=52, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=48, varin=26, theta=0.500000, up=999999999999999983222784.000000
ITER 10: row=30, varin=13, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28545083.558064
  % 	x3 = 1,	Z1 = 28545083.5580644        
DEBUG EVAL: First branch cutoff check: z=28545083.558064, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=1, varin=88, theta=0.026297, up=1.000000
  % 	x3 = 0,	Z0 = 28153077.9426585        
DEBUG EVAL: Second branch cutoff check: z=28153077.942659, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28153077.9426585        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=53, theta=1.575795, up=999999999999999983222784.000000
ITER 2: row=55, varin=88, theta=13.290650, up=1.000000
ITER 3: row=55, varin=26, theta=1.838818, up=999999999999999983222784.000000
ITER 4: row=56, varin=83, theta=9.349130, up=1.000000
ITER 5: row=56, varin=43, theta=6.128618, up=999999999999999983222784.000000
ITER 6: row=43, varin=6, theta=4.340872, up=999999999999999983222784.000000
ITER 7: row=6, varin=36, theta=1.861686, up=999999999999999983222784.000000
ITER 8: row=1, varin=84, theta=0.856692, up=1.000000
ITER 9: row=26, varin=65, theta=3.186124, up=1.000000
ITER 10: row=26, varin=12, theta=1.149263, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=57, theta=0.176770, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28172141.712984
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 61 rows, 60 cols, 311 nonzeros, 3 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 13 at  28.17214171298440206215
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6046ac0
% @LO 0.02  28.15289211138341229912 99.9000000000
% @LN 0.02  28.15690579160579787299 99.9000000000
% Resuming node 18 at  28.15690579160579787299
DEBUG CONSTRNT: LP rows=58, pool->nlprows=58, pool->npend=0
DEBUG CONSTRNT: Checking 58 LP rows (pool tracks 58, total LP rows 58)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=57, expected 57
 % @PAP adding 52 rows, 238 nz to LP
DEBUG BB: Processing node 18, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=52, theta=0.709202, up=999999999999999983222784.000000
ITER 2: row=45, varin=49, theta=0.558760, up=999999999999999983222784.000000
ITER 3: row=46, varin=36, theta=0.878373, up=999999999999999983222784.000000
ITER 4: row=48, varin=35, theta=0.696219, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28156905.791606
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 298 nonzeros, 2 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=62, theta=0.237210, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28165479.438592
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 302 nonzeros, 2 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 18 LP 1 Solution, length = 28165479.438592, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.237210 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.237210 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.237210 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.423257 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.525581 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.474419 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.474419 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.474419 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.576743 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.576743 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.576743 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28165479.438592, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 18 at  28.16547943859203684269
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6043950
% @LO 0.02  28.15690579160579787299 99.9000000000
% @LN 0.02  28.15705402996899664458 99.9000000000
% Resuming node 21 at  28.15705402996899664458
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=50, expected 50
 % @PAP adding 46 rows, 206 nz to LP
DEBUG BB: Processing node 21, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=64, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28157054.029969
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 266 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=69, theta=0.039177, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28158075.229242
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 274 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 21 LP 1 Solution, length = 28158075.229242, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.294156 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.294156 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.039177 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.294156 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.705844 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.705844 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.705844 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.705844 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.705844 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.705844 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28158075.229242, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.02  28.15705402996899664458 99.9000000000
 % @LN 0.02  28.15807522924159300715 99.9000000000
DEBUG CG: Second cutoff check: z=28158075.229242, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 21 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 21
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.294156
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.294156)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.294156
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.294156)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.039177
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.039177)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.294156
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.294156)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x18, Z0 = 28158075.2292416        , Z1 = 28404329.4779616        

DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=50, theta=0.778054, up=999999999999999983222784.000000
ITER 2: row=22, varin=41, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=41, varin=45, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=18, varin=6, theta=0.605621, up=999999999999999983222784.000000
ITER 5: row=28, varin=18, theta=0.497274, up=999999999999999983222784.000000
ITER 6: row=45, varin=28, theta=0.421811, up=999999999999999983222784.000000
ITER 7: row=6, varin=34, theta=0.903331, up=999999999999999983222784.000000
ITER 8: row=34, varin=43, theta=2.779580, up=999999999999999983222784.000000
ITER 9: row=43, varin=27, theta=1.779580, up=999999999999999983222784.000000
ITER 10: row=33, varin=35, theta=0.779580, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=53, theta=0.039290, up=1.000000
ITER 2: row=23, varin=52, theta=0.039437, up=1.000000
ITER 3: row=8, varin=51, theta=0.059016, up=1.000000
ITER 4: row=11, varin=35, theta=0.063148, up=999999999999999983222784.000000
ITER 5: row=47, varin=54, theta=0.044071, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28167110.579820
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 274 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 21 at  28.16711057982028165725
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60478a0
% @LO 0.02  28.15807522924159300715 99.9000000000
% @LN 0.02  28.16434337167828871884 99.9000000000
% Resuming node 19 at  28.16434337167828871884
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=49, expected 49
 % @PAP adding 48 rows, 204 nz to LP
DEBUG BB: Processing node 19, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=41, theta=0.562665, up=999999999999999983222784.000000
ITER 2: row=46, varin=37, theta=1.108781, up=999999999999999983222784.000000
ITER 3: row=45, varin=43, theta=0.553526, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28164343.371678
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 264 nonzeros, 3 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=65, theta=0.046563, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28166337.335974
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 262 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=68, theta=0.053230, up=1.000000
ITER 2: row=48, varin=18, theta=0.005958, up=999999999999999983222784.000000
ITER 3: row=50, varin=28, theta=0.007899, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28168499.084602
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 284 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=53, theta=0.094551, up=1.000000
ITER 2: row=8, varin=54, theta=0.079017, up=1.000000
ITER 3: row=22, varin=46, theta=0.471299, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28174826.013604
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 291 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=6, theta=0.058433, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28176625.289550
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.941567
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 279 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=56, theta=0.088196, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28177610.693084
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 274 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 19 LP 1 Solution, length = 28177610.693084, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.088196 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.676393 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.323607 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.323607 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.323607 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28177610.693084, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 19 at  28.17761069308394183963
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6046ac0
% @LO 0.02  28.16434337167828871884 99.9000000000
% @LN 0.02  28.16547943859203684269 99.9000000000
% Resuming node 18 at  28.16547943859203684269
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=48, expected 48
 % @PAP adding 51 rows, 238 nz to LP
DEBUG BB: Processing node 18, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 18 LP 2 Solution, length = 28165479.438592, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.237210 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.237210 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.237210 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.423257 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.525581 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.474419 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.474419 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.474419 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.576743 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.576743 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.576743 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28165479.438592, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28165479.438592, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 18 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 18
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.237210
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.237210)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.237210
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.237210)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.237210
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.237210)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.423257
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.423257)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.525581
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.525581)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[3] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x16, Z0 = 28165479.438592         , Z1 = 28267935.3808536        

DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=43, varin=51, theta=0.976861, up=999999999999999983222784.000000
ITER 2: row=27, varin=70, theta=0.060047, up=1.000000
ITER 3: row=49, varin=28, theta=0.054067, up=999999999999999983222784.000000
ITER 4: row=47, varin=33, theta=42502.000000, up=999999999999999983222784.000000
ITER 5: row=33, varin=34, theta=0.085955, up=999999999999999983222784.000000
ITER 6: row=51, varin=48, theta=0.773596, up=999999999999999983222784.000000
ITER 7: row=47, varin=47, theta=0.045506, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 1 gives z=28214321.684939
  % 	x8 = 1,	Z1 = 28214321.684939         
DEBUG EVAL: First branch cutoff check: z=28214321.684939, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
ITER 1: row=43, varin=44, theta=1.007146, up=999999999999999983222784.000000
ITER 2: row=27, varin=70, theta=0.003208, up=1.000000
ITER 3: row=49, varin=69, theta=0.004064, up=1.000000
ITER 4: row=50, varin=28, theta=0.000568, up=999999999999999983222784.000000
ITER 5: row=47, varin=49, theta=0.000127, up=999999999999999983222784.000000
  % 	x8 = 0,	Z0 = 28204981.6313585        
DEBUG EVAL: Second branch cutoff check: z=28204981.631358, best_z=INF, threshold=INF
  %   New best:  x8, Z = 28204981.6313585        
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=43, theta=1.012736, up=999999999999999983222784.000000
ITER 2: row=43, varin=51, theta=0.017962, up=999999999999999983222784.000000
ITER 3: row=33, varin=48, theta=0.533170, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28247145.136524
  % 	x5 = 1,	Z1 = 28247145.1365241        
DEBUG EVAL: First branch cutoff check: z=28247145.136524, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=1, varin=51, theta=1.082449, up=999999999999999983222784.000000
ITER 2: row=27, varin=70, theta=0.032952, up=1.000000
ITER 3: row=49, varin=69, theta=0.041275, up=1.000000
ITER 4: row=50, varin=28, theta=0.005787, up=999999999999999983222784.000000
ITER 5: row=47, varin=49, theta=0.001296, up=999999999999999983222784.000000
  % 	x5 = 0,	Z0 = 28199440.405738         
DEBUG EVAL: Second branch cutoff check: z=28199440.405738, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=44, theta=0.997798, up=999999999999999983222784.000000
ITER 2: row=27, varin=70, theta=0.005382, up=1.000000
ITER 3: row=49, varin=28, theta=0.004922, up=999999999999999983222784.000000
ITER 4: row=47, varin=33, theta=3959.000000, up=999999999999999983222784.000000
ITER 5: row=43, varin=46, theta=0.008007, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28193326.064821
  % 	x7 = 1,	Z1 = 28205419.077712         
DEBUG EVAL: First branch cutoff check: z=28205419.077712, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=33, varin=51, theta=1.082449, up=999999999999999983222784.000000
ITER 2: row=27, varin=70, theta=0.032952, up=1.000000
ITER 3: row=49, varin=69, theta=0.041275, up=1.000000
ITER 4: row=50, varin=28, theta=0.005787, up=999999999999999983222784.000000
ITER 5: row=47, varin=49, theta=0.001296, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 28199440.405738         
DEBUG EVAL: Second branch cutoff check: z=28199440.405738, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=69, theta=0.314485, up=1.000000
ITER 2: row=50, varin=70, theta=2.145325, up=1.000000
ITER 3: row=50, varin=28, theta=0.024744, up=999999999999999983222784.000000
ITER 4: row=47, varin=70, theta=0.964547, up=1.000000
ITER 5: row=27, varin=47, theta=0.303152, up=999999999999999983222784.000000
ITER 6: row=47, varin=53, theta=0.297166, up=1.000000
ITER 7: row=9, varin=54, theta=0.330438, up=1.000000
ITER 8: row=23, varin=58, theta=0.437317, up=1.000000
DEBUG EVAL: Branch var 16 = 1 gives z=28267935.380854
  % 	x16 = 1,	Z1 = 28267935.3808536        
DEBUG EVAL: First branch cutoff check: z=28267935.380854, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=6, varin=51, theta=0.935669, up=999999999999999983222784.000000
ITER 2: row=27, varin=6, theta=0.151924, up=999999999999999983222784.000000
  % 	x16 = 0,	Z0 = 28203929.9748712        
DEBUG EVAL: Second branch cutoff check: z=28203929.974871, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=70, theta=0.184009, up=1.000000
ITER 2: row=49, varin=69, theta=0.258591, up=1.000000
ITER 3: row=50, varin=28, theta=0.034838, up=999999999999999983222784.000000
ITER 4: row=47, varin=49, theta=0.007837, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28209739.153809
  % 	x10 = 0,	Z0 = 28209739.1538089        
DEBUG EVAL: First branch cutoff check: z=28209739.153809, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=27, varin=51, theta=0.841776, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28189237.0031212        
DEBUG EVAL: Second branch cutoff check: z=28189237.003121, best_z=INF, threshold=INF
  % Best branch is x8, Z0 = 28204981.6313585        , Z1 = 28214321.684939         

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   23   18	x8 = 0	28204981.631358
 % @NC   24   18	x8 = 1	28214321.684939
 %      18    13 28165479.4386               28167110.5798   x13 D     4     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6043950
% @LO 0.02  28.16547943859203684269 99.9000000000
% @LN 0.02  28.16711057982028165725 99.9000000000
% Resuming node 21 at  28.16711057982028165725
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=50, expected 50
 % @PAP adding 50 rows, 214 nz to LP
DEBUG BB: Processing node 21, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 21 LP 2 Solution, length = 28167110.579820, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.044071 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.303953 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.303953 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.303953 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.696047 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.696047 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.696047 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.696047 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.696047 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.696047 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28167110.579820, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28167110.579820, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 21 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 21
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.044071
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.044071)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.303953
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.303953)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.303953
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.303953)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.303953
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.303953)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x3, Z0 = 28167110.5798203        , Z1 = 28449863.6478155        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=47, theta=1.369718, up=999999999999999983222784.000000
ITER 2: row=35, varin=11, theta=1.280090, up=999999999999999983222784.000000
ITER 3: row=11, varin=8, theta=0.855419, up=999999999999999983222784.000000
ITER 4: row=8, varin=23, theta=0.852230, up=999999999999999983222784.000000
ITER 5: row=23, varin=50, theta=0.688126, up=999999999999999983222784.000000
ITER 6: row=33, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=41, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=1, varin=6, theta=0.068880, up=999999999999999983222784.000000
ITER 9: row=48, varin=18, theta=0.056557, up=999999999999999983222784.000000
ITER 10: row=49, varin=28, theta=0.047974, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28491217.179458
  % 	x3 = 1,	Z1 = 28491217.179458         
DEBUG EVAL: First branch cutoff check: z=28491217.179458, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=1, varin=95, theta=0.016528, up=1.000000
ITER 2: row=17, varin=77, theta=0.072333, up=1.000000
  % 	x3 = 0,	Z0 = 28170187.2841769        
DEBUG EVAL: Second branch cutoff check: z=28170187.284177, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28170187.2841769        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=6, theta=1.037198, up=999999999999999983222784.000000
ITER 2: row=48, varin=11, theta=12.060911, up=999999999999999983222784.000000
ITER 3: row=11, varin=41, theta=3.356458, up=999999999999999983222784.000000
ITER 4: row=41, varin=77, theta=9.553741, up=1.000000
ITER 5: row=41, varin=18, theta=1.146483, up=999999999999999983222784.000000
ITER 6: row=49, varin=28, theta=1.497871, up=999999999999999983222784.000000
ITER 7: row=27, varin=72, theta=2.162692, up=1.000000
ITER 8: row=27, varin=22, theta=0.853466, up=999999999999999983222784.000000
ITER 9: row=45, varin=73, theta=1.212446, up=1.000000
ITER 10: row=45, varin=76, theta=0.255913, up=1.000000
DEBUG EVAL: Branch var 17 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=47, theta=0.380606, up=999999999999999983222784.000000
ITER 2: row=35, varin=50, theta=0.328201, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
ITER 3: row=2, varin=95, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28271148.310875
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 274 nonzeros, 4 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=86, theta=0.383214, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28278501.439809
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 272 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=88, theta=0.369323, up=1.000000
ITER 2: row=53, varin=43, theta=0.059699, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28289309.147856
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 291 nonzeros, 3 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=78, theta=0.296887, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28291180.124182
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 283 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 21 at  28.29118012418205907466
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f605a370
% @LO 0.02  28.16711057982028165725 99.9000000000
% @LN 0.02  28.16856986837180798489 99.9000000000
% Resuming node 20 at  28.16856986837180798489
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=50, expected 50
 % @PAP adding 48 rows, 204 nz to LP
DEBUG BB: Processing node 20, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=38, theta=4.934266, up=999999999999999983222784.000000
ITER 2: row=44, varin=48, theta=0.937988, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28168569.868372
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 264 nonzeros, 4 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=45, varin=42, theta=1.056716, up=999999999999999983222784.000000
ITER 3: row=47, varin=66, theta=0.445414, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28350574.495145
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 274 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 6 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=69, theta=0.509187, up=1.000000
ITER 2: row=47, varin=18, theta=0.056997, up=999999999999999983222784.000000
ITER 3: row=50, varin=28, theta=0.075563, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28371253.460228
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 296 nonzeros, 5 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 5 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=53, theta=0.904459, up=1.000000
ITER 2: row=8, varin=54, theta=0.755862, up=1.000000
ITER 3: row=22, varin=45, theta=4.508374, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28431775.919771
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 301 nonzeros, 4 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 5 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=6, theta=0.455141, up=999999999999999983222784.000000
ITER 2: row=50, varin=51, theta=0.117920, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28448987.525221
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.441040
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 307 nonzeros, 6 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=44, theta=1.681449, up=999999999999999983222784.000000
ITER 2: row=49, varin=50, theta=0.357857, up=1.000000
ITER 3: row=6, varin=53, theta=0.279301, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28503679.877878
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 284 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=88, theta=0.142128, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28504200.830456
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 282 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=98, theta=0.051517, up=1.000000
ITER 2: row=16, varin=46, theta=0.101929, up=999999999999999983222784.000000
ITER 3: row=49, varin=80, theta=0.092516, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28512107.871719
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 290 nonzeros, 0 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 20 LP 1 Solution, length = 28512107.871719, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.226871 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.226871 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.226871 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.226871 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.092516 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.773129 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.773129 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.773129 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.773129 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.773129 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.773129 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28512107.871719, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 20 at  28.51210787171871174905
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60410f0
% @LO 0.02  28.16856986837180798489 99.9000000000
% @LN 0.02  28.17214171298440206215 99.9000000000
% Resuming node 13 at  28.17214171298440206215
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=52, expected 52
 % @PAP adding 58 rows, 245 nz to LP
DEBUG BB: Processing node 13, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 13 LP 2 Solution, length = 28172141.712984, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.146460 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.176770 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.176770 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.176770 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.823230 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.823230 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.823230 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.823230 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.823230 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28172141.712984, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28172141.712984, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 13 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 13
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.146460
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.146460)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.176770
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.176770)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.176770
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.176770)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.176770
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.176770)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x17, Z0 = 28172141.7129844        , Z1 = 28566122.9736101        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=13, theta=1.738749, up=999999999999999983222784.000000
ITER 2: row=25, varin=85, theta=9.858549, up=1.000000
ITER 3: row=25, varin=26, theta=2.260033, up=999999999999999983222784.000000
ITER 4: row=35, varin=80, theta=6.738434, up=1.000000
ITER 5: row=35, varin=43, theta=4.212256, up=999999999999999983222784.000000
ITER 6: row=34, varin=6, theta=2.718859, up=999999999999999983222784.000000
ITER 7: row=6, varin=81, theta=4.563379, up=1.000000
ITER 8: row=6, varin=84, theta=4.292448, up=1.000000
ITER 9: row=6, varin=87, theta=3.993266, up=1.000000
ITER 10: row=6, varin=86, theta=2.938870, up=1.000000
DEBUG EVAL: Branch var 17 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=12, theta=0.285290, up=999999999999999983222784.000000
ITER 2: row=54, varin=59, theta=2.672432, up=1.000000
ITER 3: row=54, varin=11, theta=1.713274, up=999999999999999983222784.000000
ITER 4: row=14, varin=59, theta=1.000000, up=1.000000
ITER 5: row=56, varin=47, theta=0.072504, up=999999999999999983222784.000000
ITER 6: row=57, varin=55, theta=0.064777, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
ITER 7: row=12, varin=54, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28219396.684453
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.352232
DEBUG SOLUTION: lp->best_solution[8] = 0.352232
DEBUG SOLUTION: lp->best_solution[9] = 0.352232
DEBUG SOLUTION: lp->best_solution[10] = 0.352232
DEBUG SOLUTION: lp->best_solution[11] = 2.408929
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 305 nonzeros, 7 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 7 slack rows
   % @PAP adding 7 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=7, theta=0.285290, up=999999999999999983222784.000000
ITER 2: row=48, varin=47, theta=0.193124, up=999999999999999983222784.000000
ITER 3: row=52, varin=85, theta=0.330245, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28242276.623406
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.776748
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 4.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 320 nonzeros, 7 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 7 slack rows
   % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=91, theta=0.203700, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28243916.021433
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 294 nonzeros, 0 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=101, theta=0.072181, up=1.000000
ITER 2: row=18, varin=78, theta=0.098146, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28259684.813046
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 302 nonzeros, 0 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=114, theta=0.201479, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28259849.069766
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 60 rows, 60 cols, 318 nonzeros, 3 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=104, theta=0.000416, up=1.000000
ITER 2: row=20, varin=81, theta=0.000811, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28259890.490424
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 312 nonzeros, 0 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 13 at  28.25989049042406264789
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60478a0
% @LO 0.02  28.17214171298440206215 99.9000000000
% @LN 0.02  28.17761069308394183963 99.9000000000
% Resuming node 19 at  28.17761069308394183963
DEBUG CONSTRNT: LP rows=58, pool->nlprows=58, pool->npend=0
DEBUG CONSTRNT: Checking 58 LP rows (pool tracks 58, total LP rows 58)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=57, expected 57
 % @PAP adding 49 rows, 214 nz to LP
DEBUG BB: Processing node 19, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 19 LP 2 Solution, length = 28177610.693084, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.088196 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.676393 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.323607 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.323607 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.323607 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28177610.693084, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28177610.693084, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 19 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 19
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.088196
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.088196)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.676393
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.676393)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[3] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 6
DEBUG CAREFUL: New best var: 6
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x6, Z0 = 28177610.6930839        , Z1 = 28466032.5124357        

DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=42, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=25, varin=48, theta=0.175769, up=999999999999999983222784.000000
ITER 4: row=40, varin=47, theta=0.135481, up=999999999999999983222784.000000
ITER 5: row=46, varin=35, theta=0.240145, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28426284.912993
  % 	x5 = 1,	Z1 = 28426284.9129927        
DEBUG EVAL: First branch cutoff check: z=28426284.912993, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=1, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=25, varin=45, theta=2.042424, up=999999999999999983222784.000000
ITER 4: row=30, varin=38, theta=0.057695, up=999999999999999983222784.000000
  % 	x5 = 0,	Z0 = 28328784.8864694        
DEBUG EVAL: Second branch cutoff check: z=28328784.886469, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28328784.8864694        
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=40, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28218694.643134
  % 	x14 = 1,	Z1 = 28218694.6431341        
DEBUG EVAL: First branch cutoff check: z=28218694.643134, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=48, theta=0.128447, up=999999999999999983222784.000000
ITER 4: row=40, varin=47, theta=0.099006, up=999999999999999983222784.000000
ITER 5: row=46, varin=36, theta=0.175492, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28388786.186160
  % 	x7 = 1,	Z1 = 28388786.1861599        
DEBUG EVAL: First branch cutoff check: z=28388786.186160, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=38, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=45, theta=2.042424, up=999999999999999983222784.000000
ITER 4: row=30, varin=42, theta=0.056652, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 28330488.1545917        
DEBUG EVAL: Second branch cutoff check: z=28330488.154592, best_z=INF, threshold=INF
  %   New best:  x7, Z = 28330488.1545917        
DEBUG EVAL: Testing var 6 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=48, theta=0.503415, up=999999999999999983222784.000000
ITER 2: row=40, varin=21, theta=0.981448, up=999999999999999983222784.000000
ITER 3: row=21, varin=47, theta=0.522047, up=999999999999999983222784.000000
ITER 4: row=46, varin=7, theta=0.977498, up=999999999999999983222784.000000
ITER 5: row=7, varin=44, theta=0.494336, up=999999999999999983222784.000000
ITER 6: row=44, varin=43, theta=1.106732, up=999999999999999983222784.000000
ITER 7: row=20, varin=39, theta=1.890318, up=999999999999999983222784.000000
ITER 8: row=34, varin=40, theta=0.931504, up=999999999999999983222784.000000
ITER 9: row=1, varin=34, theta=0.139000, up=999999999999999983222784.000000
ITER 10: row=41, varin=42, theta=0.095633, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 6 = 1 gives z=28410784.605745
  % 	x6 = 1,	Z1 = 28466032.5124357        
DEBUG EVAL: First branch cutoff check: z=28466032.512436, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 6 = 0
ITER 1: row=30, varin=45, theta=0.175776, up=999999999999999983222784.000000
  % 	x6 = 0,	Z0 = 28179914.1410515        
DEBUG EVAL: Second branch cutoff check: z=28179914.141052, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=48, theta=0.316495, up=999999999999999983222784.000000
ITER 2: row=40, varin=47, theta=0.243953, up=999999999999999983222784.000000
ITER 3: row=46, varin=43, theta=0.281952, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28212554.135208
  % 	x10 = 1,	Z1 = 28212554.1352078        
DEBUG EVAL: First branch cutoff check: z=28212554.135208, best_z=INF, threshold=INF
  % Best branch is x7, Z0 = 28330488.1545917        , Z1 = 28388786.1861599        

DEBUG CAREFUL: Final result - returning best.var = 7
DEBUG BB: Branching variable chosen: j=7
 % @NC   25   19	x7 = 0	28330488.154592
 % @NC   26   19	x7 = 1	28388786.186160
 %      19    14 28177610.6931               28204981.6314    x8 D    15     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6057f50
% @LO 0.02  28.17761069308394183963 99.9000000000
% @LN 0.02  28.20498163135846070304 99.9000000000
% Resuming node 23 at  28.20498163135846070304
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=48, expected 48
 % @PAP adding 51 rows, 238 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=44, theta=1.007146, up=999999999999999983222784.000000
ITER 2: row=27, varin=70, theta=0.003208, up=1.000000
ITER 3: row=49, varin=69, theta=0.004064, up=1.000000
ITER 4: row=50, varin=28, theta=0.000568, up=999999999999999983222784.000000
ITER 5: row=47, varin=49, theta=0.000127, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28204981.631358
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 298 nonzeros, 4 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 9 rows, 36 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=71, theta=0.558798, up=1.000000
ITER 2: row=54, varin=62, theta=0.274736, up=1.000000
ITER 3: row=9, varin=63, theta=0.229598, up=1.000000
ITER 4: row=23, varin=48, theta=1.369449, up=999999999999999983222784.000000
ITER 5: row=49, varin=61, theta=0.242051, up=1.000000
ITER 6: row=2, varin=43, theta=0.925658, up=999999999999999983222784.000000
ITER 7: row=53, varin=7, theta=0.059734, up=999999999999999983222784.000000
ITER 8: row=59, varin=67, theta=0.090160, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28238331.368563
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 60 rows, 60 cols, 334 nonzeros, 4 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 5 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=51, theta=0.666667, up=999999999999999983222784.000000
ITER 2: row=59, varin=48, theta=0.326828, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28243471.628737
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.934634
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 61 rows, 60 cols, 325 nonzeros, 7 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % Node 23 LP 1 Solution, length = 28243471.628737, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.333333 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.333333 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.529430 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.333333 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.065366 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.065366 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.666667 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.934634 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.934634 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.666667 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.666667 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.470570 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.470570 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.934634 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.470570 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28243471.628737, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 23 at  28.24347162873703709352
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6050790
% @LO 0.02  28.20498163135846070304 99.9000000000
% @LN 0.02  28.21432168493897663097 99.9000000000
% Resuming node 24 at  28.21432168493897663097
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=53, expected 53
 % @PAP adding 51 rows, 238 nz to LP
DEBUG BB: Processing node 24, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=51, theta=0.976861, up=999999999999999983222784.000000
ITER 2: row=27, varin=70, theta=0.060047, up=1.000000
ITER 3: row=49, varin=28, theta=0.054067, up=999999999999999983222784.000000
ITER 4: row=47, varin=33, theta=42502.000000, up=999999999999999983222784.000000
ITER 5: row=33, varin=34, theta=0.085955, up=999999999999999983222784.000000
ITER 6: row=51, varin=48, theta=0.773596, up=999999999999999983222784.000000
ITER 7: row=47, varin=47, theta=0.045506, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
ITER 8: row=50, varin=33, theta=42502.000000, up=999999999999999983222784.000000
ITER 9: row=1, varin=49, theta=0.000000, up=999999999999999983222784.000000
ITER 10: row=28, varin=111, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28210499.482748
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 298 nonzeros, 2 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=74, theta=0.333333, up=1.000000
ITER 3: row=33, varin=63, theta=0.433025, up=1.000000
ITER 4: row=55, varin=66, theta=0.487987, up=1.000000
ITER 5: row=54, varin=55, theta=8.000000, up=999999999999999983222784.000000
ITER 6: row=33, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=47, varin=73, theta=0.442759, up=1.000000
ITER 8: row=48, varin=102, theta=0.049562, up=1.000000
ITER 9: row=50, varin=28, theta=0.065705, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28467248.470338
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 322 nonzeros, 8 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 5 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=60, theta=0.748212, up=1.000000
ITER 2: row=6, varin=54, theta=0.786466, up=1.000000
ITER 3: row=9, varin=55, theta=0.657254, up=1.000000
ITER 4: row=22, varin=44, theta=3.920222, up=999999999999999983222784.000000
ITER 5: row=52, varin=53, theta=0.131004, up=1.000000
ITER 6: row=2, varin=59, theta=0.118433, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28523614.669837
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 303 nonzeros, 3 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 8 rows, 38 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=49, theta=0.218632, up=999999999999999983222784.000000
ITER 2: row=50, varin=7, theta=0.510622, up=999999999999999983222784.000000
ITER 3: row=52, varin=94, theta=0.652843, up=1.000000
ITER 4: row=54, varin=52, theta=0.150886, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28584825.640473
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.818937
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 327 nonzeros, 6 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 4 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=59, theta=0.357923, up=1.000000
ITER 2: row=54, varin=52, theta=1.582849, up=999999999999999983222784.000000
ITER 3: row=42, varin=43, theta=0.375102, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28591655.306582
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 310 nonzeros, 1 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=94, theta=0.505180, up=1.000000
ITER 2: row=51, varin=82, theta=0.762255, up=1.000000
ITER 3: row=3, varin=84, theta=0.328840, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28621611.888097
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 308 nonzeros, 0 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=114, theta=0.283044, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28628493.440832
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 60 rows, 60 cols, 315 nonzeros, 3 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=103, theta=0.142685, up=1.000000
ITER 2: row=13, varin=6, theta=0.197027, up=999999999999999983222784.000000
ITER 3: row=6, varin=100, theta=0.134355, up=1.000000
ITER 4: row=12, varin=82, theta=0.165994, up=1.000000
ITER 5: row=49, varin=80, theta=0.067021, up=1.000000
ITER 6: row=32, varin=81, theta=0.067999, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28641545.855040
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 309 nonzeros, 0 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 24 LP 1 Solution, length = 28641545.855040, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.155334 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.155334 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.155334 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.155334 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.155334 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.067999 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.155334 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.844666 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.844666 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.844666 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.844666 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.844666 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.844666 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.844666 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28641545.855040, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 24 at  28.64154585503956340631
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6040360
% @LO 0.02  28.21432168493897663097 99.9000000000
% @LN 0.02  28.22553136432968301506 99.9000000000
% Resuming node 12 at  28.22553136432968301506
DEBUG CONSTRNT: LP rows=58, pool->nlprows=58, pool->npend=0
DEBUG CONSTRNT: Checking 58 LP rows (pool tracks 58, total LP rows 58)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=57, expected 57
 % @PAP adding 50 rows, 192 nz to LP
DEBUG BB: Processing node 12, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=6, varin=95, theta=0.400000, up=1.000000
ITER 3: row=18, varin=104, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28002421.419595
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 252 nonzeros, 6 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 52 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=18, theta=4.402179, up=999999999999999983222784.000000
ITER 2: row=51, varin=80, theta=1.137535, up=1.000000
ITER 3: row=51, varin=8, theta=0.883648, up=999999999999999983222784.000000
ITER 4: row=14, varin=77, theta=0.306213, up=1.000000
ITER 5: row=31, varin=75, theta=0.132527, up=1.000000
ITER 6: row=8, varin=14, theta=0.137130, up=999999999999999983222784.000000
ITER 7: row=12, varin=51, theta=0.139819, up=999999999999999983222784.000000
ITER 8: row=29, varin=31, theta=0.377779, up=999999999999999983222784.000000
ITER 9: row=14, varin=46, theta=0.138386, up=999999999999999983222784.000000
ITER 10: row=46, varin=47, theta=0.155265, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=17)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28225531.364330
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 304 nonzeros, 3 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=37, theta=0.189726, up=999999999999999983222784.000000
ITER 2: row=54, varin=81, theta=1.012421, up=1.000000
ITER 3: row=54, varin=84, theta=0.015894, up=1.000000
ITER 4: row=45, varin=102, theta=0.166667, up=1.000000
ITER 5: row=37, varin=54, theta=2.780518, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 325 nonzeros, 9 slack, 49 tight.
  % Node 12 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.867214 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.132786 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 12 is INFEASIBLE
 %      12    13    infeasible               28243471.6287    x7 U     5     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6057f50
% @LO 0.02  28.22553136432968301506 99.9000000000
% @LN 0.02  28.24347162873703709352 99.9000000000
% Resuming node 23 at  28.24347162873703709352
DEBUG CONSTRNT: LP rows=58, pool->nlprows=58, pool->npend=0
DEBUG CONSTRNT: Checking 58 LP rows (pool tracks 58, total LP rows 58)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=57, expected 57
 % @PAP adding 54 rows, 228 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 23 LP 2 Solution, length = 28243471.628737, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.333333 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.333333 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.529430 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.333333 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.065366 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.065366 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.666667 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.934634 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.934634 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.666667 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.666667 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.470570 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.470570 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.934634 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.470570 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28243471.628737, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28243471.628737, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 23 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 23
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.333333
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.333333
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.529430
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.529430)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.333333
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.065366
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.065366)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.065366
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.065366)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[4] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x18, Z0 = 28243471.628737         , Z1 = 28507528.9614014        

DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=50, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=25, varin=58, theta=0.516091, up=1.000000
ITER 4: row=42, varin=49, theta=0.037630, up=999999999999999983222784.000000
ITER 5: row=44, varin=81, theta=0.104023, up=1.000000
DEBUG EVAL: Branch var 16 = 1 gives z=28340198.514493
  % 	x16 = 1,	Z1 = 28340198.5144935        
DEBUG EVAL: First branch cutoff check: z=28340198.514493, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=6, varin=6, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=48, varin=41, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=51, varin=40, theta=0.500000, up=999999999999999983222784.000000
  % 	x16 = 0,	Z0 = 28490269.9694901        
DEBUG EVAL: Second branch cutoff check: z=28490269.969490, best_z=INF, threshold=INF
  %   New best:  x16, Z = 28340198.5144935        
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=45, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=30, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=51, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=54, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=31, varin=58, theta=1.026157, up=1.000000
ITER 6: row=31, varin=89, theta=0.060616, up=1.000000
ITER 7: row=43, varin=79, theta=0.427308, up=1.000000
ITER 8: row=3, varin=25, theta=0.047750, up=999999999999999983222784.000000
ITER 9: row=39, varin=81, theta=0.117206, up=1.000000
ITER 10: row=31, varin=42, theta=0.014154, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28874709.173818
  % 	x5 = 1,	Z1 = 28874709.1738177        
DEBUG EVAL: First branch cutoff check: z=28874709.173818, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=1, varin=50, theta=0.500000, up=999999999999999983222784.000000
  % 	x5 = 0,	Z0 = 28246953.5514743        
DEBUG EVAL: Second branch cutoff check: z=28246953.551474, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=45, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28262531.921592
  % 	x7 = 0,	Z0 = 28262531.9215917        
DEBUG EVAL: First branch cutoff check: z=28262531.921592, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=44, varin=52, theta=2.344782, up=999999999999999983222784.000000
ITER 2: row=52, varin=50, theta=12.704103, up=999999999999999983222784.000000
ITER 3: row=1, varin=2, theta=2.127503, up=999999999999999983222784.000000
ITER 4: row=2, varin=8, theta=2.414787, up=999999999999999983222784.000000
ITER 5: row=8, varin=21, theta=2.424545, up=999999999999999983222784.000000
ITER 6: row=21, varin=43, theta=1.456315, up=999999999999999983222784.000000
ITER 7: row=47, varin=42, theta=1.189197, up=999999999999999983222784.000000
ITER 8: row=31, varin=60, theta=1.010833, up=1.000000
ITER 9: row=31, varin=57, theta=0.011508, up=1.000000
ITER 10: row=51, varin=60, theta=0.666667, up=1.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28874978.962837
  % 	x17 = 1,	Z1 = 28874978.9628375        
DEBUG EVAL: First branch cutoff check: z=28874978.962837, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=44, varin=49, theta=0.136737, up=999999999999999983222784.000000
  % 	x17 = 0,	Z0 = 28252707.0109069        
DEBUG EVAL: Second branch cutoff check: z=28252707.010907, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=52, theta=2.344782, up=999999999999999983222784.000000
ITER 2: row=52, varin=50, theta=12.704103, up=999999999999999983222784.000000
ITER 3: row=1, varin=2, theta=2.127503, up=999999999999999983222784.000000
ITER 4: row=2, varin=49, theta=1.720144, up=999999999999999983222784.000000
ITER 5: row=45, varin=8, theta=1.010959, up=999999999999999983222784.000000
ITER 6: row=25, varin=60, theta=2.514564, up=1.000000
ITER 7: row=25, varin=46, theta=1.113931, up=999999999999999983222784.000000
ITER 8: row=44, varin=44, theta=0.672691, up=999999999999999983222784.000000
ITER 9: row=51, varin=60, theta=1.045714, up=1.000000
ITER 10: row=51, varin=40, theta=0.067882, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28718203.558681
  % 	x18 = 1,	Z1 = 28718203.5586809        
DEBUG EVAL: First branch cutoff check: z=28718203.558681, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=42, varin=58, theta=0.157942, up=1.000000
  % 	x18 = 0,	Z0 = 28256608.885631         
DEBUG EVAL: Second branch cutoff check: z=28256608.885631, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=58, theta=0.620458, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28295079.936293
  % 	x10 = 1,	Z1 = 28295079.9362927        
DEBUG EVAL: First branch cutoff check: z=28295079.936293, best_z=INF, threshold=INF
  % Best branch is x16, Z0 = 28490269.9694901        , Z1 = 28340198.5144935        

DEBUG CAREFUL: Final result - returning best.var = 16
DEBUG BB: Branching variable chosen: j=16
 % @NC   27   23	x16 = 1	28340198.514493
 % @NC   28   23	x16 = 0	28490269.969490
 %      23    14 28243471.6287               28259890.4904    x8 D    18     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60410f0
% @LO 0.02  28.24347162873703709352 99.9000000000
% @LN 0.02  28.25989049042406264789 99.9000000000
% Resuming node 13 at  28.25989049042406264789
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=53, expected 53
 % @PAP adding 58 rows, 252 nz to LP
DEBUG BB: Processing node 13, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 13 LP 3 Solution, length = 28259890.490424, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.199838 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.199838 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.199838 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.199838 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000811 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.199838 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.800162 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.800162 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.800162 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.800162 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.800162 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.800162 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28259890.490424, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28259890.490424, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 13 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 13
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.199838
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.199838)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.199838
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.199838)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.199838
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.199838)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.199838
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.199838)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000811
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.000811)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.199838
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.199838)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x3, Z0 = 28259890.4904241        , Z1 = 28545083.5580644        

DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=20, theta=1.280749, up=999999999999999983222784.000000
ITER 2: row=12, varin=58, theta=2.277830, up=999999999999999983222784.000000
ITER 3: row=1, varin=54, theta=0.887676, up=999999999999999983222784.000000
ITER 4: row=54, varin=8, theta=0.794903, up=999999999999999983222784.000000
ITER 5: row=8, varin=53, theta=1.842353, up=999999999999999983222784.000000
ITER 6: row=49, varin=49, theta=0.967694, up=999999999999999983222784.000000
ITER 7: row=45, varin=45, theta=0.462203, up=999999999999999983222784.000000
ITER 8: row=23, varin=47, theta=0.460772, up=999999999999999983222784.000000
ITER 9: row=8, varin=9, theta=0.146616, up=999999999999999983222784.000000
ITER 10: row=20, varin=41, theta=0.953796, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=28511970.931299
  % 	x22 = 1,	Z1 = 28536126.0078311        
DEBUG EVAL: First branch cutoff check: z=28536126.007831, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=30, varin=84, theta=0.000866, up=1.000000
ITER 2: row=57, varin=37, theta=0.000183, up=999999999999999983222784.000000
  % 	x22 = 0,	Z0 = 28259931.5453421        
DEBUG EVAL: Second branch cutoff check: z=28259931.545342, best_z=INF, threshold=INF
  %   New best:  x22, Z = 28259931.5453421        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=20, theta=2.691418, up=999999999999999983222784.000000
ITER 2: row=12, varin=58, theta=7.127230, up=999999999999999983222784.000000
ITER 3: row=53, varin=7, theta=0.969429, up=999999999999999983222784.000000
ITER 4: row=46, varin=47, theta=0.866679, up=999999999999999983222784.000000
ITER 5: row=49, varin=8, theta=2.112524, up=999999999999999983222784.000000
ITER 6: row=8, varin=19, theta=1.010686, up=999999999999999983222784.000000
ITER 7: row=48, varin=54, theta=-215.515251, up=999999999999999983222784.000000
ITER 8: row=30, varin=6, theta=2.298677, up=999999999999999983222784.000000
ITER 9: row=6, varin=25, theta=1.044720, up=999999999999999983222784.000000
ITER 10: row=48, varin=81, theta=2.278054, up=1.000000
DEBUG EVAL: Branch var 3 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x3 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=6, theta=0.335137, up=999999999999999983222784.000000
ITER 2: row=52, varin=41, theta=0.888397, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28306889.747088
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 312 nonzeros, 1 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 5 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=62, varin=41, theta=2.681836, up=999999999999999983222784.000000
ITER 2: row=6, varin=44, theta=0.139591, up=999999999999999983222784.000000
ITER 3: row=58, varin=88, theta=0.086480, up=1.000000
ITER 4: row=56, varin=37, theta=0.018236, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 28333017.533224
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 62 rows, 60 cols, 331 nonzeros, 8 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 8 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=84, theta=0.091557, up=1.000000
ITER 2: row=39, varin=79, theta=0.029420, up=1.000000
ITER 3: row=41, varin=36, theta=0.020454, up=999999999999999983222784.000000
ITER 4: row=26, varin=50, theta=0.148913, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28337150.612015
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 303 nonzeros, 1 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 13 at  28.33715061201512952493
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6055740
% @LO 0.02  28.25989049042406264789 99.9000000000
% @LN 0.02  28.26609597327500011943 99.9000000000
% Resuming node 14 at  28.26609597327500011943
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=53, expected 53
 % @PAP adding 71 rows, 277 nz to LP
DEBUG BB: Processing node 14, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=60, varin=36, theta=0.270968, up=999999999999999983222784.000000
ITER 2: row=36, varin=70, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=1, varin=65, theta=0.019764, up=999999999999999983222784.000000
ITER 4: row=65, varin=93, theta=0.543050, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=71)
DEBUG SOLUTION: LP solution array indices: FST[72-111], not_covered[112-131]
DEBUG SOLUTION: lp->best_solution[0] = 28266095.973275
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 71 rows, 60 cols, 337 nonzeros, 2 slack, 69 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=74)
DEBUG SOLUTION: LP solution array indices: FST[75-114], not_covered[115-134]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 74 rows, 60 cols, 349 nonzeros, 2 slack, 72 tight.
  % Node 14 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.228475 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.543050 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 14 is INFEASIBLE
 %      14    13    infeasible               28273485.3506   x15 U     2     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6038600
% @LO 0.02  28.26609597327500011943 99.9000000000
% @LN 0.02  28.27348535056453471270 99.9000000000
% Resuming node 7 at  28.27348535056453471270
DEBUG CONSTRNT: LP rows=74, pool->nlprows=74, pool->npend=0
DEBUG CONSTRNT: Checking 74 LP rows (pool tracks 74, total LP rows 74)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=64, expected 64
DEBUG CONSTRNT: Checking LP row 65 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=65, expected 65
DEBUG CONSTRNT: Checking LP row 66 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=66, expected 66
DEBUG CONSTRNT: Checking LP row 67 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=67, expected 67
DEBUG CONSTRNT: Checking LP row 68 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=68, expected 68
DEBUG CONSTRNT: Checking LP row 69 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=69, expected 69
DEBUG CONSTRNT: Checking LP row 70 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=70, expected 70
DEBUG CONSTRNT: Checking LP row 71 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=71, expected 71
DEBUG CONSTRNT: Checking LP row 72 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=72, expected 72
DEBUG CONSTRNT: Checking LP row 73 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=73, expected 73
 % @PAP adding 56 rows, 240 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 7 LP 4 Solution, length = 28273485.350565, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.162075 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.162075 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.094813 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.162075 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.162075 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.162075 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.162075 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.837925 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.837925 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.837925 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.837925 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.837925 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.837925 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.837925 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28273485.350565, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28273485.350565, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.162075
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.162075)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.162075
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.162075)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.094813
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.094813)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.162075
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.162075)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.162075
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.162075)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.162075
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.162075)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.162075
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.162075)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[1] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x4, Z0 = 28273485.3505645        , Z1 = 28653173.3503737        

DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=43, varin=54, theta=0.838317, up=999999999999999983222784.000000
ITER 2: row=50, varin=51, theta=0.770616, up=999999999999999983222784.000000
ITER 3: row=51, varin=50, theta=646625.000000, up=999999999999999983222784.000000
ITER 4: row=50, varin=39, theta=0.333333, up=999999999999999983222784.000000
ITER 5: row=40, varin=49, theta=0.820166, up=999999999999999983222784.000000
ITER 6: row=49, varin=40, theta=0.362229, up=999999999999999983222784.000000
ITER 7: row=39, varin=18, theta=0.327719, up=999999999999999983222784.000000
ITER 8: row=11, varin=7, theta=0.294404, up=999999999999999983222784.000000
ITER 9: row=7, varin=46, theta=0.814798, up=999999999999999983222784.000000
ITER 10: row=46, varin=43, theta=0.517533, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x4 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=80, theta=0.166293, up=1.000000
ITER 2: row=47, varin=78, theta=0.069434, up=1.000000
ITER 3: row=36, varin=6, theta=0.065601, up=999999999999999983222784.000000
ITER 4: row=24, varin=79, theta=0.069095, up=1.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=6, varin=24, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28286240.614857
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 300 nonzeros, 0 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 7 at  28.28624061485708907071
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6038600
% @LO 0.02  28.27348535056453471270 99.9000000000
% @LN 0.02  28.28624061485708907071 99.9000000000
% Resuming node 7 at  28.28624061485708907071
DEBUG CONSTRNT: LP rows=56, pool->nlprows=56, pool->npend=0
DEBUG CONSTRNT: Checking 56 LP rows (pool tracks 56, total LP rows 56)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=55, expected 55
 % @PAP adding 56 rows, 240 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 7 LP 5 Solution, length = 28286240.614857, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.186181 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.186181 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.186181 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.186181 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.186181 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.069095 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.186181 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.813819 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.813819 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.813819 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.813819 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.813819 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.813819 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.813819 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28286240.614857, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28286240.614857, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.186181
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.186181)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.186181
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.186181)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.186181
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.186181)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.186181
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.186181)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.186181
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.186181)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.069095
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.069095)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.186181
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.186181)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[1] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x11, Z0 = 28286240.6148571        , Z1 = 28616397.9164915        

DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=50, varin=114, theta=0.155913, up=1.000000
ITER 2: row=34, varin=47, theta=2.240443, up=999999999999999983222784.000000
ITER 3: row=47, varin=54, theta=1.183040, up=999999999999999983222784.000000
ITER 4: row=43, varin=51, theta=0.778107, up=999999999999999983222784.000000
ITER 5: row=51, varin=50, theta=395984.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=29447663.087878
  % 	x22 = 1,	Z1 = 29447663.087878         
DEBUG EVAL: First branch cutoff check: z=29447663.087878, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=50, varin=85, theta=0.076823, up=1.000000
  % 	x22 = 0,	Z0 = 28288428.8654742        
DEBUG EVAL: Second branch cutoff check: z=28288428.865474, best_z=INF, threshold=INF
  %   New best:  x22, Z = 28288428.8654742        
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=43, varin=114, theta=138.671046, up=1.000000
ITER 2: row=43, varin=41, theta=1.269070, up=999999999999999983222784.000000
ITER 3: row=34, varin=114, theta=1.000000, up=1.000000
ITER 4: row=55, varin=34, theta=-219.563467, up=999999999999999983222784.000000
ITER 5: row=55, varin=48, theta=4.232434, up=999999999999999983222784.000000
ITER 6: row=23, varin=42, theta=1.481242, up=999999999999999983222784.000000
ITER 7: row=56, varin=18, theta=2.445702, up=999999999999999983222784.000000
ITER 8: row=11, varin=49, theta=6.476540, up=999999999999999983222784.000000
ITER 9: row=49, varin=7, theta=1.888182, up=999999999999999983222784.000000
ITER 10: row=7, varin=46, theta=6.562260, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x11 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=40, theta=1.222629, up=999999999999999983222784.000000
ITER 2: row=44, varin=54, theta=0.245824, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28329039.782015
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 300 nonzeros, 3 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=84, theta=0.018690, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28329485.706372
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 298 nonzeros, 0 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=36, theta=0.003371, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28330005.901007
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 303 nonzeros, 2 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 3 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=6, theta=0.016704, up=999999999999999983222784.000000
ITER 2: row=24, varin=85, theta=0.018601, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28330179.927287
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 308 nonzeros, 0 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 7 at  28.33017992728729694818
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6043950
% @LO 0.02  28.28624061485708907071 99.9000000000
% @LN 0.02  28.29118012418205907466 99.9000000000
% Resuming node 21 at  28.29118012418205907466
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=56, expected 56
 % @PAP adding 51 rows, 223 nz to LP
DEBUG BB: Processing node 21, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 21 LP 3 Solution, length = 28291180.124182, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.351556 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.351556 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.351556 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.296887 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.648444 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.648444 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.648444 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.648444 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.648444 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.648444 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28291180.124182, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28291180.124182, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 21 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 21
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.351556
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.351556)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.351556
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.351556)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.351556
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.351556)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.296887
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.296887)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x3, Z0 = 28291180.1241821        , Z1 = 28491217.179458         

DEBUG EVAL: Testing var 20 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=50, theta=3.359998, up=999999999999999983222784.000000
ITER 2: row=41, varin=51, theta=0.550315, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 0 gives z=28379249.842975
  % 	x20 = 0,	Z0 = 28379249.8429748        
DEBUG EVAL: First branch cutoff check: z=28379249.842975, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 1
ITER 1: row=6, varin=51, theta=3.199103, up=999999999999999983222784.000000
ITER 2: row=45, varin=48, theta=3.534093, up=999999999999999983222784.000000
ITER 3: row=48, varin=22, theta=2.693905, up=999999999999999983222784.000000
ITER 4: row=44, varin=2, theta=2.107869, up=999999999999999983222784.000000
ITER 5: row=41, varin=42, theta=2.178190, up=999999999999999983222784.000000
ITER 6: row=45, varin=73, theta=3.577484, up=1.000000
ITER 7: row=45, varin=75, theta=8.536753, up=1.000000
ITER 8: row=45, varin=74, theta=2.344941, up=1.000000
ITER 9: row=45, varin=77, theta=1.530126, up=1.000000
ITER 10: row=45, varin=80, theta=0.601122, up=1.000000
  % 	x20 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=50, theta=3.359998, up=999999999999999983222784.000000
ITER 2: row=41, varin=51, theta=0.550315, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28379249.842975
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 283 nonzeros, 2 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=48, theta=0.604147, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28387840.542247
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 276 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 1 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=43, theta=0.373629, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28412407.075594
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 278 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=75, theta=0.186684, up=1.000000
ITER 2: row=17, varin=104, theta=0.223298, up=1.000000
LP PHASE: Switching to primal (iter=2)
ITER 3: row=22, varin=33, theta=142395.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28414606.423318
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 280 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=60, theta=8.000000, up=1.000000
ITER 2: row=1, varin=64, theta=4.666667, up=1.000000
ITER 3: row=1, varin=57, theta=5.500000, up=1.000000
ITER 4: row=1, varin=58, theta=4.500000, up=1.000000
ITER 5: row=1, varin=90, theta=7.000000, up=1.000000
ITER 6: row=1, varin=91, theta=6.000000, up=1.000000
ITER 7: row=1, varin=92, theta=5.000000, up=1.000000
ITER 8: row=1, varin=93, theta=4.000000, up=1.000000
ITER 9: row=1, varin=94, theta=3.000000, up=1.000000
ITER 10: row=1, varin=95, theta=2.000000, up=1.000000
LP PHASE: Switching to primal (iter=44)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28414606.423318
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 240 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 21 at  28.41460642331820096729
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6038600
% @LO 0.02  28.29118012418205907466 99.9000000000
% @LN 0.02  28.33017992728729694818 99.9000000000
% Resuming node 7 at  28.33017992728729694818
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=48, expected 48
 % @PAP adding 57 rows, 248 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 7 LP 6 Solution, length = 28330179.927287, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.245350 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.245350 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.245350 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.245350 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.245350 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.245350 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.018601 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.754650 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.754650 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.754650 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.754650 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.754650 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.754650 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.754650 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28330179.927287, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28330179.927287, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.245350
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.245350)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.245350
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.245350)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.245350
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.245350)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.245350
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.245350)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.245350
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.245350)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.245350
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.245350)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.018601
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.018601)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[6] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
  % Initial guess is x22, Z0 = 28330179.9272873        , Z1 = 29447663.087878         

DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=24, theta=6.810446, up=999999999999999983222784.000000
ITER 2: row=24, varin=39, theta=1.151465, up=999999999999999983222784.000000
ITER 3: row=43, varin=41, theta=0.783161, up=999999999999999983222784.000000
ITER 4: row=53, varin=43, theta=2.448475, up=999999999999999983222784.000000
ITER 5: row=24, varin=46, theta=2.967332, up=999999999999999983222784.000000
ITER 6: row=21, varin=44, theta=3.147453, up=999999999999999983222784.000000
ITER 7: row=44, varin=40, theta=0.776336, up=999999999999999983222784.000000
ITER 8: row=49, varin=83, theta=0.124858, up=1.000000
DEBUG EVAL: Branch var 22 = 1 gives z=29365442.122519
  % 	x22 = 1,	Z1 = 29447663.087878         
DEBUG EVAL: First branch cutoff check: z=29447663.087878, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=41, varin=52, theta=0.238576, up=999999999999999983222784.000000
  % 	x22 = 0,	Z0 = 28346464.4396281        
DEBUG EVAL: Second branch cutoff check: z=28346464.439628, best_z=INF, threshold=INF
  %   New best:  x22, Z = 28346464.4396281        
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=42, theta=0.294577, up=999999999999999983222784.000000
ITER 2: row=38, varin=55, theta=11.356215, up=999999999999999983222784.000000
ITER 3: row=55, varin=95, theta=1.618172, up=1.000000
ITER 4: row=55, varin=108, theta=0.250546, up=1.000000
ITER 5: row=49, varin=54, theta=0.318640, up=999999999999999983222784.000000
ITER 6: row=54, varin=24, theta=0.507926, up=999999999999999983222784.000000
ITER 7: row=24, varin=95, theta=0.652171, up=1.000000
ITER 8: row=2, varin=52, theta=0.520670, up=999999999999999983222784.000000
ITER 9: row=24, varin=81, theta=1.346663, up=1.000000
ITER 10: row=24, varin=82, theta=0.096099, up=1.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28434417.574709
  % 	x3 = 0,	Z0 = 28434417.5747092        
DEBUG EVAL: First branch cutoff check: z=28434417.574709, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=22, varin=24, theta=6.810446, up=999999999999999983222784.000000
ITER 2: row=24, varin=39, theta=1.151465, up=999999999999999983222784.000000
ITER 3: row=43, varin=46, theta=2.967332, up=999999999999999983222784.000000
ITER 4: row=23, varin=44, theta=3.147453, up=999999999999999983222784.000000
ITER 5: row=44, varin=18, theta=1.617635, up=999999999999999983222784.000000
ITER 6: row=11, varin=47, theta=4.439159, up=999999999999999983222784.000000
ITER 7: row=1, varin=40, theta=1.152728, up=999999999999999983222784.000000
ITER 8: row=49, varin=60, theta=0.926622, up=1.000000
ITER 9: row=43, varin=83, theta=0.537241, up=1.000000
ITER 10: row=47, varin=7, theta=0.150764, up=999999999999999983222784.000000
  % 	x3 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=42, theta=0.294577, up=999999999999999983222784.000000
ITER 2: row=38, varin=55, theta=11.356215, up=999999999999999983222784.000000
ITER 3: row=55, varin=95, theta=1.618172, up=1.000000
ITER 4: row=55, varin=108, theta=0.250546, up=1.000000
ITER 5: row=49, varin=54, theta=0.318640, up=999999999999999983222784.000000
ITER 6: row=54, varin=24, theta=0.507926, up=999999999999999983222784.000000
ITER 7: row=24, varin=95, theta=0.652171, up=1.000000
ITER 8: row=2, varin=52, theta=0.520670, up=999999999999999983222784.000000
ITER 9: row=24, varin=81, theta=1.346663, up=1.000000
ITER 10: row=24, varin=82, theta=0.096099, up=1.000000
LP PHASE: Switching to primal (iter=13)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28434417.574709
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 308 nonzeros, 1 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=41, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28447030.453752
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 60 rows, 60 cols, 288 nonzeros, 7 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 7 slack rows
   % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=78, theta=1.349798, up=1.000000
ITER 2: row=54, varin=77, theta=0.130877, up=1.000000
ITER 3: row=24, varin=78, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28485910.671419
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 302 nonzeros, 0 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=85, theta=0.280008, up=1.000000
ITER 2: row=48, varin=84, theta=0.279030, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28498473.959103
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 306 nonzeros, 0 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=79, theta=0.042165, up=1.000000
ITER 2: row=49, varin=83, theta=0.046086, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28500338.775042
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 308 nonzeros, 1 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=89, theta=0.048854, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28502923.574617
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 308 nonzeros, 0 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 7 at  28.50292357461651349126
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6046ac0
% @LO 0.02  28.33017992728729694818 99.9000000000
% @LN 0.02  28.33048815459173752629 99.9000000000
% Resuming node 25 at  28.33048815459173752629
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=56, expected 56
 % @PAP adding 49 rows, 214 nz to LP
DEBUG BB: Processing node 25, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=45, theta=2.042424, up=999999999999999983222784.000000
ITER 4: row=30, varin=42, theta=0.056652, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28330488.154592
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 274 nonzeros, 5 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=57, theta=0.705637, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28344124.461627
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 278 nonzeros, 4 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 6 rows, 23 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=63, theta=0.168583, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28346307.641364
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 291 nonzeros, 4 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 25 LP 1 Solution, length = 28346307.641364, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.325670 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.325670 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.831417 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.325670 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.168583 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.168583 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.674330 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.831417 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.831417 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.674330 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.674330 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.674330 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.674330 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.168583 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.168583 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.831417 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.674330 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.168583 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28346307.641364, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 25 at  28.34630764136404579290
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60410f0
% @LO 0.02  28.33048815459173752629 99.9000000000
% @LN 0.02  28.33715061201512952493 99.9000000000
% Resuming node 13 at  28.33715061201512952493
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=47, expected 47
 % @PAP adding 54 rows, 236 nz to LP
DEBUG BB: Processing node 13, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 13 LP 4 Solution, length = 28337150.612015, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.133575 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.049638 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.133575 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.049638 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.133575 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.049638 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.866425 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.866425 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.866425 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.866425 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.950362 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.950362 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28337150.612015, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28337150.612015, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 13 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 13
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.133575
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.133575)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.049638
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.049638)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.133575
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.133575)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.049638
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.049638)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.133575
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.133575)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.049638
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.049638)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.500000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[3] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[4] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[5] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[7] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
  % Initial guess is x22, Z0 = 28337150.6120151        , Z1 = 28536126.0078311        

DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=43, varin=53, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28363393.220487
  % 	x26 = 0,	Z0 = 28363393.2204874        
DEBUG EVAL: First branch cutoff check: z=28363393.220487, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=43, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=45, varin=32, theta=1.000000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 29481427.1580439        
DEBUG EVAL: Second branch cutoff check: z=29481427.158044, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28363393.2204874        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=53, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28363393.220487
  % 	x10 = 0,	Z0 = 28363393.2204874        
DEBUG EVAL: First branch cutoff check: z=28363393.220487, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=24, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=26, theta=0.151374, up=999999999999999983222784.000000
ITER 3: row=40, varin=82, theta=3.104410, up=1.000000
ITER 4: row=40, varin=20, theta=0.152704, up=999999999999999983222784.000000
ITER 5: row=12, varin=7, theta=0.066797, up=999999999999999983222784.000000
ITER 6: row=1, varin=42, theta=0.095444, up=999999999999999983222784.000000
ITER 7: row=26, varin=46, theta=0.183188, up=999999999999999983222784.000000
ITER 8: row=46, varin=8, theta=0.142155, up=999999999999999983222784.000000
ITER 9: row=8, varin=6, theta=0.149374, up=999999999999999983222784.000000
ITER 10: row=6, varin=19, theta=0.094389, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=24, varin=53, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28363393.220487
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 296 nonzeros, 1 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=67, theta=0.778481, up=1.000000
ITER 2: row=55, varin=41, theta=6.155106, up=999999999999999983222784.000000
ITER 3: row=40, varin=47, theta=0.342957, up=999999999999999983222784.000000
ITER 4: row=48, varin=51, theta=0.112945, up=999999999999999983222784.000000
ITER 5: row=39, varin=55, theta=0.269399, up=999999999999999983222784.000000
ITER 6: row=23, varin=48, theta=0.110936, up=999999999999999983222784.000000
ITER 7: row=37, varin=26, theta=0.157241, up=999999999999999983222784.000000
ITER 8: row=26, varin=39, theta=0.561339, up=999999999999999983222784.000000
ITER 9: row=54, varin=32, theta=0.175710, up=999999999999999983222784.000000
ITER 10: row=26, varin=62, theta=0.138402, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28435028.614244
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 306 nonzeros, 8 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 8 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=37, theta=4.823760, up=999999999999999983222784.000000
ITER 2: row=47, varin=72, theta=0.652962, up=1.000000
ITER 3: row=26, varin=60, theta=0.286466, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28450704.828312
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 48 rows, 60 cols, 276 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=58, theta=0.301589, up=1.000000
ITER 2: row=49, varin=113, theta=0.053968, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28466092.859040
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 299 nonzeros, 2 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=77, theta=0.276784, up=1.000000
ITER 2: row=42, varin=78, theta=0.279967, up=1.000000
ITER 3: row=53, varin=49, theta=0.307916, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28483764.932501
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 294 nonzeros, 1 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=52, theta=0.543218, up=999999999999999983222784.000000
ITER 2: row=38, varin=85, theta=0.033877, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28488716.577174
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 288 nonzeros, 1 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 4 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=85, theta=0.018388, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28489358.207277
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 59 rows, 60 cols, 302 nonzeros, 0 slack, 59 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 13 at  28.48935820727723111645
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6041ff0
% @LO 0.04  28.33715061201512952493 99.9000000000
% @LN 0.04  28.33848814811905825195 99.9000000000
% Resuming node 11 at  28.33848814811905825195
DEBUG CONSTRNT: LP rows=59, pool->nlprows=59, pool->npend=0
DEBUG CONSTRNT: Checking 59 LP rows (pool tracks 59, total LP rows 59)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=58, expected 58
 % @PAP adding 54 rows, 188 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 11 LP 2 Solution, length = 28338488.148119, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.200000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.200000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.200000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.200000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.200000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.200000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.200000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.800000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.800000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.800000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.800000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.800000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.800000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.800000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28338488.148119, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28338488.148119, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 11 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 11
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.200000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.200000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.200000
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.200000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.200000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.200000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.200000
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[5] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[6] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 37
  % Initial guess is x4, Z0 = 28338488.1481191        , Z1 = 28596437.0375231        

DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=76, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28361059.155101
  % 	x10 = 0,	Z0 = 28361059.1551012        
DEBUG EVAL: First branch cutoff check: z=28361059.155101, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=24, varin=53, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28374884.2609915        
DEBUG EVAL: Second branch cutoff check: z=28374884.260991, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28361059.1551012        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=76, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28361059.155101
  % 	x2 = 0,	Z0 = 28361059.1551012        
DEBUG EVAL: First branch cutoff check: z=28361059.155101, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=51, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=48, theta=0.750000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28536374.2269721        
DEBUG EVAL: Second branch cutoff check: z=28536374.226972, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28361059.1551012        
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=43, varin=76, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28361059.155101
  % 	x26 = 0,	Z0 = 28361059.1551012        
DEBUG EVAL: First branch cutoff check: z=28361059.155101, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=43, varin=53, theta=1.000000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 28374884.2609915        
DEBUG EVAL: Second branch cutoff check: z=28374884.260991, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=76, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28361059.155101
  % 	x3 = 0,	Z0 = 28361059.1551012        
DEBUG EVAL: First branch cutoff check: z=28361059.155101, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=25, varin=51, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=27, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=27, varin=46, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=54, varin=47, theta=0.750000, up=999999999999999983222784.000000
  % 	x3 = 1,	Z1 = 28818780.3943924        
DEBUG EVAL: Second branch cutoff check: z=28818780.394392, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28361059.1551012        
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=51, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=49, varin=27, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=27, varin=48, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28814678.682305
  % 	x4 = 1,	Z1 = 28814678.6823048        
DEBUG EVAL: First branch cutoff check: z=28814678.682305, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=38, varin=76, theta=1.000000, up=1.000000
  % 	x4 = 0,	Z0 = 28361059.1551012        
DEBUG EVAL: Second branch cutoff check: z=28361059.155101, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=46, varin=51, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=50, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=54, varin=53, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28533178.944073
  % 	x11 = 1,	Z1 = 28548001.7809018        
DEBUG EVAL: First branch cutoff check: z=28548001.780902, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=46, varin=76, theta=1.000000, up=1.000000
  % 	x11 = 0,	Z0 = 28361059.1551012        
DEBUG EVAL: Second branch cutoff check: z=28361059.155101, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 37 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=47, varin=51, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 37 = 0 gives z=28343794.434257
  % 	x37 = 0,	Z0 = 28343794.4342573        
DEBUG EVAL: First branch cutoff check: z=28343794.434257, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28361059.1551012        , Z1 = 28818780.3943924        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   29   11	x3 = 0	28361059.155101
 % @NC   30   11	x3 = 1	28818780.394392
 %      11    14 28338488.1481               28340198.5145    x7 D     5     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6040360
% @LO 0.04  28.33848814811905825195 99.9000000000
% @LN 0.04  28.34019851449349403083 99.9000000000
% Resuming node 27 at  28.34019851449349403083
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=53, expected 53
 % @PAP adding 54 rows, 228 nz to LP
DEBUG BB: Processing node 27, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=50, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=25, varin=58, theta=0.516091, up=1.000000
ITER 4: row=42, varin=49, theta=0.037630, up=999999999999999983222784.000000
ITER 5: row=44, varin=81, theta=0.104023, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28340198.514493
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 288 nonzeros, 5 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 10 rows, 48 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=82, theta=0.132456, up=1.000000
ITER 2: row=64, varin=89, theta=1.694781, up=1.000000
ITER 3: row=64, varin=31, theta=0.032222, up=999999999999999983222784.000000
ITER 4: row=3, varin=89, theta=1.000000, up=1.000000
ITER 5: row=59, varin=99, theta=2.718543, up=1.000000
ITER 6: row=59, varin=86, theta=0.263423, up=1.000000
ITER 7: row=56, varin=99, theta=0.311111, up=1.000000
ITER 8: row=35, varin=88, theta=1.056394, up=1.000000
ITER 9: row=35, varin=87, theta=0.020936, up=1.000000
ITER 10: row=26, varin=88, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=14)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=64)
DEBUG SOLUTION: LP solution array indices: FST[65-104], not_covered[105-124]
DEBUG SOLUTION: lp->best_solution[0] = 28528461.083829
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 64 rows, 60 cols, 336 nonzeros, 6 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 3 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=42, theta=0.126769, up=999999999999999983222784.000000
ITER 2: row=52, varin=49, theta=0.205049, up=999999999999999983222784.000000
ITER 3: row=61, varin=41, theta=0.028452, up=999999999999999983222784.000000
ITER 4: row=45, varin=44, theta=0.116252, up=999999999999999983222784.000000
ITER 5: row=51, varin=115, theta=0.322697, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28602928.365303
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 61 rows, 60 cols, 340 nonzeros, 10 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 10 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=61, theta=0.541572, up=1.000000
ITER 2: row=54, varin=41, theta=2.700332, up=999999999999999983222784.000000
ITER 3: row=50, varin=86, theta=0.878936, up=1.000000
ITER 4: row=9, varin=100, theta=0.865326, up=1.000000
ITER 5: row=17, varin=87, theta=0.887723, up=1.000000
ITER 6: row=51, varin=88, theta=1.059892, up=1.000000
ITER 7: row=51, varin=39, theta=0.013029, up=999999999999999983222784.000000
ITER 8: row=10, varin=88, theta=1.000000, up=1.000000
ITER 9: row=39, varin=38, theta=0.153799, up=999999999999999983222784.000000
ITER 10: row=53, varin=50, theta=0.535714, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 326 nonzeros, 3 slack, 52 tight.
  % Node 27 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.322697 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.046100 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.046100 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.295256 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.322697 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.935424 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.953900 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.677303 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.944649 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.994878 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 27 is INFEASIBLE
 %      27    13    infeasible               28346307.6414   x16 U    23     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6046ac0
% @LO 0.04  28.34019851449349403083 99.9000000000
% @LN 0.04  28.34630764136404579290 99.9000000000
% Resuming node 25 at  28.34630764136404579290
DEBUG CONSTRNT: LP rows=55, pool->nlprows=55, pool->npend=0
DEBUG CONSTRNT: Checking 55 LP rows (pool tracks 55, total LP rows 55)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=54, expected 54
 % @PAP adding 48 rows, 206 nz to LP
DEBUG BB: Processing node 25, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 25 LP 2 Solution, length = 28346307.641364, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.325670 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.325670 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.831417 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.325670 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.168583 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.168583 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.674330 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.831417 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.831417 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.674330 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.674330 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.674330 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.674330 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.168583 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.168583 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.831417 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.674330 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.168583 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28346307.641364, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28346307.641364, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 25 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 25
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.325670
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.325670)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.325670
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.325670)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.831417
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.831417)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.325670
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.325670)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.168583
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.168583)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.168583
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.168583)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[3] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 6
DEBUG CAREFUL: New best var: 6
DEBUG CAREFUL: Testing fvar[4] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[5] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
  % Initial guess is x18, Z0 = 28346307.641364         , Z1 = 28489834.9614771        

DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=49, theta=0.378050, up=1.000000
ITER 2: row=6, varin=85, theta=0.642320, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28375091.717673
  % 	x10 = 1,	Z1 = 28375091.7176732        
DEBUG EVAL: First branch cutoff check: z=28375091.717673, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=20, varin=46, theta=1.451742, up=999999999999999983222784.000000
ITER 2: row=30, varin=45, theta=0.772810, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28386994.4718925        
DEBUG EVAL: Second branch cutoff check: z=28386994.471893, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28375091.7176732        
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=45, theta=0.940476, up=999999999999999983222784.000000
ITER 2: row=41, varin=46, theta=0.589859, up=999999999999999983222784.000000
ITER 3: row=20, varin=41, theta=0.104952, up=999999999999999983222784.000000
ITER 4: row=37, varin=40, theta=0.164363, up=999999999999999983222784.000000
ITER 5: row=40, varin=34, theta=0.240145, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28426284.912993
  % 	x5 = 1,	Z1 = 28426284.9129927        
DEBUG EVAL: First branch cutoff check: z=28426284.912993, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=1, varin=46, theta=1.119858, up=999999999999999983222784.000000
ITER 2: row=30, varin=38, theta=0.435617, up=999999999999999983222784.000000
  % 	x5 = 0,	Z0 = 28360854.8617582        
DEBUG EVAL: Second branch cutoff check: z=28360854.861758, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=46, theta=1.119858, up=999999999999999983222784.000000
ITER 2: row=30, varin=21, theta=0.875607, up=999999999999999983222784.000000
ITER 3: row=21, varin=7, theta=0.885828, up=999999999999999983222784.000000
ITER 4: row=7, varin=30, theta=312339.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28379910.824063
  % 	x14 = 0,	Z0 = 28379910.8240632        
DEBUG EVAL: First branch cutoff check: z=28379910.824063, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=33, varin=38, theta=1.241385, up=999999999999999983222784.000000
ITER 2: row=1, varin=45, theta=0.182874, up=999999999999999983222784.000000
ITER 3: row=41, varin=46, theta=0.114697, up=999999999999999983222784.000000
  % 	x14 = 1,	Z1 = 28383712.8230338        
DEBUG EVAL: Second branch cutoff check: z=28383712.823034, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28379910.8240632        
DEBUG EVAL: Testing var 6 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=38, theta=1.241385, up=999999999999999983222784.000000
ITER 2: row=1, varin=45, theta=0.182874, up=999999999999999983222784.000000
ITER 3: row=41, varin=21, theta=0.123458, up=999999999999999983222784.000000
ITER 4: row=21, varin=7, theta=0.122961, up=999999999999999983222784.000000
ITER 5: row=7, varin=41, theta=0.040157, up=999999999999999983222784.000000
ITER 6: row=37, varin=40, theta=0.074155, up=999999999999999983222784.000000
ITER 7: row=44, varin=42, theta=0.060554, up=999999999999999983222784.000000
ITER 8: row=40, varin=34, theta=0.306524, up=999999999999999983222784.000000
ITER 9: row=47, varin=33, theta=0.158946, up=999999999999999983222784.000000
ITER 10: row=48, varin=35, theta=0.107291, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 6 = 1 gives z=28429771.787139
  % 	x6 = 1,	Z1 = 28466032.5124357        
DEBUG EVAL: First branch cutoff check: z=28466032.512436, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 6 = 0
ITER 1: row=30, varin=46, theta=0.252298, up=999999999999999983222784.000000
  % 	x6 = 0,	Z0 = 28348178.8445111        
DEBUG EVAL: Second branch cutoff check: z=28348178.844511, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=46, theta=1.451742, up=999999999999999983222784.000000
ITER 2: row=30, varin=21, theta=1.605098, up=999999999999999983222784.000000
ITER 3: row=21, varin=7, theta=1.601987, up=999999999999999983222784.000000
ITER 4: row=7, varin=43, theta=1.341130, up=999999999999999983222784.000000
ITER 5: row=41, varin=38, theta=1.660794, up=999999999999999983222784.000000
ITER 6: row=1, varin=41, theta=0.180742, up=999999999999999983222784.000000
ITER 7: row=37, varin=5, theta=2.517338, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28556685.419869
  % 	x18 = 1,	Z1 = 28556685.4198693        
DEBUG EVAL: First branch cutoff check: z=28556685.419869, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=40, varin=49, theta=0.378050, up=1.000000
ITER 2: row=6, varin=45, theta=0.392735, up=999999999999999983222784.000000
  % 	x18 = 0,	Z0 = 28364415.44966          
DEBUG EVAL: Second branch cutoff check: z=28364415.449660, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=46, theta=1.451742, up=999999999999999983222784.000000
ITER 2: row=30, varin=21, theta=1.605098, up=999999999999999983222784.000000
ITER 3: row=21, varin=7, theta=1.601987, up=999999999999999983222784.000000
ITER 4: row=7, varin=40, theta=1.016378, up=999999999999999983222784.000000
ITER 5: row=44, varin=38, theta=6.529308, up=999999999999999983222784.000000
ITER 6: row=1, varin=42, theta=0.837999, up=999999999999999983222784.000000
ITER 7: row=33, varin=45, theta=0.371891, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28571159.276289
  % 	x17 = 1,	Z1 = 28571159.2762894        
DEBUG EVAL: First branch cutoff check: z=28571159.276289, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=37, varin=49, theta=0.378050, up=1.000000
ITER 2: row=6, varin=45, theta=0.392735, up=999999999999999983222784.000000
  % 	x17 = 0,	Z0 = 28364415.44966          
DEBUG EVAL: Second branch cutoff check: z=28364415.449660, best_z=INF, threshold=INF
  % Best branch is x14, Z0 = 28379910.8240632        , Z1 = 28383712.8230338        

DEBUG CAREFUL: Final result - returning best.var = 14
DEBUG BB: Branching variable chosen: j=14
 % @NC   31   25	x14 = 0	28379910.824063
 % @NC   32   25	x14 = 1	28383712.823034
 %      25    14 28346307.6414               28353988.0620    x7 D    19     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6049c70
% @LO 0.04  28.34630764136404579290 99.9000000000
% @LN 0.04  28.35398806199393462180 99.9000000000
% Resuming node 17 at  28.35398806199393462180
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=47, expected 47
 % @PAP adding 65 rows, 264 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 17 LP 2 Solution, length = 28353988.061994, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.087937 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.074921 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.074921 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.074921 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.074921 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.074921 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.074921 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.074921 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.074921 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.087937 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.087937 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.925079 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.912063 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.925079 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.912063 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.925079 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.925079 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.925079 (terminal 19)
 % 11 fractional variables
DEBUG CG: LP optimal, z=28353988.061994, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28353988.061994, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 17 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 17
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.087937
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.087937)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.074921
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.074921)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.074921
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.074921)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.074921
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.074921)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.074921
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.074921)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.074921
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.074921)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.074921
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.074921)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.074921
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.074921)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.074921
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.074921)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.087937
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.087937)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.087937
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.087937)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 11 fractional variables

  %  Carefully choosing branching variable, nfrac = 11
DEBUG CAREFUL: Testing fvar[0] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 31
DEBUG CAREFUL: New best var: 31
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[6] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[7] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[8] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[9] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[10] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x4, Z0 = 28353988.0619939        , Z1 = 28883622.9451399        

DEBUG EVAL: Testing var 31 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=62, varin=10, theta=1.202660, up=999999999999999983222784.000000
ITER 2: row=10, varin=9, theta=3.386540, up=999999999999999983222784.000000
ITER 3: row=9, varin=17, theta=2.827316, up=999999999999999983222784.000000
ITER 4: row=1, varin=63, theta=3.863908, up=999999999999999983222784.000000
ITER 5: row=27, varin=4, theta=1.369839, up=999999999999999983222784.000000
ITER 6: row=4, varin=23, theta=1.659114, up=999999999999999983222784.000000
ITER 7: row=23, varin=60, theta=2.135224, up=999999999999999983222784.000000
ITER 8: row=47, varin=20, theta=1.257633, up=999999999999999983222784.000000
ITER 9: row=9, varin=49, theta=0.576025, up=999999999999999983222784.000000
ITER 10: row=42, varin=14, theta=0.481061, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x31 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=62, varin=103, theta=0.491447, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=65)
DEBUG SOLUTION: LP solution array indices: FST[66-105], not_covered[106-125]
DEBUG SOLUTION: lp->best_solution[0] = 28375743.382351
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 65 rows, 60 cols, 324 nonzeros, 0 slack, 65 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 10 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=72, varin=14, theta=0.143297, up=999999999999999983222784.000000
ITER 2: row=71, varin=65, theta=0.024856, up=999999999999999983222784.000000
ITER 3: row=14, varin=126, theta=0.037986, up=1.000000
ITER 4: row=18, varin=105, theta=0.078938, up=1.000000
ITER 5: row=66, varin=71, theta=0.138419, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=75)
DEBUG SOLUTION: LP solution array indices: FST[76-115], not_covered[116-135]
DEBUG SOLUTION: lp->best_solution[0] = 28478540.955389
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.979991
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 75 rows, 60 cols, 364 nonzeros, 5 slack, 70 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=71, varin=17, theta=0.111258, up=999999999999999983222784.000000
ITER 2: row=13, varin=22, theta=0.054942, up=999999999999999983222784.000000
ITER 3: row=72, varin=112, theta=0.308410, up=1.000000
ITER 4: row=23, varin=72, theta=0.039875, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=73)
DEBUG SOLUTION: LP solution array indices: FST[74-113], not_covered[114-133]
DEBUG SOLUTION: lp->best_solution[0] = 28576728.155507
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 73 rows, 60 cols, 342 nonzeros, 2 slack, 71 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 4 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=72, varin=115, theta=0.931758, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=75)
DEBUG SOLUTION: LP solution array indices: FST[76-115], not_covered[116-135]
DEBUG SOLUTION: lp->best_solution[0] = 28825373.453387
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 75 rows, 60 cols, 358 nonzeros, 2 slack, 73 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 4 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=74, varin=40, theta=0.551917, up=999999999999999983222784.000000
ITER 2: row=61, varin=3, theta=2.534404, up=999999999999999983222784.000000
ITER 3: row=77, varin=42, theta=1.294874, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=77)
DEBUG SOLUTION: LP solution array indices: FST[78-117], not_covered[118-137]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 77 rows, 60 cols, 361 nonzeros, 6 slack, 71 tight.
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 17 at 1000000000000000000.00000000000000000000
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6055740
% @LO 0.04  28.35398806199393462180 99.9000000000
% @LN 0.04  28.36105915510123054446 99.9000000000
% Resuming node 29 at  28.36105915510123054446
DEBUG CONSTRNT: LP rows=77, pool->nlprows=77, pool->npend=0
DEBUG CONSTRNT: Checking 77 LP rows (pool tracks 77, total LP rows 77)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=64, expected 64
DEBUG CONSTRNT: Checking LP row 65 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=65, expected 65
DEBUG CONSTRNT: Checking LP row 66 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=66, expected 66
DEBUG CONSTRNT: Checking LP row 67 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=67, expected 67
DEBUG CONSTRNT: Checking LP row 68 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=68, expected 68
DEBUG CONSTRNT: Checking LP row 69 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=69, expected 69
DEBUG CONSTRNT: Checking LP row 70 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=70, expected 70
DEBUG CONSTRNT: Checking LP row 71 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=71, expected 71
DEBUG CONSTRNT: Checking LP row 72 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=72, expected 72
DEBUG CONSTRNT: Checking LP row 73 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=73, expected 73
DEBUG CONSTRNT: Checking LP row 74 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=74, expected 74
DEBUG CONSTRNT: Checking LP row 75 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=75, expected 75
DEBUG CONSTRNT: Checking LP row 76 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=76, expected 76
 % @PAP adding 54 rows, 188 nz to LP
DEBUG BB: Processing node 29, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=76, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28361059.155101
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 248 nonzeros, 0 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=106, theta=0.625000, up=1.000000
ITER 2: row=12, varin=53, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28374884.260991
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 252 nonzeros, 2 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 46 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=82, theta=0.327449, up=1.000000
ITER 2: row=54, varin=56, theta=120611.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28382390.006204
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 294 nonzeros, 1 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=79, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28390873.175666
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 259 nonzeros, 0 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=89, theta=0.500000, up=1.000000
ITER 2: row=34, varin=88, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28411409.381539
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 60 rows, 60 cols, 278 nonzeros, 0 slack, 60 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=61, varin=38, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=49, varin=50, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 28425220.973820
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 62 rows, 60 cols, 284 nonzeros, 3 slack, 59 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 52 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=62, varin=96, theta=0.463839, up=1.000000
ITER 2: row=4, varin=92, theta=0.244043, up=1.000000
ITER 3: row=14, varin=17, theta=0.208777, up=999999999999999983222784.000000
ITER 4: row=24, varin=93, theta=0.144146, up=1.000000
ITER 5: row=9, varin=79, theta=0.051796, up=1.000000
ITER 6: row=33, varin=94, theta=0.026369, up=1.000000
ITER 7: row=61, varin=95, theta=0.027931, up=1.000000
ITER 8: row=59, varin=48, theta=0.003532, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 28446299.174557
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.888245
DEBUG SOLUTION: lp->best_solution[11] = 3.888245
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 62 rows, 60 cols, 324 nonzeros, 6 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 5 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=73, theta=0.107336, up=1.000000
ITER 2: row=59, varin=55, theta=0.480312, up=999999999999999983222784.000000
ITER 3: row=60, varin=49, theta=0.045126, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28452919.945385
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 61 rows, 60 cols, 324 nonzeros, 4 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=52, theta=0.112618, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28457952.208398
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 307 nonzeros, 1 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 29 LP 1 Solution, length = 28457952.208398, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.112618 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.112618 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.436912 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.112618 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.112618 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.436912 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.112618 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.112618 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.436912 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.887382 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.887382 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.563088 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.887382 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.563088 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.887382 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.563088 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28457952.208398, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 29 at  28.45795220839753625341
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6040360
% @LO 0.04  28.36105915510123054446 99.9000000000
% @LN 0.04  28.37991082406322718157 99.9000000000
% Resuming node 31 at  28.37991082406322718157
DEBUG CONSTRNT: LP rows=58, pool->nlprows=58, pool->npend=0
DEBUG CONSTRNT: Checking 58 LP rows (pool tracks 58, total LP rows 58)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=57, expected 57
 % @PAP adding 48 rows, 206 nz to LP
DEBUG BB: Processing node 31, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=46, theta=1.119858, up=999999999999999983222784.000000
ITER 2: row=30, varin=21, theta=0.875607, up=999999999999999983222784.000000
ITER 3: row=21, varin=7, theta=0.885828, up=999999999999999983222784.000000
ITER 4: row=7, varin=30, theta=312339.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28379910.824063
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 266 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 31 LP 1 Solution, length = 28379910.824063, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.750000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.250000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.250000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.250000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.250000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.250000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28379910.824063, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28379910.824063, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 31 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 31
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.750000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.750000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.250000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.250000
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
  % Initial guess is x17, Z0 = 28379910.8240632        , Z1 = 28571159.2762894        

DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=50, theta=0.500000, up=1.000000
ITER 2: row=7, varin=51, theta=0.500000, up=1.000000
ITER 3: row=21, varin=55, theta=0.500000, up=1.000000
ITER 4: row=46, varin=49, theta=0.600000, up=1.000000
ITER 5: row=6, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=30, varin=85, theta=0.132094, up=1.000000
ITER 7: row=44, varin=30, theta=360135.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28429865.614058
  % 	x10 = 1,	Z1 = 28429865.6140576        
DEBUG EVAL: First branch cutoff check: z=28429865.614058, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=1, varin=43, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=20, varin=45, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28500000                
DEBUG EVAL: Second branch cutoff check: z=28500000.000000, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28429865.6140576        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=43, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=20, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=30, varin=5, theta=2.619907, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28573601.404770
  % 	x18 = 1,	Z1 = 28573601.4047703        
DEBUG EVAL: First branch cutoff check: z=28573601.404770, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=40, varin=50, theta=0.500000, up=1.000000
ITER 2: row=7, varin=51, theta=0.500000, up=1.000000
ITER 3: row=21, varin=55, theta=0.500000, up=1.000000
ITER 4: row=46, varin=49, theta=0.600000, up=1.000000
ITER 5: row=6, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=30, varin=85, theta=0.132094, up=1.000000
ITER 7: row=44, varin=30, theta=360135.000000, up=999999999999999983222784.000000
  % 	x18 = 0,	Z0 = 28429865.6140576        
DEBUG EVAL: Second branch cutoff check: z=28429865.614058, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28429865.6140576        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=30, varin=38, theta=0.105211, up=999999999999999983222784.000000
ITER 3: row=44, varin=42, theta=0.750000, up=999999999999999983222784.000000
ITER 4: row=38, varin=45, theta=0.371891, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28571159.276289
  % 	x17 = 1,	Z1 = 28571159.2762894        
DEBUG EVAL: First branch cutoff check: z=28571159.276289, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=20, varin=50, theta=0.500000, up=1.000000
ITER 2: row=7, varin=51, theta=0.500000, up=1.000000
ITER 3: row=21, varin=55, theta=0.500000, up=1.000000
ITER 4: row=46, varin=49, theta=0.600000, up=1.000000
ITER 5: row=6, varin=43, theta=0.500000, up=999999999999999983222784.000000
  % 	x17 = 0,	Z0 = 28418956.1330468        
DEBUG EVAL: Second branch cutoff check: z=28418956.133047, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28429865.6140576        , Z1 = 28573601.4047703        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC   33   31	x18 = 0	28429865.614058
 % @NC   34   31	x18 = 1	28573601.404770
 %      31    15 28379910.8241               28383712.8230   x14 D    25     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6041ff0
% @LO 0.04  28.37991082406322718157 99.9000000000
% @LN 0.04  28.38371282303383225099 99.9000000000
% Resuming node 32 at  28.38371282303383225099
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=47, expected 47
 % @PAP adding 48 rows, 206 nz to LP
DEBUG BB: Processing node 32, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=38, theta=1.241385, up=999999999999999983222784.000000
ITER 2: row=1, varin=45, theta=0.182874, up=999999999999999983222784.000000
ITER 3: row=41, varin=46, theta=0.114697, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28383712.823034
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 266 nonzeros, 5 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=47, theta=0.938871, up=1.000000
ITER 2: row=6, varin=90, theta=0.352883, up=1.000000
LP PHASE: Switching to primal (iter=2)
ITER 3: row=3, varin=6, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28406834.510224
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 271 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=3, theta=0.107195, up=999999999999999983222784.000000
ITER 2: row=6, varin=55, theta=0.250992, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28427711.447001
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 293 nonzeros, 2 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=89, theta=0.004810, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28427729.077019
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 283 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=101, theta=0.001743, up=1.000000
ITER 2: row=16, varin=91, theta=0.004498, up=1.000000
ITER 3: row=56, varin=62, theta=0.000822, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28427834.685488
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 302 nonzeros, 1 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=39, theta=0.002210, up=999999999999999983222784.000000
ITER 2: row=43, varin=83, theta=0.003131, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28427996.666222
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 298 nonzeros, 0 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 32 LP 1 Solution, length = 28427996.666222, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.249217 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.249217 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.249217 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.249217 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.003131 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750783 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750783 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750783 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750783 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750783 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750783 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28427996.666222, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 32 at  28.42799666622190102316
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f605a130
% @LO 0.04  28.38371282303383225099 99.9000000000
% @LN 0.04  28.38878618615992266427 99.9000000000
% Resuming node 26 at  28.38878618615992266427
DEBUG CONSTRNT: LP rows=56, pool->nlprows=56, pool->npend=0
DEBUG CONSTRNT: Checking 56 LP rows (pool tracks 56, total LP rows 56)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=55, expected 55
 % @PAP adding 49 rows, 214 nz to LP
DEBUG BB: Processing node 26, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=48, theta=0.128447, up=999999999999999983222784.000000
ITER 4: row=40, varin=47, theta=0.099006, up=999999999999999983222784.000000
ITER 5: row=46, varin=36, theta=0.175492, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28388786.186160
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 274 nonzeros, 4 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=99, theta=0.132567, up=1.000000
ITER 2: row=47, varin=70, theta=0.146051, up=1.000000
ITER 3: row=48, varin=53, theta=0.288128, up=1.000000
ITER 4: row=6, varin=45, theta=0.386697, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28412268.034081
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 291 nonzeros, 5 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 5 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=63, theta=0.018417, up=1.000000
ITER 2: row=48, varin=52, theta=0.386924, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28415976.279230
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 297 nonzeros, 2 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 26 LP 1 Solution, length = 28415976.279230, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.435513 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.064487 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.564487 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.064487 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.064487 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.935513 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.935513 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.435513 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.435513 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.935513 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.935513 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.935513 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.435513 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.935513 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28415976.279230, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 26 at  28.41597627922989843796
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f605a1f0
% @LO 0.04  28.38878618615992266427 99.9000000000
% @LN 0.04  28.38959282876225032055 99.9000000000
% Resuming node 10 at  28.38959282876225032055
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=49, expected 49
 % @PAP adding 62 rows, 255 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 10 LP 2 Solution, length = 28389592.828762, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.169207 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.060144 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.060144 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.060144 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.060144 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.060144 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.060144 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.060144 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.169207 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.169207 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.939856 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.830793 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.939856 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.830793 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.939856 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.939856 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.939856 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28389592.828762, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28389592.828762, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.169207
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.169207)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.060144
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.060144)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.060144
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.060144)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.060144
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.060144)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.060144
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.060144)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.060144
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.060144)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.060144
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.060144)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.060144
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.060144)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.169207
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.169207)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.169207
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.169207)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[6] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[7] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 31
DEBUG CAREFUL: New best var: 31
DEBUG CAREFUL: Testing fvar[8] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[9] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x31, Z0 = 28389592.8287623        , Z1 = 28688776.4048995        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=55, theta=1.156327, up=999999999999999983222784.000000
ITER 2: row=44, varin=43, theta=3.818785, up=999999999999999983222784.000000
ITER 3: row=42, varin=24, theta=1.440050, up=999999999999999983222784.000000
ITER 4: row=58, varin=113, theta=0.474820, up=1.000000
ITER 5: row=23, varin=36, theta=7.556130, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x3 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=56, theta=0.052394, up=999999999999999983222784.000000
ITER 2: row=40, varin=74, theta=0.371328, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 28505672.492250
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 62 rows, 60 cols, 315 nonzeros, 0 slack, 62 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 5 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=64, varin=42, theta=0.043119, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=67)
DEBUG SOLUTION: LP solution array indices: FST[68-107], not_covered[108-127]
DEBUG SOLUTION: lp->best_solution[0] = 28527562.085805
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 67 rows, 60 cols, 339 nonzeros, 5 slack, 62 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 10 at  28.52756208580472829794
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6043950
% @LO 0.04  28.38959282876225032055 99.9000000000
% @LN 0.04  28.41460642331820096729 99.9000000000
% Resuming node 21 at  28.41460642331820096729
DEBUG CONSTRNT: LP rows=62, pool->nlprows=62, pool->npend=0
DEBUG CONSTRNT: Checking 62 LP rows (pool tracks 62, total LP rows 62)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 138
DEBUG CONSTRNT: Pool row 138 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=61, expected 61
 % @PAP adding 49 rows, 180 nz to LP
DEBUG BB: Processing node 21, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 21 LP 4 Solution, length = 28414606.423318, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.500000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28414606.423318, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28414606.423318, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 21 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 21
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.500000
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[2] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x34, Z0 = 28414606.4233182        , Z1 = 28414606.4233182        

DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=22, varin=94, theta=0.400000, up=1.000000
ITER 3: row=17, varin=26, theta=2.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28431184.167300
  % 	x34 = 0,	Z0 = 28431184.1672999        
DEBUG EVAL: First branch cutoff check: z=28431184.167300, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 1
ITER 1: row=40, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=48, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=22, varin=94, theta=0.400000, up=1.000000
ITER 4: row=17, varin=26, theta=2.000000, up=999999999999999983222784.000000
  % 	x34 = 1,	Z1 = 28735627.4235068        
DEBUG EVAL: Second branch cutoff check: z=28735627.423507, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28431184.1672999        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=48, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=22, varin=94, theta=0.400000, up=1.000000
ITER 4: row=17, varin=26, theta=2.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28539735.710416
  % 	x7 = 0,	Z0 = 28539735.7104158        
DEBUG EVAL: First branch cutoff check: z=28539735.710416, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=23, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=22, varin=94, theta=0.400000, up=1.000000
ITER 3: row=17, varin=26, theta=2.000000, up=999999999999999983222784.000000
  % 	x7 = 1,	Z1 = 28431184.1672999        
DEBUG EVAL: Second branch cutoff check: z=28431184.167300, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=45, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=22, varin=94, theta=0.400000, up=1.000000
ITER 3: row=17, varin=26, theta=2.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 0 gives z=28431184.167300
  % 	x36 = 0,	Z0 = 28431184.1672999        
DEBUG EVAL: First branch cutoff check: z=28431184.167300, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 1
ITER 1: row=45, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=48, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=22, varin=94, theta=0.400000, up=1.000000
ITER 4: row=49, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=17, varin=26, theta=2.000000, up=999999999999999983222784.000000
  % 	x36 = 1,	Z1 = 28911574.7932424        
DEBUG EVAL: Second branch cutoff check: z=28911574.793242, best_z=INF, threshold=INF
  %   New best:  x36, Z = 28431184.1672999        
  % Best branch is x36, Z0 = 28431184.1672999        , Z1 = 28911574.7932424        

DEBUG CAREFUL: Final result - returning best.var = 36
DEBUG BB: Branching variable chosen: j=36
 % @NC   35   21	x36 = 0	28431184.167300
 % @NC   36   21	x36 = 1	28911574.793242
 %      21    16 28414606.4233               28415976.2792    x5 D    16     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f605a130
% @LO 0.04  28.41460642331820096729 99.9000000000
% @LN 0.04  28.41597627922989843796 99.9000000000
% Resuming node 26 at  28.41597627922989843796
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=48, expected 48
 % @PAP adding 50 rows, 221 nz to LP
DEBUG BB: Processing node 26, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 26 LP 2 Solution, length = 28415976.279230, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.435513 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.064487 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.564487 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.064487 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.064487 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.935513 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.935513 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.435513 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.435513 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.935513 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.935513 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.935513 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.435513 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.935513 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28415976.279230, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28415976.279230, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 26 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 26
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.435513
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.435513)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.064487
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.064487)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.564487
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.564487)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.064487
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.064487)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.064487
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.064487)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 6
DEBUG CAREFUL: New best var: 6
DEBUG CAREFUL: Testing fvar[1] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
  % Initial guess is x10, Z0 = 28415976.2792299        , Z1 = 28506800.580633         

DEBUG EVAL: Testing var 6 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=6, theta=0.926119, up=999999999999999983222784.000000
ITER 2: row=6, varin=48, theta=0.847351, up=999999999999999983222784.000000
ITER 3: row=41, varin=21, theta=0.206106, up=999999999999999983222784.000000
ITER 4: row=21, varin=7, theta=0.205276, up=999999999999999983222784.000000
ITER 5: row=7, varin=41, theta=0.067040, up=999999999999999983222784.000000
ITER 6: row=33, varin=40, theta=0.123798, up=999999999999999983222784.000000
ITER 7: row=44, varin=42, theta=0.101091, up=999999999999999983222784.000000
ITER 8: row=40, varin=45, theta=0.511724, up=999999999999999983222784.000000
ITER 9: row=30, varin=39, theta=0.163657, up=999999999999999983222784.000000
ITER 10: row=39, varin=95, theta=0.551145, up=1.000000
DEBUG EVAL: Branch var 6 = 1 gives z=28555568.579276
  % 	x6 = 1,	Z1 = 28555568.5792756        
DEBUG EVAL: First branch cutoff check: z=28555568.579276, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 6 = 0
ITER 1: row=1, varin=54, theta=0.557671, up=1.000000
ITER 2: row=41, varin=40, theta=0.082529, up=999999999999999983222784.000000
ITER 3: row=44, varin=41, theta=0.065296, up=999999999999999983222784.000000
ITER 4: row=33, varin=45, theta=0.226637, up=999999999999999983222784.000000
  % 	x6 = 0,	Z0 = 28448450.6508773        
DEBUG EVAL: Second branch cutoff check: z=28448450.650877, best_z=INF, threshold=INF
  %   New best:  x6, Z = 28448450.6508773        
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=54, theta=0.557671, up=1.000000
ITER 2: row=41, varin=40, theta=0.082529, up=999999999999999983222784.000000
ITER 3: row=44, varin=41, theta=0.065296, up=999999999999999983222784.000000
ITER 4: row=33, varin=42, theta=0.099087, up=999999999999999983222784.000000
ITER 5: row=49, varin=6, theta=1.091233, up=999999999999999983222784.000000
ITER 6: row=6, varin=31, theta=0.123957, up=999999999999999983222784.000000
ITER 7: row=20, varin=77, theta=0.864392, up=1.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28509760.628659
  % 	x14 = 1,	Z1 = 28509760.6286587        
DEBUG EVAL: First branch cutoff check: z=28509760.628659, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=30, varin=6, theta=0.926119, up=999999999999999983222784.000000
ITER 2: row=6, varin=48, theta=0.847351, up=999999999999999983222784.000000
ITER 3: row=41, varin=45, theta=0.191480, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 28461605.740395         
DEBUG EVAL: Second branch cutoff check: z=28461605.740395, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28461605.740395         
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=6, theta=4.179857, up=999999999999999983222784.000000
ITER 2: row=6, varin=43, theta=2.576585, up=999999999999999983222784.000000
ITER 3: row=33, varin=45, theta=2.880546, up=999999999999999983222784.000000
ITER 4: row=30, varin=20, theta=2.563931, up=999999999999999983222784.000000
ITER 5: row=50, varin=31, theta=4.571667, up=999999999999999983222784.000000
ITER 6: row=31, varin=39, theta=4.093483, up=999999999999999983222784.000000
ITER 7: row=39, varin=77, theta=8.812397, up=1.000000
ITER 8: row=39, varin=72, theta=5.616881, up=1.000000
ITER 9: row=39, varin=73, theta=4.850614, up=1.000000
ITER 10: row=39, varin=76, theta=4.818937, up=1.000000
DEBUG EVAL: Branch var 18 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=54, theta=0.294395, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28423915.983578
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 281 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=101, theta=0.174992, up=1.000000
ITER 2: row=16, varin=40, theta=0.114379, up=999999999999999983222784.000000
ITER 3: row=56, varin=91, theta=0.486360, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28431093.367275
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 312 nonzeros, 0 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 1 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=48, theta=0.388060, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28434582.855357
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 318 nonzeros, 3 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=42, theta=0.018249, up=999999999999999983222784.000000
ITER 2: row=44, varin=102, theta=0.034959, up=1.000000
ITER 3: row=17, varin=110, theta=0.208774, up=1.000000
ITER 4: row=51, varin=30, theta=133133.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=1, varin=51, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28443867.387132
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 316 nonzeros, 1 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 26 at  28.44386738713184570315
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6041ff0
% @LO 0.04  28.41597627922989843796 99.9000000000
% @LN 0.04  28.42799666622190102316 99.9000000000
% Resuming node 32 at  28.42799666622190102316
DEBUG CONSTRNT: LP rows=55, pool->nlprows=55, pool->npend=0
DEBUG CONSTRNT: Checking 55 LP rows (pool tracks 55, total LP rows 55)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=54, expected 54
 % @PAP adding 56 rows, 238 nz to LP
DEBUG BB: Processing node 32, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 32 LP 2 Solution, length = 28427996.666222, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.249217 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.249217 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.249217 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.249217 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.003131 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750783 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750783 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750783 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750783 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750783 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750783 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28427996.666222, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28427996.666222, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 32 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 32
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.249217
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.249217)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.249217
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.249217)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.249217
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.249217)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.249217
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.249217)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.003131
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.003131)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x17, Z0 = 28427996.6662219        , Z1 = 28571159.2762894        

DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=43, theta=0.703500, up=999999999999999983222784.000000
ITER 2: row=39, varin=56, theta=1.309185, up=999999999999999983222784.000000
ITER 3: row=51, varin=53, theta=1.691375, up=999999999999999983222784.000000
ITER 4: row=53, varin=16, theta=1.110196, up=999999999999999983222784.000000
ITER 5: row=10, varin=51, theta=0.631453, up=999999999999999983222784.000000
ITER 6: row=7, varin=6, theta=0.225808, up=999999999999999983222784.000000
ITER 7: row=1, varin=47, theta=0.370121, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28545070.672076
  % 	x26 = 1,	Z1 = 28545070.6720757        
DEBUG EVAL: First branch cutoff check: z=28545070.672076, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=41, varin=102, theta=0.000940, up=1.000000
ITER 2: row=17, varin=110, theta=0.004779, up=1.000000
  % 	x26 = 0,	Z0 = 28428112.8467889        
DEBUG EVAL: Second branch cutoff check: z=28428112.846789, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28428112.8467889        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=42, theta=0.877943, up=999999999999999983222784.000000
ITER 2: row=50, varin=56, theta=4.702992, up=999999999999999983222784.000000
ITER 3: row=51, varin=53, theta=5.202182, up=999999999999999983222784.000000
ITER 4: row=53, varin=20, theta=4.025801, up=999999999999999983222784.000000
ITER 5: row=48, varin=41, theta=1.984887, up=999999999999999983222784.000000
ITER 6: row=53, varin=16, theta=6.897219, up=999999999999999983222784.000000
ITER 7: row=10, varin=40, theta=0.920472, up=999999999999999983222784.000000
ITER 8: row=52, varin=38, theta=2.979436, up=999999999999999983222784.000000
ITER 9: row=38, varin=6, theta=3.150022, up=999999999999999983222784.000000
ITER 10: row=41, varin=43, theta=1.142757, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=29393407.001612
  % 	x3 = 1,	Z1 = 29393407.0016118        
DEBUG EVAL: First branch cutoff check: z=29393407.001612, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=7, varin=102, theta=0.426906, up=1.000000
ITER 2: row=41, varin=43, theta=0.291676, up=999999999999999983222784.000000
ITER 3: row=17, varin=83, theta=0.587562, up=1.000000
ITER 4: row=39, varin=55, theta=2.978886, up=999999999999999983222784.000000
ITER 5: row=17, varin=17, theta=0.166539, up=999999999999999983222784.000000
ITER 6: row=10, varin=51, theta=0.084104, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28451787.4501773        
DEBUG EVAL: Second branch cutoff check: z=28451787.450177, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28451787.4501773        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=43, theta=1.897131, up=999999999999999983222784.000000
ITER 2: row=39, varin=56, theta=4.702992, up=999999999999999983222784.000000
ITER 3: row=51, varin=53, theta=5.202182, up=999999999999999983222784.000000
ITER 4: row=53, varin=20, theta=4.025801, up=999999999999999983222784.000000
ITER 5: row=48, varin=16, theta=6.897219, up=999999999999999983222784.000000
ITER 6: row=10, varin=42, theta=1.716465, up=999999999999999983222784.000000
ITER 7: row=50, varin=38, theta=2.979436, up=999999999999999983222784.000000
ITER 8: row=38, varin=51, theta=1.383350, up=999999999999999983222784.000000
ITER 9: row=41, varin=10, theta=2.887388, up=999999999999999983222784.000000
ITER 10: row=48, varin=80, theta=3.643210, up=1.000000
DEBUG EVAL: Branch var 18 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=102, theta=0.426906, up=1.000000
ITER 2: row=41, varin=55, theta=3.443719, up=999999999999999983222784.000000
ITER 3: row=10, varin=43, theta=0.172904, up=999999999999999983222784.000000
ITER 4: row=42, varin=6, theta=0.138319, up=999999999999999983222784.000000
ITER 5: row=1, varin=56, theta=0.300839, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28459830.267583
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 298 nonzeros, 2 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=56, theta=1.061708, up=1.000000
ITER 2: row=55, varin=53, theta=0.019105, up=999999999999999983222784.000000
ITER 3: row=30, varin=56, theta=0.648144, up=1.000000
ITER 4: row=11, varin=90, theta=0.664350, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28464965.468388
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 291 nonzeros, 2 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 32 at  28.46496546838772445653
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6042690
% @LO 0.04  28.42799666622190102316 99.9000000000
% @LN 0.04  28.42861917058075249543 99.9000000000
% Resuming node 22 at  28.42861917058075249543
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=52, expected 52
 % @PAP adding 46 rows, 206 nz to LP
DEBUG BB: Processing node 22, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=44, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=6, varin=42, theta=0.604402, up=999999999999999983222784.000000
ITER 4: row=22, varin=49, theta=0.551842, up=1.000000
ITER 5: row=23, varin=48, theta=0.561567, up=1.000000
ITER 6: row=8, varin=73, theta=0.787642, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28428619.170581
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 266 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 5 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=71, theta=0.654600, up=1.000000
ITER 2: row=49, varin=67, theta=0.129765, up=1.000000
ITER 3: row=48, varin=35, theta=0.014279, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28541969.241021
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 283 nonzeros, 3 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 8 rows, 37 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=77, theta=0.648949, up=1.000000
ITER 2: row=48, varin=80, theta=0.840556, up=1.000000
ITER 3: row=47, varin=58, theta=0.162662, up=1.000000
ITER 4: row=50, varin=78, theta=1.652646, up=1.000000
ITER 5: row=50, varin=18, theta=0.006903, up=999999999999999983222784.000000
ITER 6: row=29, varin=78, theta=1.000000, up=1.000000
ITER 7: row=54, varin=55, theta=0.147966, up=1.000000
ITER 8: row=7, varin=6, theta=0.023648, up=999999999999999983222784.000000
ITER 9: row=52, varin=75, theta=0.015930, up=1.000000
ITER 10: row=42, varin=89, theta=0.252004, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28650999.587809
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 314 nonzeros, 0 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=84, theta=0.853225, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28703613.537015
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 319 nonzeros, 0 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=85, theta=0.842913, up=1.000000
ITER 2: row=24, varin=87, theta=0.901530, up=1.000000
ITER 3: row=14, varin=80, theta=1.049282, up=1.000000
ITER 4: row=14, varin=42, theta=0.019111, up=999999999999999983222784.000000
ITER 5: row=48, varin=64, theta=0.255129, up=1.000000
ITER 6: row=57, varin=47, theta=0.353164, up=999999999999999983222784.000000
ITER 7: row=33, varin=111, theta=0.152923, up=1.000000
ITER 8: row=1, varin=92, theta=2.016850, up=1.000000
ITER 9: row=1, varin=28, theta=0.127940, up=999999999999999983222784.000000
ITER 10: row=14, varin=92, theta=0.118561, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28862807.637061
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.833333
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 327 nonzeros, 8 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=75, theta=1.000000, up=1.000000
ITER 2: row=47, varin=6, theta=0.774604, up=999999999999999983222784.000000
ITER 3: row=51, varin=37, theta=0.989209, up=999999999999999983222784.000000
ITER 4: row=10, varin=87, theta=4.315076, up=1.000000
ITER 5: row=10, varin=56, theta=1.247528, up=1.000000
ITER 6: row=10, varin=97, theta=0.136358, up=1.000000
ITER 7: row=37, varin=83, theta=1.114363, up=1.000000
ITER 8: row=37, varin=77, theta=0.336918, up=1.000000
ITER 9: row=6, varin=87, theta=4.329015, up=1.000000
ITER 10: row=6, varin=56, theta=3.209167, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.833333
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 315 nonzeros, 4 slack, 48 tight.
  % Node 22 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.101098 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 1.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.101098 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.118561 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.988767 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.898902 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.857143 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 22 is INFEASIBLE
 %      22    15    infeasible               28429865.6141    x5 U    16     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6046ac0
% @LO 0.04  28.42861917058075249543 99.9000000000
% @LN 0.04  28.42986561405759360355 99.9000000000
% Resuming node 33 at  28.42986561405759360355
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=51, expected 51
 % @PAP adding 48 rows, 206 nz to LP
DEBUG BB: Processing node 33, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=50, theta=0.500000, up=1.000000
ITER 2: row=7, varin=51, theta=0.500000, up=1.000000
ITER 3: row=21, varin=55, theta=0.500000, up=1.000000
ITER 4: row=46, varin=49, theta=0.600000, up=1.000000
ITER 5: row=6, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=30, varin=85, theta=0.132094, up=1.000000
ITER 7: row=44, varin=30, theta=360135.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28429865.614058
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 266 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=34, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=47, varin=97, theta=0.375000, up=1.000000
ITER 3: row=16, varin=56, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28442189.022602
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 285 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=92, theta=1.000000, up=1.000000
ITER 2: row=51, varin=45, theta=0.166667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28465463.355664
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 276 nonzeros, 3 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=103, theta=0.176471, up=1.000000
ITER 2: row=17, varin=43, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28500000.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 284 nonzeros, 1 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=111, theta=0.500000, up=1.000000
ITER 2: row=51, varin=40, theta=0.055556, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28507395.094202
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 320 nonzeros, 7 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=45, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28511493.981332
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 295 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 33 LP 1 Solution, length = 28511493.981332, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28511493.981332, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 33 at  28.51149398133245682629
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6040360
% @LO 0.04  28.42986561405759360355 99.9000000000
% @LN 0.04  28.43118416729994990533 99.9000000000
% Resuming node 35 at  28.43118416729994990533
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=49, expected 49
 % @PAP adding 49 rows, 180 nz to LP
DEBUG BB: Processing node 35, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=22, varin=94, theta=0.400000, up=1.000000
ITER 3: row=17, varin=26, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28431184.167300
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 240 nonzeros, 6 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 52 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=45, theta=0.221573, up=999999999999999983222784.000000
ITER 2: row=50, varin=98, theta=0.125532, up=1.000000
ITER 3: row=19, varin=79, theta=1.182418, up=1.000000
ITER 4: row=19, varin=64, theta=0.054360, up=1.000000
ITER 5: row=40, varin=52, theta=61887.000000, up=999999999999999983222784.000000
ITER 6: row=51, varin=99, theta=0.006609, up=1.000000
LP PHASE: Switching to primal (iter=6)
ITER 7: row=1, varin=95, theta=0.000000, up=1.000000
ITER 8: row=23, varin=51, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28478114.123451
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 292 nonzeros, 4 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=79, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28478854.366554
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 263 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=65, theta=0.250000, up=1.000000
ITER 2: row=47, varin=56, theta=0.031250, up=1.000000
ITER 3: row=51, varin=64, theta=0.035714, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28492054.243754
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 270 nonzeros, 6 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=56, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28498235.914073
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 263 nonzeros, 2 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=97, theta=0.166667, up=1.000000
ITER 2: row=39, varin=77, theta=1.000000, up=1.000000
ITER 3: row=25, varin=109, theta=0.125000, up=1.000000
ITER 4: row=53, varin=46, theta=0.625000, up=999999999999999983222784.000000
ITER 5: row=52, varin=91, theta=0.500000, up=1.000000
ITER 6: row=53, varin=53, theta=0.071429, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28562280.091456
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 272 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=42, theta=0.576923, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28565977.158641
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.884615
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 280 nonzeros, 6 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=43, theta=0.400000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28568776.859631
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 249 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 35 LP 1 Solution, length = 28568776.859631, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.100000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.100000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.100000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.100000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.100000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.100000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.100000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.900000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.900000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.900000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.900000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.900000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.900000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.900000 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28568776.859631, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 35 at  28.56877685963085156118
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f605a130
% @LO 0.04  28.43118416729994990533 99.9000000000
% @LN 0.04  28.44386738713184570315 99.9000000000
% Resuming node 26 at  28.44386738713184570315
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=49, expected 49
 % @PAP adding 55 rows, 216 nz to LP
DEBUG BB: Processing node 26, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 26 LP 3 Solution, length = 28443867.387132, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.500000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28443867.387132, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28443867.387132, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 26 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 26
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.500000
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 6
DEBUG CAREFUL: New best var: 6
DEBUG CAREFUL: Testing fvar[1] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
  % Initial guess is x14, Z0 = 28461605.740395         , Z1 = 28509760.6286587        

DEBUG EVAL: Testing var 6 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=44, varin=54, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=20, varin=58, theta=1.000000, up=1.000000
ITER 3: row=50, varin=52, theta=0.555556, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 6 = 0 gives z=28482583.079608
  % 	x6 = 0,	Z0 = 28482583.079608         
DEBUG EVAL: First branch cutoff check: z=28482583.079608, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 6 = 1
ITER 1: row=44, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=55, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=58, theta=1.000000, up=1.000000
ITER 4: row=50, varin=52, theta=0.555556, up=999999999999999983222784.000000
  % 	x6 = 1,	Z1 = 28926895.5828216        
DEBUG EVAL: Second branch cutoff check: z=28926895.582822, best_z=INF, threshold=INF
  %   New best:  x6, Z = 28482583.079608         
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=20, varin=58, theta=1.000000, up=1.000000
ITER 3: row=50, varin=52, theta=0.555556, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28652320.400967
  % 	x14 = 0,	Z0 = 28652320.4009671        
DEBUG EVAL: First branch cutoff check: z=28652320.400967, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=32, varin=54, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=20, varin=58, theta=1.000000, up=1.000000
ITER 3: row=50, varin=52, theta=0.555556, up=999999999999999983222784.000000
  % 	x14 = 1,	Z1 = 28509760.6286587        
DEBUG EVAL: Second branch cutoff check: z=28509760.628659, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28509760.6286587        
  % Best branch is x14, Z0 = 28652320.4009671        , Z1 = 28509760.6286587        

DEBUG CAREFUL: Final result - returning best.var = 14
DEBUG BB: Branching variable chosen: j=14
 % @NC   37   26	x14 = 1	28509760.628659
 % @NC   38   26	x14 = 0	28652320.400967
 %      26    16 28443867.3871               28457952.2084    x7 U    19     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6055740
% @LO 0.04  28.44386738713184570315 99.9000000000
% @LN 0.04  28.45795220839753625341 99.9000000000
% Resuming node 29 at  28.45795220839753625341
DEBUG CONSTRNT: LP rows=55, pool->nlprows=55, pool->npend=0
DEBUG CONSTRNT: Checking 55 LP rows (pool tracks 55, total LP rows 55)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=54, expected 54
 % @PAP adding 58 rows, 243 nz to LP
DEBUG BB: Processing node 29, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 29 LP 2 Solution, length = 28457952.208398, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.112618 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.112618 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.436912 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.112618 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.112618 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.436912 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.112618 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.112618 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.436912 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.887382 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.887382 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.563088 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.887382 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.563088 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.887382 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.563088 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28457952.208398, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28457952.208398, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 29 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 29
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.112618
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.112618)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.112618
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.112618)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.436912
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.436912)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.112618
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.112618)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.112618
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.112618)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.436912
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.436912)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.112618
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.112618)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.112618
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.112618)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.436912
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.436912)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[1] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[2] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 31
DEBUG CAREFUL: New best var: 31
DEBUG CAREFUL: Testing fvar[3] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 37
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[6] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[7] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[8] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
  % Initial guess is x4, Z0 = 28457952.2083975        , Z1 = 28814678.6823048        

DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=56, theta=0.701538, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28489540.234221
  % 	x10 = 0,	Z0 = 28489540.2342209        
DEBUG EVAL: First branch cutoff check: z=28489540.234221, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=22, varin=25, theta=0.477164, up=999999999999999983222784.000000
ITER 2: row=1, varin=45, theta=0.609743, up=999999999999999983222784.000000
ITER 3: row=23, varin=61, theta=2.101950, up=1.000000
ITER 4: row=23, varin=50, theta=2.714681, up=999999999999999983222784.000000
ITER 5: row=44, varin=7, theta=4.891098, up=999999999999999983222784.000000
ITER 6: row=15, varin=97, theta=173.929779, up=1.000000
  % 	x10 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=56, theta=0.701538, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28489540.234221
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 303 nonzeros, 1 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 5 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=62, varin=25, theta=0.333287, up=999999999999999983222784.000000
ITER 2: row=59, varin=52, theta=230892.111111, up=999999999999999983222784.000000
ITER 3: row=26, varin=34, theta=0.086662, up=999999999999999983222784.000000
ITER 4: row=61, varin=59, theta=4.073114, up=999999999999999983222784.000000
ITER 5: row=60, varin=6, theta=0.467351, up=999999999999999983222784.000000
ITER 6: row=38, varin=35, theta=0.354513, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 28594441.716316
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.800000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 62 rows, 60 cols, 327 nonzeros, 4 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=43, theta=0.142857, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28600219.439095
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
   % @PL 60 rows, 60 cols, 283 nonzeros, 3 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 29 at  28.60021943909494268610
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6041ff0
% @LO 0.04  28.45795220839753625341 99.9000000000
% @LN 0.04  28.46496546838772445653 99.9000000000
% Resuming node 32 at  28.46496546838772445653
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=56, expected 56
 % @PAP adding 53 rows, 227 nz to LP
DEBUG BB: Processing node 32, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 32 LP 3 Solution, length = 28464965.468388, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.664350 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.664350 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.335650 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.335650 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.335650 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28464965.468388, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28464965.468388, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % initially 3 congested vertices:
 % _gst_find_congested_components found 1 components:
 % 	component 0:	3 verts,	3 edges
 % @PAP adding 1 rows, 12 nz to LP
 % @PMEM 164 rows, 1 blocks, 402 nzfree, 0 nzwasted, 1172 nztotal
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=98, theta=0.075101, up=1.000000
ITER 2: row=43, varin=108, theta=0.303262, up=1.000000
LP PHASE: Switching to primal (iter=2)
ITER 3: row=7, varin=47, theta=0.222461, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28470908.879894
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 299 nonzeros, 3 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=65, theta=8.000000, up=1.000000
ITER 2: row=1, varin=60, theta=7.000000, up=1.000000
ITER 3: row=1, varin=95, theta=12.000000, up=1.000000
ITER 4: row=1, varin=96, theta=11.000000, up=1.000000
ITER 5: row=1, varin=97, theta=10.000000, up=1.000000
ITER 6: row=1, varin=98, theta=9.000000, up=1.000000
ITER 7: row=1, varin=99, theta=8.000000, up=1.000000
ITER 8: row=1, varin=100, theta=7.000000, up=1.000000
ITER 9: row=1, varin=101, theta=6.000000, up=1.000000
ITER 10: row=1, varin=102, theta=5.000000, up=1.000000
LP PHASE: Switching to primal (iter=48)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28475168.729939
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 299 nonzeros, 1 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 32 LP 4 Solution, length = 28475168.729939, 0.00/0.00/0.00/0.00/0.00/0.00/0.00 1
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.500000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28475168.729939, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.04  28.46496546838772445653 99.9000000000
 % @LN 0.04  28.47516872993938008563 99.9000000000
DEBUG CG: Second cutoff check: z=28475168.729939, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 32 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 32
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.500000
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[2] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x34, Z0 = 28475168.7299394        , Z1 = 28475168.7299394        

DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=53, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=20, varin=98, theta=0.333333, up=1.000000
ITER 3: row=16, varin=107, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28505008.755364
  % 	x34 = 0,	Z0 = 28505008.7553642        
DEBUG EVAL: First branch cutoff check: z=28505008.755364, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 1
ITER 1: row=36, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=52, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=98, theta=0.333333, up=1.000000
ITER 4: row=36, varin=53, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=16, varin=107, theta=2.000000, up=1.000000
ITER 6: row=16, varin=37, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=43, varin=107, theta=1.000000, up=1.000000
ITER 8: row=51, varin=49, theta=1.000000, up=999999999999999983222784.000000
  % 	x34 = 1,	Z1 = 28782927.4486849        
DEBUG EVAL: Second branch cutoff check: z=28782927.448685, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28505008.7553642        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=52, varin=50, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=98, theta=0.333333, up=1.000000
ITER 4: row=16, varin=107, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28587035.735594
  % 	x5 = 0,	Z0 = 28587035.7355939        
DEBUG EVAL: First branch cutoff check: z=28587035.735594, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=1, varin=53, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=20, varin=98, theta=0.333333, up=1.000000
ITER 3: row=16, varin=107, theta=1.000000, up=1.000000
  % 	x5 = 1,	Z1 = 28505008.7553642        
DEBUG EVAL: Second branch cutoff check: z=28505008.755364, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=49, varin=53, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=20, varin=98, theta=0.333333, up=1.000000
ITER 3: row=16, varin=107, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 36 = 0 gives z=28505008.755364
  % 	x36 = 0,	Z0 = 28505008.7553642        
DEBUG EVAL: First branch cutoff check: z=28505008.755364, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 1
ITER 1: row=49, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=51, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=98, theta=0.333333, up=1.000000
ITER 4: row=16, varin=107, theta=1.000000, up=1.000000
  % 	x36 = 1,	Z1 = 28958874.8184205        
DEBUG EVAL: Second branch cutoff check: z=28958874.818420, best_z=INF, threshold=INF
  %   New best:  x36, Z = 28505008.7553642        
  % Best branch is x36, Z0 = 28505008.7553642        , Z1 = 28958874.8184205        

DEBUG CAREFUL: Final result - returning best.var = 36
DEBUG BB: Branching variable chosen: j=36
 % @NC   39   32	x36 = 0	28505008.755364
 % @NC   40   32	x36 = 1	28958874.818420
 %      32    17 28475168.7299               28489358.2073   x14 U    25     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60410f0
% @LO 0.04  28.47516872993938008563 99.9000000000
% @LN 0.04  28.48935820727723111645 99.9000000000
% Resuming node 13 at  28.48935820727723111645
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=52, expected 52
 % @PAP adding 59 rows, 242 nz to LP
DEBUG BB: Processing node 13, calling compute_good_lower_bound
LP PHASE: Starting primal phase (iter=0)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28489358.207277
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 302 nonzeros, 0 slack, 59 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 13 LP 5 Solution, length = 28489358.207277, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.160537 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.160537 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.160537 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.018388 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.160537 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.018388 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.160537 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.018388 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.839463 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.839463 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.839463 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.839463 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.981612 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.981612 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.839463 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28489358.207277, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28489358.207277, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 13 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 13
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.160537
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.160537)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.160537
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.160537)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.160537
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.160537)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.018388
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.018388)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.160537
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.160537)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.018388
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.018388)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.160537
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.160537)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.018388
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.018388)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[2] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[5] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[6] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[7] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
  % Initial guess is x4, Z0 = 28489358.2072772        , Z1 = 29084210.8350793        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=84, theta=0.076374, up=1.000000
ITER 2: row=3, varin=87, theta=0.033702, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28489959.660295
  % 	x12 = 0,	Z0 = 28489959.6602952        
DEBUG EVAL: First branch cutoff check: z=28489959.660295, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=35, varin=56, theta=1.808407, up=999999999999999983222784.000000
ITER 2: row=56, varin=102, theta=2.307075, up=1.000000
ITER 3: row=56, varin=54, theta=0.907508, up=999999999999999983222784.000000
ITER 4: row=48, varin=45, theta=1.324110, up=999999999999999983222784.000000
ITER 5: row=55, varin=102, theta=0.742036, up=1.000000
ITER 6: row=45, varin=42, theta=0.486778, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28604515.2373441        
DEBUG EVAL: Second branch cutoff check: z=28604515.237344, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28489959.6602952        
DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=45, varin=56, theta=1.808407, up=999999999999999983222784.000000
ITER 2: row=56, varin=102, theta=2.307075, up=1.000000
ITER 3: row=56, varin=54, theta=0.907508, up=999999999999999983222784.000000
ITER 4: row=48, varin=42, theta=1.240244, up=999999999999999983222784.000000
ITER 5: row=55, varin=102, theta=0.784860, up=1.000000
ITER 6: row=42, varin=51, theta=0.468840, up=999999999999999983222784.000000
ITER 7: row=23, varin=48, theta=0.445332, up=999999999999999983222784.000000
ITER 8: row=30, varin=26, theta=0.507537, up=999999999999999983222784.000000
ITER 9: row=26, varin=55, theta=0.320148, up=999999999999999983222784.000000
ITER 10: row=57, varin=47, theta=0.203318, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 1 gives z=28709452.847954
  % 	x25 = 1,	Z1 = 28709452.847954         
DEBUG EVAL: First branch cutoff check: z=28709452.847954, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 0
ITER 1: row=45, varin=84, theta=0.076374, up=1.000000
ITER 2: row=3, varin=87, theta=0.033702, up=1.000000
  % 	x25 = 0,	Z0 = 28489959.6602952        
DEBUG EVAL: Second branch cutoff check: z=28489959.660295, best_z=INF, threshold=INF
  %   New best:  x25, Z = 28489959.6602952        
DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=56, theta=1.808407, up=999999999999999983222784.000000
ITER 2: row=56, varin=102, theta=2.307075, up=1.000000
ITER 3: row=56, varin=54, theta=0.907508, up=999999999999999983222784.000000
ITER 4: row=48, varin=45, theta=1.324110, up=999999999999999983222784.000000
ITER 5: row=55, varin=102, theta=0.742036, up=1.000000
ITER 6: row=45, varin=51, theta=0.530402, up=999999999999999983222784.000000
ITER 7: row=23, varin=48, theta=0.503806, up=999999999999999983222784.000000
ITER 8: row=30, varin=26, theta=0.574179, up=999999999999999983222784.000000
ITER 9: row=26, varin=55, theta=0.362185, up=999999999999999983222784.000000
ITER 10: row=57, varin=47, theta=0.230015, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 1 gives z=28669988.487696
  % 	x21 = 1,	Z1 = 28669988.4876956        
DEBUG EVAL: First branch cutoff check: z=28669988.487696, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 0
ITER 1: row=42, varin=84, theta=0.076374, up=1.000000
ITER 2: row=3, varin=87, theta=0.033702, up=1.000000
  % 	x21 = 0,	Z0 = 28489959.6602952        
DEBUG EVAL: Second branch cutoff check: z=28489959.660295, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=102, theta=0.348319, up=1.000000
ITER 2: row=35, varin=56, theta=0.041136, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28491823.252377
  % 	x2 = 0,	Z0 = 28491823.2523766        
DEBUG EVAL: First branch cutoff check: z=28491823.252377, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=56, theta=-58.834687, up=999999999999999983222784.000000
ITER 2: row=1, varin=51, theta=3.820885, up=999999999999999983222784.000000
ITER 3: row=23, varin=19, theta=1.427877, up=999999999999999983222784.000000
ITER 4: row=49, varin=48, theta=0.967979, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28957707.749749         
DEBUG EVAL: Second branch cutoff check: z=28957707.749749, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28491823.2523766        
DEBUG EVAL: Testing var 20 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=102, theta=0.348319, up=1.000000
ITER 2: row=35, varin=56, theta=0.041136, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 0 gives z=28491823.252377
  % 	x20 = 0,	Z0 = 28491823.2523766        
DEBUG EVAL: First branch cutoff check: z=28491823.252377, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 1
ITER 1: row=7, varin=56, theta=-58.834687, up=999999999999999983222784.000000
ITER 2: row=7, varin=51, theta=3.820885, up=999999999999999983222784.000000
ITER 3: row=23, varin=48, theta=3.005351, up=999999999999999983222784.000000
ITER 4: row=30, varin=47, theta=3.560658, up=999999999999999983222784.000000
ITER 5: row=59, varin=87, theta=27.197486, up=1.000000
ITER 6: row=59, varin=6, theta=1.712798, up=999999999999999983222784.000000
ITER 7: row=57, varin=56, theta=7.619622, up=999999999999999983222784.000000
ITER 8: row=56, varin=20, theta=1.900989, up=999999999999999983222784.000000
ITER 9: row=12, varin=44, theta=5.404018, up=999999999999999983222784.000000
ITER 10: row=1, varin=8, theta=1.442192, up=999999999999999983222784.000000
  % 	x20 = 1,	Z1 = 30745580.490641         
DEBUG EVAL: Second branch cutoff check: z=30745580.490641, best_z=INF, threshold=INF
  %   New best:  x20, Z = 28491823.2523766        
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=56, theta=-58.834687, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=27375018.844284
  % 	x11 = 1,	Z1 = 29021952.9015346        
DEBUG EVAL: First branch cutoff check: z=29021952.901535, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=30, varin=102, theta=0.348319, up=1.000000
  % 	x11 = 0,	Z0 = 28491050.3124576        
DEBUG EVAL: Second branch cutoff check: z=28491050.312458, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=48, varin=56, theta=-58.834687, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=27375018.844284
  % 	x22 = 1,	Z1 = 28593931.6829865        
DEBUG EVAL: First branch cutoff check: z=28593931.682987, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=48, varin=102, theta=0.348319, up=1.000000
  % 	x22 = 0,	Z0 = 28491050.3124576        
DEBUG EVAL: Second branch cutoff check: z=28491050.312458, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=56, theta=-58.834687, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=27375018.844284
  % 	x4 = 1,	Z1 = 29084210.8350793        
DEBUG EVAL: First branch cutoff check: z=29084210.835079, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=23, varin=102, theta=0.348319, up=1.000000
  % 	x4 = 0,	Z0 = 28491050.3124576        
DEBUG EVAL: Second branch cutoff check: z=28491050.312458, best_z=INF, threshold=INF
  % Best branch is x20, Z0 = 28491823.2523766        , Z1 = 30745580.490641         

DEBUG CAREFUL: Final result - returning best.var = 20
DEBUG BB: Branching variable chosen: j=20
 % @NC   41   13	x20 = 0	28491823.252377
 % @NC   42   13	x20 = 1	30745580.490641
 %      13    18 28489358.2073               28490269.9695   x15 D     2     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60478a0
% @LO 0.04  28.48935820727723111645 99.9000000000
% @LN 0.04  28.49026996949005052784 99.9000000000
% Resuming node 28 at  28.49026996949005052784
DEBUG CONSTRNT: LP rows=59, pool->nlprows=59, pool->npend=0
DEBUG CONSTRNT: Checking 59 LP rows (pool tracks 59, total LP rows 59)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=58, expected 58
 % @PAP adding 54 rows, 228 nz to LP
DEBUG BB: Processing node 28, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=6, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=48, varin=41, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=51, varin=40, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28490269.969490
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.500000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 288 nonzeros, 3 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=61, theta=0.077895, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28496749.086436
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.500000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 294 nonzeros, 3 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 28 LP 1 Solution, length = 28496749.086436, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.077895 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.172105 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.172105 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.172105 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.827895 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.827895 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.827895 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.827895 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.827895 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.827895 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28496749.086436, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 28 at  28.49674908643605775183
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6041ff0
% @LO 0.04  28.49026996949005052784 99.9000000000
% @LN 0.04  28.49182325237662283257 99.9000000000
% Resuming node 41 at  28.49182325237662283257
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=53, expected 53
 % @PAP adding 59 rows, 242 nz to LP
DEBUG BB: Processing node 41, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=7, varin=102, theta=0.348319, up=1.000000
ITER 2: row=35, varin=56, theta=0.041136, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28491823.252377
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 302 nonzeros, 4 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 41 LP 1 Solution, length = 28491823.252377, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.347045 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.347045 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.305909 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.347045 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.652955 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.652955 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.652955 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28491823.252377, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28491823.252377, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 41 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 41
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.347045
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.347045)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.347045
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.347045)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.305909
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.305909)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.347045
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.347045)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 36
DEBUG CAREFUL: New best var: 36
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[2] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 6
DEBUG CAREFUL: Testing fvar[3] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 28
DEBUG CAREFUL: New best var: 28
  % Initial guess is x28, Z0 = 28491823.2523766        , Z1 = 28615370.728644         

DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=84, theta=4.330328, up=1.000000
ITER 2: row=37, varin=41, theta=0.324313, up=999999999999999983222784.000000
ITER 3: row=3, varin=84, theta=1.000000, up=1.000000
ITER 4: row=58, varin=72, theta=0.084095, up=1.000000
DEBUG EVAL: Branch var 36 = 0 gives z=28597893.957662
  % 	x36 = 0,	Z0 = 28597893.9576624        
DEBUG EVAL: First branch cutoff check: z=28597893.957662, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 1
ITER 1: row=37, varin=51, theta=1.324889, up=999999999999999983222784.000000
ITER 2: row=51, varin=48, theta=1.400996, up=999999999999999983222784.000000
ITER 3: row=48, varin=47, theta=2.521978, up=999999999999999983222784.000000
ITER 4: row=59, varin=6, theta=0.963578, up=999999999999999983222784.000000
ITER 5: row=56, varin=87, theta=0.708847, up=1.000000
ITER 6: row=58, varin=56, theta=0.148158, up=999999999999999983222784.000000
  % 	x36 = 1,	Z1 = 28863582.7850375        
DEBUG EVAL: Second branch cutoff check: z=28863582.785038, best_z=INF, threshold=INF
  %   New best:  x36, Z = 28597893.9576624        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=84, theta=4.330328, up=1.000000
ITER 2: row=1, varin=97, theta=1.132795, up=1.000000
ITER 3: row=1, varin=110, theta=0.053616, up=1.000000
ITER 4: row=30, varin=97, theta=1.503492, up=1.000000
ITER 5: row=30, varin=54, theta=0.223520, up=999999999999999983222784.000000
ITER 6: row=3, varin=84, theta=0.718117, up=1.000000
ITER 7: row=13, varin=97, theta=1.395225, up=1.000000
ITER 8: row=13, varin=88, theta=2.405165, up=1.000000
ITER 9: row=13, varin=19, theta=0.077803, up=999999999999999983222784.000000
ITER 10: row=54, varin=88, theta=1.299514, up=1.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28657083.596947
  % 	x5 = 0,	Z0 = 28657083.5969469        
DEBUG EVAL: First branch cutoff check: z=28657083.596947, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=1, varin=51, theta=1.324889, up=999999999999999983222784.000000
ITER 2: row=51, varin=48, theta=1.400996, up=999999999999999983222784.000000
ITER 3: row=48, varin=47, theta=2.521978, up=999999999999999983222784.000000
ITER 4: row=59, varin=20, theta=1.086000, up=999999999999999983222784.000000
ITER 5: row=12, varin=87, theta=7.346001, up=1.000000
ITER 6: row=12, varin=44, theta=2.770109, up=999999999999999983222784.000000
ITER 7: row=23, varin=8, theta=0.882118, up=999999999999999983222784.000000
ITER 8: row=8, varin=72, theta=7.256854, up=1.000000
ITER 9: row=8, varin=41, theta=2.343497, up=999999999999999983222784.000000
ITER 10: row=37, varin=37, theta=1.621373, up=999999999999999983222784.000000
  % 	x5 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=84, theta=4.330328, up=1.000000
ITER 2: row=1, varin=97, theta=1.132795, up=1.000000
ITER 3: row=1, varin=110, theta=0.053616, up=1.000000
ITER 4: row=30, varin=97, theta=1.503492, up=1.000000
ITER 5: row=30, varin=54, theta=0.223520, up=999999999999999983222784.000000
ITER 6: row=3, varin=84, theta=0.718117, up=1.000000
ITER 7: row=13, varin=97, theta=1.395225, up=1.000000
ITER 8: row=13, varin=88, theta=2.405165, up=1.000000
ITER 9: row=13, varin=19, theta=0.077803, up=999999999999999983222784.000000
ITER 10: row=54, varin=88, theta=1.299514, up=1.000000
LP PHASE: Switching to primal (iter=15)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28657083.596947
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 59 rows, 60 cols, 302 nonzeros, 1 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=85, theta=1.500000, up=1.000000
ITER 2: row=59, varin=82, theta=0.333333, up=1.000000
ITER 3: row=3, varin=85, theta=1.000000, up=1.000000
ITER 4: row=41, varin=86, theta=1.000000, up=1.000000
ITER 5: row=44, varin=73, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28745635.906337
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 60 rows, 60 cols, 274 nonzeros, 0 slack, 60 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 41 at  28.74563590633729859292
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60478a0
% @LO 0.05  28.49182325237662283257 99.9000000000
% @LN 0.05  28.49674908643605775183 99.9000000000
% Resuming node 28 at  28.49674908643605775183
DEBUG CONSTRNT: LP rows=60, pool->nlprows=60, pool->npend=0
DEBUG CONSTRNT: Checking 60 LP rows (pool tracks 60, total LP rows 60)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=59, expected 59
 % @PAP adding 54 rows, 228 nz to LP
DEBUG BB: Processing node 28, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 28 LP 2 Solution, length = 28496749.086436, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.077895 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.172105 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.172105 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.172105 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.827895 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.827895 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.827895 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.827895 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.827895 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.827895 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28496749.086436, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28496749.086436, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 28 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 28
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.077895
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.077895)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.172105
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.172105)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.172105
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.172105)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.172105
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.172105)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[4] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x17, Z0 = 28496749.0864361        , Z1 = 28874978.9628375        

DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=42, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=51, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=89, theta=0.023980, up=1.000000
ITER 4: row=24, varin=52, theta=0.020205, up=999999999999999983222784.000000
ITER 5: row=39, varin=79, theta=0.427308, up=1.000000
ITER 6: row=3, varin=81, theta=0.117206, up=1.000000
ITER 7: row=1, varin=46, theta=0.035492, up=999999999999999983222784.000000
ITER 8: row=42, varin=3, theta=0.519278, up=999999999999999983222784.000000
ITER 9: row=39, varin=58, theta=0.084547, up=1.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28874709.173818
  % 	x5 = 1,	Z1 = 28874709.1738177        
DEBUG EVAL: First branch cutoff check: z=28874709.173818, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=29, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x5 = 0,	Z0 = 28592612.6508386        
DEBUG EVAL: Second branch cutoff check: z=28592612.650839, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28592612.6508386        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=41, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28592612.650839
  % 	x7 = 0,	Z0 = 28592612.6508386        
DEBUG EVAL: First branch cutoff check: z=28592612.650839, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=41, varin=47, theta=1.000000, up=999999999999999983222784.000000
  % 	x7 = 1,	Z1 = 28595917.6369841        
DEBUG EVAL: Second branch cutoff check: z=28595917.636984, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=52, theta=1.080968, up=999999999999999983222784.000000
ITER 2: row=39, varin=49, theta=0.525627, up=999999999999999983222784.000000
ITER 3: row=49, varin=2, theta=0.496459, up=999999999999999983222784.000000
ITER 4: row=2, varin=46, theta=0.401401, up=999999999999999983222784.000000
ITER 5: row=42, varin=7, theta=0.563498, up=999999999999999983222784.000000
ITER 6: row=7, varin=20, theta=0.565775, up=999999999999999983222784.000000
ITER 7: row=20, varin=41, theta=0.825449, up=999999999999999983222784.000000
ITER 8: row=30, varin=47, theta=0.246469, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28664380.952854
  % 	x3 = 1,	Z1 = 28664380.9528536        
DEBUG EVAL: First branch cutoff check: z=28664380.952854, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=1, varin=89, theta=0.165570, up=1.000000
  % 	x3 = 0,	Z0 = 28499794.5661125        
DEBUG EVAL: Second branch cutoff check: z=28499794.566112, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=40, theta=1.184748, up=999999999999999983222784.000000
ITER 2: row=44, varin=41, theta=3.227431, up=999999999999999983222784.000000
ITER 3: row=46, varin=39, theta=0.981712, up=999999999999999983222784.000000
ITER 4: row=53, varin=48, theta=1.441915, up=999999999999999983222784.000000
ITER 5: row=47, varin=30, theta=1.228116, up=999999999999999983222784.000000
ITER 6: row=1, varin=81, theta=0.478494, up=1.000000
ITER 7: row=39, varin=58, theta=0.795361, up=1.000000
ITER 8: row=1, varin=79, theta=3.387804, up=1.000000
ITER 9: row=1, varin=45, theta=0.099390, up=999999999999999983222784.000000
ITER 10: row=3, varin=79, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 1 gives z=29397288.075972
  % 	x17 = 1,	Z1 = 29397288.075972         
DEBUG EVAL: First branch cutoff check: z=29397288.075972, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=42, varin=46, theta=0.211025, up=999999999999999983222784.000000
  % 	x17 = 0,	Z0 = 28525317.2895694        
DEBUG EVAL: Second branch cutoff check: z=28525317.289569, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=41, theta=3.227431, up=999999999999999983222784.000000
ITER 2: row=46, varin=38, theta=2.418396, up=999999999999999983222784.000000
ITER 3: row=53, varin=46, theta=1.358175, up=999999999999999983222784.000000
ITER 4: row=54, varin=53, theta=3.098037, up=999999999999999983222784.000000
ITER 5: row=42, varin=48, theta=0.976486, up=999999999999999983222784.000000
ITER 6: row=41, varin=81, theta=5.799684, up=1.000000
ITER 7: row=41, varin=79, theta=27.526291, up=1.000000
ITER 8: row=41, varin=76, theta=3.518340, up=1.000000
ITER 9: row=41, varin=30, theta=1.848569, up=999999999999999983222784.000000
ITER 10: row=3, varin=79, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 18 = 1 gives z=34622836.651018
  % 	x18 = 1,	Z1 = 34622836.6510184        
DEBUG EVAL: First branch cutoff check: z=34622836.651018, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=39, varin=52, theta=0.487500, up=999999999999999983222784.000000
  % 	x18 = 0,	Z0 = 28531339.0099808        
DEBUG EVAL: Second branch cutoff check: z=28531339.009981, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=38, theta=0.225346, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28532783.857015
  % 	x10 = 0,	Z0 = 28532783.8570152        
DEBUG EVAL: First branch cutoff check: z=28532783.857015, best_z=INF, threshold=INF
  % Best branch is x5, Z0 = 28592612.6508386        , Z1 = 28874709.1738177        

DEBUG CAREFUL: Final result - returning best.var = 5
DEBUG BB: Branching variable chosen: j=5
 % @NC   43   28	x5 = 0	28592612.650839
 % @NC   44   28	x5 = 1	28874709.173818
 %      28    19 28496749.0864               28502923.5746   x16 D    23     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6038600
% @LO 0.05  28.49674908643605775183 99.9000000000
% @LN 0.05  28.50292357461651349126 99.9000000000
% Resuming node 7 at  28.50292357461651349126
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=53, expected 53
 % @PAP adding 57 rows, 248 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
LP PHASE: Switching to primal (iter=0)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28502923.574617
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 308 nonzeros, 0 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 7 LP 7 Solution, length = 28502923.574617, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.237786 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.237786 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.237786 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.237786 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.237786 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.237786 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.048854 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.237786 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.762214 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.762214 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.762214 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.762214 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.762214 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.762214 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.762214 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28502923.574617, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28502923.574617, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.237786
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.237786)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.237786
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.237786)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.237786
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.237786)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.237786
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.237786)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.237786
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.237786)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.237786
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.237786)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.048854
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.048854)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.237786
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.237786)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 31
DEBUG CAREFUL: New best var: 31
DEBUG CAREFUL: Testing fvar[1] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[6] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[7] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 37
  % Initial guess is x22, Z0 = 28502923.5746165        , Z1 = 29447663.087878         

DEBUG EVAL: Testing var 31 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=54, varin=57, theta=0.747713, up=999999999999999983222784.000000
ITER 2: row=34, varin=49, theta=0.820915, up=999999999999999983222784.000000
ITER 3: row=49, varin=56, theta=0.753586, up=999999999999999983222784.000000
ITER 4: row=53, varin=48, theta=0.567169, up=999999999999999983222784.000000
ITER 5: row=48, varin=54, theta=0.521665, up=999999999999999983222784.000000
ITER 6: row=37, varin=24, theta=0.464754, up=999999999999999983222784.000000
ITER 7: row=24, varin=53, theta=278226.000000, up=999999999999999983222784.000000
ITER 8: row=6, varin=51, theta=0.515603, up=999999999999999983222784.000000
ITER 9: row=51, varin=3, theta=0.196345, up=999999999999999983222784.000000
ITER 10: row=3, varin=42, theta=0.438933, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 1 gives z=29078137.266224
  % 	x31 = 1,	Z1 = 29078137.2662244        
DEBUG EVAL: First branch cutoff check: z=29078137.266224, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 0
ITER 1: row=54, varin=90, theta=0.050343, up=1.000000
ITER 2: row=10, varin=87, theta=0.053449, up=1.000000
ITER 3: row=19, varin=5, theta=0.033260, up=999999999999999983222784.000000
ITER 4: row=14, varin=19, theta=0.024141, up=999999999999999983222784.000000
ITER 5: row=12, varin=91, theta=0.040746, up=1.000000
ITER 6: row=16, varin=88, theta=0.018545, up=1.000000
  % 	x31 = 0,	Z0 = 28509722.4238678        
DEBUG EVAL: Second branch cutoff check: z=28509722.423868, best_z=INF, threshold=INF
  %   New best:  x31, Z = 28509722.4238678        
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=53, varin=90, theta=-103.114927, up=1.000000
ITER 2: row=53, varin=39, theta=0.900868, up=999999999999999983222784.000000
ITER 3: row=54, varin=3, theta=0.415116, up=999999999999999983222784.000000
ITER 4: row=26, varin=57, theta=0.239609, up=999999999999999983222784.000000
ITER 5: row=34, varin=49, theta=0.265132, up=999999999999999983222784.000000
ITER 6: row=49, varin=48, theta=0.242342, up=999999999999999983222784.000000
ITER 7: row=48, varin=54, theta=0.219182, up=999999999999999983222784.000000
ITER 8: row=37, varin=51, theta=0.238650, up=999999999999999983222784.000000
ITER 9: row=51, varin=2, theta=0.084048, up=999999999999999983222784.000000
ITER 10: row=11, varin=8, theta=0.094661, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28815145.880263
  % 	x27 = 1,	Z1 = 28815145.8802635        
DEBUG EVAL: First branch cutoff check: z=28815145.880263, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=53, varin=56, theta=0.223160, up=999999999999999983222784.000000
  % 	x27 = 0,	Z0 = 28528577.2550956        
DEBUG EVAL: Second branch cutoff check: z=28528577.255096, best_z=INF, threshold=INF
  %   New best:  x27, Z = 28528577.2550956        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=37, theta=0.460438, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28572830.537490
  % 	x17 = 0,	Z0 = 28572830.5374896        
DEBUG EVAL: First branch cutoff check: z=28572830.537490, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=22, varin=90, theta=-103.114927, up=1.000000
ITER 2: row=22, varin=2, theta=0.913017, up=999999999999999983222784.000000
ITER 3: row=11, varin=3, theta=6.697206, up=999999999999999983222784.000000
ITER 4: row=3, varin=8, theta=2.573408, up=999999999999999983222784.000000
ITER 5: row=18, varin=51, theta=6.252259, up=999999999999999983222784.000000
ITER 6: row=51, varin=87, theta=22.458647, up=1.000000
ITER 7: row=51, varin=43, theta=2.458230, up=999999999999999983222784.000000
ITER 8: row=18, varin=24, theta=5.079189, up=999999999999999983222784.000000
ITER 9: row=24, varin=41, theta=2.770636, up=999999999999999983222784.000000
ITER 10: row=41, varin=7, theta=1.661800, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=37, theta=0.460438, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=12, varin=5, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28572830.537490
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 308 nonzeros, 1 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=91, theta=0.547397, up=1.000000
ITER 2: row=10, varin=88, theta=0.387656, up=1.000000
ITER 3: row=14, varin=92, theta=0.288505, up=1.000000
ITER 4: row=4, varin=89, theta=0.139971, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28599807.738055
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.965007
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 318 nonzeros, 1 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=9, theta=0.188059, up=999999999999999983222784.000000
ITER 2: row=58, varin=37, theta=0.200755, up=999999999999999983222784.000000
ITER 3: row=10, varin=23, theta=0.052630, up=999999999999999983222784.000000
ITER 4: row=24, varin=40, theta=0.309183, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28634412.689229
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 60 rows, 60 cols, 324 nonzeros, 3 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 7 at  28.63441268922898430560
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f605a130
% @LO 0.05  28.50292357461651349126 99.9000000000
% @LN 0.05  28.50500875536421929723 99.9000000000
% Resuming node 39 at  28.50500875536421929723
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=56, expected 56
 % @PAP adding 53 rows, 199 nz to LP
DEBUG BB: Processing node 39, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=53, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=20, varin=98, theta=0.333333, up=1.000000
ITER 3: row=16, varin=107, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28505008.755364
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 259 nonzeros, 6 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 52 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=49, theta=0.346971, up=999999999999999983222784.000000
ITER 2: row=54, varin=112, theta=0.163632, up=1.000000
ITER 3: row=52, varin=83, theta=0.018483, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28522370.024120
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 311 nonzeros, 9 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 5 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=98, theta=0.048644, up=1.000000
ITER 2: row=3, varin=63, theta=0.029184, up=1.000000
ITER 3: row=50, varin=5, theta=0.411060, up=999999999999999983222784.000000
ITER 4: row=17, varin=52, theta=0.507775, up=999999999999999983222784.000000
ITER 5: row=48, varin=64, theta=0.149676, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28538039.575014
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 300 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=36, theta=0.042150, up=999999999999999983222784.000000
ITER 2: row=41, varin=59, theta=0.089398, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28540427.635334
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 296 nonzeros, 0 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=81, theta=0.036031, up=1.000000
ITER 2: row=23, varin=79, theta=0.014398, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28542412.177815
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 302 nonzeros, 0 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=44, theta=0.034480, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28542788.685251
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 309 nonzeros, 1 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 39 LP 1 Solution, length = 28542788.685251, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.073891 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.073891 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.073891 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.482760 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.073891 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.073891 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.073891 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.073891 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.482760 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.517240 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.926109 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.926109 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.517240 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.926109 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.926109 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.926109 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.926109 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.926109 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28542788.685251, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 39 at  28.54278868525056012118
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6042690
% @LO 0.05  28.50500875536421929723 99.9000000000
% @LN 0.05  28.50976062865866467178 99.9000000000
% Resuming node 37 at  28.50976062865866467178
DEBUG CONSTRNT: LP rows=58, pool->nlprows=58, pool->npend=0
DEBUG CONSTRNT: Checking 58 LP rows (pool tracks 58, total LP rows 58)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=57, expected 57
 % @PAP adding 55 rows, 216 nz to LP
DEBUG BB: Processing node 37, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=54, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=20, varin=58, theta=1.000000, up=1.000000
ITER 3: row=50, varin=52, theta=0.555556, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28482583.079608
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 276 nonzeros, 9 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 54 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=86, theta=0.938118, up=1.000000
ITER 2: row=58, varin=70, theta=0.179681, up=1.000000
ITER 3: row=59, varin=30, theta=0.157270, up=999999999999999983222784.000000
ITER 4: row=56, varin=83, theta=0.222643, up=1.000000
ITER 5: row=26, varin=71, theta=0.044114, up=1.000000
ITER 6: row=58, varin=81, theta=0.080575, up=1.000000
ITER 7: row=52, varin=50, theta=0.002445, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28576016.457023
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 330 nonzeros, 11 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 11 slack rows
  % @PAP adding 7 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=66, theta=1.000000, up=1.000000
ITER 2: row=53, varin=81, theta=1.579972, up=1.000000
ITER 3: row=53, varin=78, theta=0.653177, up=1.000000
ITER 4: row=55, varin=82, theta=0.994305, up=1.000000
ITER 5: row=53, varin=81, theta=0.066586, up=1.000000
ITER 6: row=49, varin=60, theta=0.034951, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28742829.714355
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 311 nonzeros, 0 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=61, varin=84, theta=1.117756, up=1.000000
ITER 2: row=61, varin=90, theta=0.105416, up=1.000000
ITER 3: row=41, varin=49, theta=0.395844, up=999999999999999983222784.000000
ITER 4: row=57, varin=35, theta=0.075524, up=999999999999999983222784.000000
ITER 5: row=44, varin=84, theta=1.000845, up=1.000000
ITER 6: row=44, varin=55, theta=0.000325, up=999999999999999983222784.000000
ITER 7: row=39, varin=84, theta=0.787556, up=1.000000
ITER 8: row=20, varin=89, theta=0.986130, up=1.000000
ITER 9: row=42, varin=44, theta=0.001784, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28813532.582783
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 61 rows, 60 cols, 339 nonzeros, 8 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 5 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=41, theta=0.154504, up=999999999999999983222784.000000
ITER 2: row=57, varin=83, theta=4.136526, up=1.000000
ITER 3: row=57, varin=88, theta=1.172510, up=1.000000
ITER 4: row=57, varin=90, theta=0.195950, up=1.000000
ITER 5: row=18, varin=88, theta=1.000000, up=1.000000
ITER 6: row=3, varin=83, theta=1.000000, up=1.000000
ITER 7: row=57, varin=91, theta=0.828591, up=1.000000
ITER 8: row=56, varin=36, theta=1.022360, up=999999999999999983222784.000000
ITER 9: row=43, varin=17, theta=1.168791, up=999999999999999983222784.000000
ITER 10: row=10, varin=89, theta=4.770114, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 321 nonzeros, 10 slack, 48 tight.
  % Node 37 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.001784 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.001784 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.001784 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.007137 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.987709 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.998216 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.998216 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.998216 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.998216 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.999802 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 37 is INFEASIBLE
 %      37    18    infeasible               28511493.9813   x14 U    26     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6046ac0
% @LO 0.05  28.50976062865866467178 99.9000000000
% @LN 0.05  28.51149398133245682629 99.9000000000
% Resuming node 33 at  28.51149398133245682629
DEBUG CONSTRNT: LP rows=58, pool->nlprows=58, pool->npend=0
DEBUG CONSTRNT: Checking 58 LP rows (pool tracks 58, total LP rows 58)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=57, expected 57
 % @PAP adding 50 rows, 225 nz to LP
DEBUG BB: Processing node 33, calling compute_good_lower_bound
LP PHASE: Starting primal phase (iter=0)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28511493.981332
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 285 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 33 LP 2 Solution, length = 28511493.981332, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28511493.981332, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28511493.981332, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 33 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 33
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
  % Initial guess is x17, Z0 = 28511493.9813325        , Z1 = 28571159.2762894        

DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=42, theta=3.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28546960.194753
  % 	x10 = 0,	Z0 = 28546960.194753         
DEBUG EVAL: First branch cutoff check: z=28546960.194753, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=20, varin=49, theta=1.000000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28522987.9626649        
DEBUG EVAL: Second branch cutoff check: z=28522987.962665, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28522987.9626649        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=50, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=1, varin=49, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=17, theta=0.441176, up=999999999999999983222784.000000
ITER 4: row=10, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=46, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=40, varin=43, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28616083.564118
  % 	x17 = 1,	Z1 = 28616083.5641176        
DEBUG EVAL: First branch cutoff check: z=28616083.564118, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=35, varin=29, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=39, varin=77, theta=0.500000, up=1.000000
  % 	x17 = 0,	Z0 = 28528810.6287128        
DEBUG EVAL: Second branch cutoff check: z=28528810.628713, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28528810.6287128        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=29, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=39, varin=50, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28514568.146680
  % 	x2 = 0,	Z0 = 28514568.14668          
DEBUG EVAL: First branch cutoff check: z=28514568.146680, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=50, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=1, varin=49, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=17, theta=0.441176, up=999999999999999983222784.000000
ITER 4: row=10, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=46, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=40, varin=6, theta=0.384615, up=999999999999999983222784.000000
ITER 7: row=6, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=44, varin=7, theta=0.483871, up=999999999999999983222784.000000
ITER 9: row=17, varin=38, theta=0.500000, up=999999999999999983222784.000000
ITER 10: row=38, varin=36, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28722327.362168
  % 	x3 = 1,	Z1 = 28722327.3621682        
DEBUG EVAL: First branch cutoff check: z=28722327.362168, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=21, varin=29, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=39, varin=77, theta=0.500000, up=1.000000
  % 	x3 = 0,	Z0 = 28528810.6287128        
DEBUG EVAL: Second branch cutoff check: z=28528810.628713, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28528810.6287128        
  % Best branch is x3, Z0 = 28528810.6287128        , Z1 = 28722327.3621682        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   45   33	x3 = 0	28528810.628713
 % @NC   46   33	x3 = 1	28722327.362168
 %      33    19 28511493.9813               28512107.8717   x18 D    31    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f605a370
% @LO 0.05  28.51149398133245682629 99.9000000000
% @LN 0.05  28.51210787171871174905 99.9000000000
% Resuming node 20 at  28.51210787171871174905
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=49, expected 49
 % @PAP adding 53 rows, 230 nz to LP
DEBUG BB: Processing node 20, calling compute_good_lower_bound
LP PHASE: Starting primal phase (iter=0)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28512107.871719
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 290 nonzeros, 0 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 20 LP 2 Solution, length = 28512107.871719, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.226871 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.226871 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.226871 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.226871 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.092516 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.773129 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.773129 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.773129 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.773129 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.773129 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.773129 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28512107.871719, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28512107.871719, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 20 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 20
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.226871
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.226871)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.226871
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.226871)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.226871
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.226871)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.226871
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.226871)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.092516
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.092516)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[4] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
  % Initial guess is x3, Z0 = 28512107.8717187        , Z1 = 28621465.1343466        

DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=44, varin=49, theta=0.999820, up=999999999999999983222784.000000
ITER 2: row=46, varin=16, theta=1.010650, up=999999999999999983222784.000000
ITER 3: row=10, varin=52, theta=1.394122, up=999999999999999983222784.000000
ITER 4: row=52, varin=50, theta=0.574834, up=999999999999999983222784.000000
ITER 5: row=7, varin=6, theta=0.205561, up=999999999999999983222784.000000
ITER 6: row=1, varin=48, theta=0.336934, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28618684.350194
  % 	x26 = 1,	Z1 = 28618684.3501938        
DEBUG EVAL: First branch cutoff check: z=28618684.350194, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=44, varin=99, theta=0.027770, up=1.000000
ITER 2: row=17, varin=107, theta=0.141204, up=1.000000
  % 	x26 = 0,	Z0 = 28515540.912094         
DEBUG EVAL: Second branch cutoff check: z=28515540.912094, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28515540.912094         
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=31, theta=4.145625, up=999999999999999983222784.000000
ITER 2: row=20, varin=43, theta=1.550924, up=999999999999999983222784.000000
ITER 3: row=47, varin=16, theta=5.389253, up=999999999999999983222784.000000
ITER 4: row=10, varin=52, theta=6.722386, up=999999999999999983222784.000000
ITER 5: row=52, varin=44, theta=0.932416, up=999999999999999983222784.000000
ITER 6: row=51, varin=47, theta=2.338055, up=999999999999999983222784.000000
ITER 7: row=7, varin=6, theta=1.408599, up=999999999999999983222784.000000
ITER 8: row=44, varin=60, theta=1.133448, up=1.000000
ITER 9: row=44, varin=42, theta=0.169105, up=999999999999999983222784.000000
ITER 10: row=1, varin=80, theta=1.720596, up=1.000000
DEBUG EVAL: Branch var 3 = 1 gives z=29510598.668264
  % 	x3 = 1,	Z1 = 29510598.668264         
DEBUG EVAL: First branch cutoff check: z=29510598.668264, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=7, varin=99, theta=0.388627, up=1.000000
ITER 2: row=44, varin=49, theta=0.331250, up=999999999999999983222784.000000
ITER 3: row=46, varin=50, theta=0.179851, up=999999999999999983222784.000000
ITER 4: row=17, varin=80, theta=0.492840, up=1.000000
  % 	x3 = 0,	Z0 = 28548576.5122681        
DEBUG EVAL: Second branch cutoff check: z=28548576.512268, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28548576.5122681        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=99, theta=0.388627, up=1.000000
ITER 2: row=44, varin=31, theta=0.308526, up=999999999999999983222784.000000
ITER 3: row=10, varin=50, theta=0.109589, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28546336.198751
  % 	x10 = 0,	Z0 = 28546336.1987513        
DEBUG EVAL: First branch cutoff check: z=28546336.198751, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=43, varin=99, theta=0.388627, up=1.000000
ITER 2: row=44, varin=49, theta=0.331250, up=999999999999999983222784.000000
ITER 3: row=46, varin=43, theta=0.297927, up=999999999999999983222784.000000
ITER 4: row=47, varin=48, theta=0.376422, up=999999999999999983222784.000000
ITER 5: row=17, varin=107, theta=1.450566, up=1.000000
ITER 6: row=17, varin=45, theta=0.158543, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 0 gives z=28661917.258368
  % 	x18 = 0,	Z0 = 28661917.2583676        
DEBUG EVAL: First branch cutoff check: z=28661917.258368, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 1
ITER 1: row=43, varin=50, theta=1.327855, up=999999999999999983222784.000000
ITER 2: row=7, varin=31, theta=1.023577, up=999999999999999983222784.000000
ITER 3: row=20, varin=16, theta=1.753648, up=999999999999999983222784.000000
ITER 4: row=10, varin=52, theta=2.187445, up=999999999999999983222784.000000
ITER 5: row=52, varin=44, theta=0.760796, up=999999999999999983222784.000000
ITER 6: row=7, varin=6, theta=0.800907, up=999999999999999983222784.000000
ITER 7: row=44, varin=60, theta=0.714310, up=1.000000
ITER 8: row=1, varin=80, theta=3.493120, up=1.000000
ITER 9: row=1, varin=42, theta=0.683871, up=999999999999999983222784.000000
ITER 10: row=53, varin=41, theta=0.802346, up=999999999999999983222784.000000
  % 	x18 = 1,	Z1 = 32148086.3047163        
DEBUG EVAL: Second branch cutoff check: z=32148086.304716, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28661917.2583676        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=99, theta=0.388627, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28512569.557209
  % 	x17 = 0,	Z0 = 28512569.5572093        
DEBUG EVAL: First branch cutoff check: z=28512569.557209, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28661917.2583676        , Z1 = 32148086.3047163        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC   47   20	x18 = 0	28661917.258368
 % @NC   48   20	x18 = 1	32148086.304716
 %      20    20 28512107.8717               28527562.0858    x8 U    15     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f605a1f0
% @LO 0.05  28.51210787171871174905 99.9000000000
% @LN 0.05  28.52756208580472829794 99.9000000000
% Resuming node 10 at  28.52756208580472829794
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=52, expected 52
 % @PAP adding 62 rows, 255 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
LP PHASE: Starting primal phase (iter=0)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 28527562.085805
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 62 rows, 60 cols, 315 nonzeros, 0 slack, 62 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 10 LP 3 Solution, length = 28527562.085805, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.262844 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.043119 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.043119 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.043119 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.043119 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.043119 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.043119 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.043119 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.262844 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.262844 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.956881 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.737156 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.956881 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.737156 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.956881 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.956881 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.956881 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28527562.085805, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28527562.085805, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.262844
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.262844)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.043119
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.043119)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.043119
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.043119)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.043119
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.043119)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.043119
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.043119)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.043119
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.043119)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.043119
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.043119)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.043119
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.043119)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.262844
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.262844)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.262844
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.262844)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 31
DEBUG CAREFUL: New best var: 31
DEBUG CAREFUL: Testing fvar[1] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[2] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[3] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[4] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[6] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[7] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[8] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[9] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
  % Initial guess is x11, Z0 = 28527562.0858047        , Z1 = 28791399.0078591        

DEBUG EVAL: Testing var 31 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=58, varin=61, theta=2.040115, up=999999999999999983222784.000000
ITER 2: row=23, varin=10, theta=1.101233, up=999999999999999983222784.000000
ITER 3: row=10, varin=11, theta=0.734856, up=999999999999999983222784.000000
ITER 4: row=11, varin=20, theta=0.705131, up=999999999999999983222784.000000
ITER 5: row=20, varin=3, theta=0.879859, up=999999999999999983222784.000000
ITER 6: row=3, varin=19, theta=0.993505, up=999999999999999983222784.000000
ITER 7: row=12, varin=43, theta=0.631917, up=999999999999999983222784.000000
ITER 8: row=7, varin=59, theta=0.480149, up=999999999999999983222784.000000
ITER 9: row=52, varin=56, theta=0.515361, up=999999999999999983222784.000000
ITER 10: row=56, varin=55, theta=0.359188, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x31 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=113, theta=0.166601, up=1.000000
ITER 2: row=2, varin=5, theta=0.230567, up=999999999999999983222784.000000
ITER 3: row=13, varin=96, theta=0.191285, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 28720564.479348
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 62 rows, 60 cols, 315 nonzeros, 0 slack, 62 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 7 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=68, varin=13, theta=0.224555, up=999999999999999983222784.000000
ITER 2: row=4, varin=74, theta=1.287927, up=1.000000
ITER 3: row=4, varin=107, theta=0.355048, up=1.000000
ITER 4: row=67, varin=74, theta=0.703413, up=1.000000
ITER 5: row=4, varin=60, theta=0.010912, up=999999999999999983222784.000000
ITER 6: row=9, varin=67, theta=1.553580, up=999999999999999983222784.000000
ITER 7: row=67, varin=107, theta=1.893415, up=1.000000
ITER 8: row=67, varin=44, theta=0.087122, up=999999999999999983222784.000000
ITER 9: row=41, varin=36, theta=0.591053, up=999999999999999983222784.000000
ITER 10: row=29, varin=61, theta=0.633586, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=69)
DEBUG SOLUTION: LP solution array indices: FST[70-109], not_covered[110-129]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 69 rows, 60 cols, 339 nonzeros, 7 slack, 62 tight.
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 10 at 1000000000000000000.00000000000000000000
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6042690
% @LO 0.05  28.52756208580472829794 99.9000000000
% @LN 0.05  28.52881062871278317061 99.9000000000
% Resuming node 45 at  28.52881062871278317061
DEBUG CONSTRNT: LP rows=69, pool->nlprows=69, pool->npend=0
DEBUG CONSTRNT: Checking 69 LP rows (pool tracks 69, total LP rows 69)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 138
DEBUG CONSTRNT: Pool row 138 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=64, expected 64
DEBUG CONSTRNT: Checking LP row 65 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=65, expected 65
DEBUG CONSTRNT: Checking LP row 66 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=66, expected 66
DEBUG CONSTRNT: Checking LP row 67 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=67, expected 67
DEBUG CONSTRNT: Checking LP row 68 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=68, expected 68
 % @PAP adding 50 rows, 225 nz to LP
DEBUG BB: Processing node 45, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=29, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=39, varin=77, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28528810.628713
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 285 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 45 LP 1 Solution, length = 28528810.628713, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28528810.628713, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28528810.628713, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 45 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 45
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.500000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x26, Z0 = 28528810.6287128        , Z1 = 28557621.2574256        

DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=39, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=29, varin=50, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=21, varin=49, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28557621.257426
  % 	x26 = 1,	Z1 = 28557621.2574256        
DEBUG EVAL: First branch cutoff check: z=28557621.257426, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=32, varin=62, theta=0.333333, up=1.000000
  % 	x26 = 0,	Z0 = 28543064.7565112        
DEBUG EVAL: Second branch cutoff check: z=28543064.756511, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28543064.7565112        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=49, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28557621.257426
  % 	x10 = 1,	Z1 = 28557621.2574256        
DEBUG EVAL: First branch cutoff check: z=28557621.257426, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=20, varin=42, theta=3.000000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28546960.194753         
DEBUG EVAL: Second branch cutoff check: z=28546960.194753, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28546960.194753         
  % Best branch is x10, Z0 = 28546960.194753         , Z1 = 28557621.2574256        

DEBUG CAREFUL: Final result - returning best.var = 10
DEBUG BB: Branching variable chosen: j=10
 % @NC   49   45	x10 = 0	28546960.194753
 % @NC   50   45	x10 = 1	28557621.257426
 %      45    21 28528810.6287               28542788.6853    x3 D    33    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f605a130
% @LO 0.06  28.52881062871278317061 99.9000000000
% @LN 0.06  28.54278868525056012118 99.9000000000
% Resuming node 39 at  28.54278868525056012118
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=49, expected 49
 % @PAP adding 58 rows, 237 nz to LP
DEBUG BB: Processing node 39, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 39 LP 2 Solution, length = 28542788.685251, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.073891 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.073891 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.073891 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.482760 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.073891 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.073891 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.073891 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.073891 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.482760 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.517240 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.926109 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.926109 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.517240 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.926109 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.926109 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.926109 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.926109 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.926109 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28542788.685251, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28542788.685251, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 39 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 39
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.073891
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.073891)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.073891
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.073891)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.073891
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.073891)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.482760
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.482760)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.073891
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.073891)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.073891
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.073891)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.073891
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.073891)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.073891
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.073891)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.482760
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.482760)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[2] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[4] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[6] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[7] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[8] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x3, Z0 = 28542788.6852506        , Z1 = 29393407.0016118        

DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=47, varin=57, theta=2.950193, up=999999999999999983222784.000000
ITER 2: row=33, varin=22, theta=0.824104, up=999999999999999983222784.000000
ITER 3: row=50, varin=49, theta=0.963831, up=999999999999999983222784.000000
ITER 4: row=47, varin=81, theta=0.760571, up=1.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28879184.319065
  % 	x26 = 1,	Z1 = 28879184.3190651        
DEBUG EVAL: First branch cutoff check: z=28879184.319065, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=47, varin=84, theta=0.245352, up=1.000000
  % 	x26 = 0,	Z0 = 28547624.4093947        
DEBUG EVAL: Second branch cutoff check: z=28547624.409395, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28547624.4093947        
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=57, theta=2.950193, up=999999999999999983222784.000000
ITER 2: row=33, varin=41, theta=2.028961, up=999999999999999983222784.000000
ITER 3: row=41, varin=35, theta=1.110878, up=999999999999999983222784.000000
ITER 4: row=56, varin=81, theta=2.162885, up=1.000000
ITER 5: row=56, varin=84, theta=1.275439, up=1.000000
ITER 6: row=56, varin=87, theta=0.300377, up=1.000000
ITER 7: row=36, varin=51, theta=4.207830, up=999999999999999983222784.000000
ITER 8: row=46, varin=17, theta=2.513512, up=999999999999999983222784.000000
ITER 9: row=10, varin=6, theta=2.159182, up=999999999999999983222784.000000
ITER 10: row=2, varin=27, theta=3.770991, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x4 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=84, theta=0.245352, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28547624.409395
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 297 nonzeros, 0 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=60, varin=54, theta=0.086224, up=999999999999999983222784.000000
ITER 2: row=59, varin=83, theta=0.065149, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28552454.416726
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 60 rows, 60 cols, 314 nonzeros, 3 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 39 at  28.55245441672564865598
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f605a370
% @LO 0.06  28.54278868525056012118 99.9000000000
% @LN 0.06  28.54696019475298740531 99.9000000000
% Resuming node 49 at  28.54696019475298740531
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=56, expected 56
 % @PAP adding 50 rows, 225 nz to LP
DEBUG BB: Processing node 49, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=20, varin=42, theta=3.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28546960.194753
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 285 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 49 LP 1 Solution, length = 28546960.194753, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.500000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28546960.194753, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28546960.194753, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 49 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 49
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.500000
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x5, Z0 = 28546960.194753         , Z1 = 28546960.194753         

DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=75, theta=1.200000, up=1.000000
ITER 2: row=1, varin=74, theta=0.333333, up=1.000000
ITER 3: row=3, varin=75, theta=1.000000, up=1.000000
ITER 4: row=1, varin=43, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=32, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=29, varin=7, theta=2.500000, up=999999999999999983222784.000000
ITER 7: row=11, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=23, varin=74, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28660327.665978
  % 	x5 = 0,	Z0 = 28660327.6659782        
DEBUG EVAL: First branch cutoff check: z=28660327.665978, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=1, varin=49, theta=1.000000, up=999999999999999983222784.000000
  % 	x5 = 1,	Z1 = 28593920.389506         
DEBUG EVAL: Second branch cutoff check: z=28593920.389506, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28593920.389506         
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=75, theta=1.200000, up=1.000000
ITER 2: row=40, varin=74, theta=0.333333, up=1.000000
ITER 3: row=3, varin=75, theta=1.000000, up=1.000000
ITER 4: row=23, varin=40, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 0 gives z=28610838.016437
  % 	x36 = 0,	Z0 = 28610838.016437         
DEBUG EVAL: First branch cutoff check: z=28610838.016437, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 1
ITER 1: row=40, varin=49, theta=1.000000, up=999999999999999983222784.000000
  % 	x36 = 1,	Z1 = 28593920.389506         
DEBUG EVAL: Second branch cutoff check: z=28593920.389506, best_z=INF, threshold=INF
  % Best branch is x5, Z0 = 28660327.6659782        , Z1 = 28593920.389506         

DEBUG CAREFUL: Final result - returning best.var = 5
DEBUG BB: Branching variable chosen: j=5
 % @NC   51   49	x5 = 1	28593920.389506
 % @NC   52   49	x5 = 0	28660327.665978
 %      49    22 28546960.1948               28552454.4167   x10 D    45    12
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f605a130
% @LO 0.06  28.54696019475298740531 99.9000000000
% @LN 0.06  28.55245441672564865598 99.9000000000
% Resuming node 39 at  28.55245441672564865598
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=49, expected 49
 % @PAP adding 57 rows, 248 nz to LP
DEBUG BB: Processing node 39, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 39 LP 3 Solution, length = 28552454.416726, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.086970 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.086970 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.086970 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.086970 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.086970 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.065149 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.086970 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.913030 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.913030 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.913030 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.913030 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.913030 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.913030 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.913030 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28552454.416726, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28552454.416726, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 39 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 39
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.086970
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.086970)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.086970
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.086970)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.086970
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.086970)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.086970
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.086970)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.086970
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.086970)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.065149
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.065149)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.086970
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.086970)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[2] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[4] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[5] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[6] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[7] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[8] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x3, Z0 = 28552454.4167257        , Z1 = 29393407.0016118        

DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=44, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28897964.373692
  % 	x34 = 1,	Z1 = 28897964.3736918        
DEBUG EVAL: First branch cutoff check: z=28897964.373692, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=44, varin=57, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=46, varin=56, theta=0.277626, up=999999999999999983222784.000000
ITER 3: row=56, varin=54, theta=0.259059, up=999999999999999983222784.000000
ITER 4: row=54, varin=23, theta=0.315997, up=999999999999999983222784.000000
ITER 5: row=23, varin=44, theta=0.214408, up=999999999999999983222784.000000
  % 	x34 = 0,	Z0 = 28609913.0732237        
DEBUG EVAL: Second branch cutoff check: z=28609913.073224, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28609913.0732237        
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=44, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28791228.533528
  % 	x5 = 1,	Z1 = 28791228.533528         
DEBUG EVAL: First branch cutoff check: z=28791228.533528, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=33, varin=57, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=46, varin=56, theta=0.277626, up=999999999999999983222784.000000
ITER 3: row=56, varin=54, theta=0.259059, up=999999999999999983222784.000000
ITER 4: row=54, varin=23, theta=0.315997, up=999999999999999983222784.000000
ITER 5: row=23, varin=41, theta=0.169893, up=999999999999999983222784.000000
ITER 6: row=36, varin=51, theta=0.333717, up=999999999999999983222784.000000
ITER 7: row=41, varin=47, theta=0.000252, up=999999999999999983222784.000000
  % 	x5 = 0,	Z0 = 28618535.5926944        
DEBUG EVAL: Second branch cutoff check: z=28618535.592694, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28618535.5926944        
DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=46, varin=56, theta=0.988369, up=999999999999999983222784.000000
ITER 2: row=56, varin=54, theta=0.922270, up=999999999999999983222784.000000
ITER 3: row=54, varin=23, theta=1.124970, up=999999999999999983222784.000000
ITER 4: row=23, varin=41, theta=0.604830, up=999999999999999983222784.000000
ITER 5: row=36, varin=51, theta=1.188055, up=999999999999999983222784.000000
ITER 6: row=41, varin=47, theta=0.891026, up=999999999999999983222784.000000
ITER 7: row=47, varin=17, theta=0.559810, up=999999999999999983222784.000000
ITER 8: row=10, varin=6, theta=0.508674, up=999999999999999983222784.000000
ITER 9: row=2, varin=46, theta=580675.500000, up=999999999999999983222784.000000
ITER 10: row=25, varin=44, theta=1.028522, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=28801351.165734
  % 	x22 = 1,	Z1 = 28801351.1657338        
DEBUG EVAL: First branch cutoff check: z=28801351.165734, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=46, varin=57, theta=0.198780, up=999999999999999983222784.000000
  % 	x22 = 0,	Z0 = 28554039.3003737        
DEBUG EVAL: Second branch cutoff check: z=28554039.300374, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=47, varin=56, theta=84.309512, up=999999999999999983222784.000000
ITER 2: row=56, varin=57, theta=5.515182, up=999999999999999983222784.000000
ITER 3: row=33, varin=22, theta=0.776963, up=999999999999999983222784.000000
ITER 4: row=50, varin=49, theta=0.954689, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28880067.030336
  % 	x26 = 1,	Z1 = 28880067.0303363        
DEBUG EVAL: First branch cutoff check: z=28880067.030336, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=47, varin=86, theta=4.322856, up=1.000000
ITER 2: row=47, varin=47, theta=0.067745, up=999999999999999983222784.000000
ITER 3: row=39, varin=86, theta=1.000000, up=1.000000
  % 	x26 = 0,	Z0 = 28572911.794569         
DEBUG EVAL: Second branch cutoff check: z=28572911.794569, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=56, theta=84.309512, up=999999999999999983222784.000000
ITER 2: row=56, varin=57, theta=5.515182, up=999999999999999983222784.000000
ITER 3: row=33, varin=42, theta=1.174090, up=999999999999999983222784.000000
ITER 4: row=52, varin=17, theta=2.406553, up=999999999999999983222784.000000
ITER 5: row=10, varin=6, theta=2.058900, up=999999999999999983222784.000000
ITER 6: row=2, varin=27, theta=3.887431, up=999999999999999983222784.000000
ITER 7: row=20, varin=37, theta=1.323147, up=999999999999999983222784.000000
ITER 8: row=53, varin=45, theta=5.785288, up=999999999999999983222784.000000
ITER 9: row=1, varin=44, theta=5.330652, up=999999999999999983222784.000000
ITER 10: row=44, varin=49, theta=1.163069, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x11 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=51, theta=0.114831, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28572447.082957
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 308 nonzeros, 3 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=85, theta=0.045511, up=1.000000
ITER 2: row=39, varin=84, theta=0.045295, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28575223.461909
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 306 nonzeros, 0 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 39 at  28.57522346190850370817
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6070ba0
% @LO 0.06  28.55245441672564865598 99.9000000000
% @LN 0.06  28.55762125742556989394 99.9000000000
% Resuming node 50 at  28.55762125742556989394
DEBUG CONSTRNT: LP rows=56, pool->nlprows=56, pool->npend=0
DEBUG CONSTRNT: Checking 56 LP rows (pool tracks 56, total LP rows 56)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=55, expected 55
 % @PAP adding 50 rows, 225 nz to LP
DEBUG BB: Processing node 50, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=20, varin=49, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28557621.257426
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 285 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=63, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28564597.134767
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 287 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=59, theta=0.500000, up=1.000000
ITER 2: row=52, varin=43, theta=0.066667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28582487.054480
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 269 nonzeros, 4 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=49, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28593540.212627
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 266 nonzeros, 2 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 50 LP 1 Solution, length = 28593540.212627, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.200000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.200000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.200000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.200000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.800000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.800000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.800000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.800000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28593540.212627, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 50 at  28.59354021262722511665
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6040360
% @LO 0.06  28.55762125742556989394 99.9000000000
% @LN 0.06  28.56877685963085156118 99.9000000000
% Resuming node 35 at  28.56877685963085156118
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=50, expected 50
 % @PAP adding 50 rows, 179 nz to LP
DEBUG BB: Processing node 35, calling compute_good_lower_bound
LP PHASE: Starting primal phase (iter=0)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28568776.859631
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 239 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 35 LP 2 Solution, length = 28568776.859631, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.100000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.100000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.100000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.100000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.100000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.100000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.100000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.900000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.900000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.900000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.900000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.900000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.900000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.900000 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28568776.859631, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28568776.859631, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 35 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 35
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.100000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.100000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.100000
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.100000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.100000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.100000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.100000
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[5] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[7] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[8] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 37
  % Initial guess is x4, Z0 = 28568776.8596309        , Z1 = 28841548.7824399        

DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28963142.608915
  % 	x34 = 1,	Z1 = 28963142.6089147        
DEBUG EVAL: First branch cutoff check: z=28963142.608915, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=38, varin=43, theta=1.000000, up=999999999999999983222784.000000
  % 	x34 = 0,	Z0 = 28658699.3527079        
DEBUG EVAL: Second branch cutoff check: z=28658699.352708, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28658699.3527079        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28767250.895824
  % 	x7 = 0,	Z0 = 28767250.8958237        
DEBUG EVAL: First branch cutoff check: z=28767250.895824, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=34, varin=43, theta=1.000000, up=999999999999999983222784.000000
  % 	x7 = 1,	Z1 = 28658699.3527079        
DEBUG EVAL: Second branch cutoff check: z=28658699.352708, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=72, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28580062.363122
  % 	x3 = 0,	Z0 = 28580062.3631219        
DEBUG EVAL: First branch cutoff check: z=28580062.363122, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=45, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=50, varin=72, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28580062.363122
  % 	x10 = 0,	Z0 = 28580062.3631219        
DEBUG EVAL: First branch cutoff check: z=28580062.363122, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=44, varin=45, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=50, varin=47, theta=4.500000, up=999999999999999983222784.000000
ITER 3: row=45, varin=49, theta=1.750000, up=999999999999999983222784.000000
ITER 4: row=1, varin=23, theta=1.500000, up=999999999999999983222784.000000
ITER 5: row=23, varin=37, theta=1.500000, up=999999999999999983222784.000000
ITER 6: row=44, varin=46, theta=0.166667, up=999999999999999983222784.000000
ITER 7: row=36, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28853390.148662
  % 	x11 = 1,	Z1 = 28853390.1486623        
DEBUG EVAL: First branch cutoff check: z=28853390.148662, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=44, varin=72, theta=0.500000, up=1.000000
  % 	x11 = 0,	Z0 = 28580062.3631219        
DEBUG EVAL: Second branch cutoff check: z=28580062.363122, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=47, theta=4.500000, up=999999999999999983222784.000000
ITER 2: row=45, varin=23, theta=3.500000, up=999999999999999983222784.000000
ITER 3: row=23, varin=36, theta=1.166667, up=999999999999999983222784.000000
ITER 4: row=21, varin=44, theta=0.250000, up=999999999999999983222784.000000
ITER 5: row=44, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=29134889.886894
  % 	x4 = 1,	Z1 = 29134889.8868936        
DEBUG EVAL: First branch cutoff check: z=29134889.886894, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=36, varin=45, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=50, varin=49, theta=0.166667, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28579730.0205643        
DEBUG EVAL: Second branch cutoff check: z=28579730.020564, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=47, theta=4.500000, up=999999999999999983222784.000000
ITER 2: row=45, varin=46, theta=0.875000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28796106.427534
  % 	x2 = 1,	Z1 = 28796106.4275339        
DEBUG EVAL: First branch cutoff check: z=28796106.427534, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=45, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=50, varin=49, theta=0.166667, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28579730.0205643        
DEBUG EVAL: Second branch cutoff check: z=28579730.020564, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=45, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=50, varin=72, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28580062.363122
  % 	x26 = 0,	Z0 = 28580062.3631219        
DEBUG EVAL: First branch cutoff check: z=28580062.363122, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 37 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=45, varin=49, theta=1.125000, up=999999999999999983222784.000000
ITER 2: row=1, varin=46, theta=0.125000, up=999999999999999983222784.000000
ITER 3: row=21, varin=23, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=23, varin=45, theta=0.250000, up=999999999999999983222784.000000
ITER 5: row=36, varin=44, theta=0.250000, up=999999999999999983222784.000000
ITER 6: row=44, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 37 = 1 gives z=28695095.465580
  % 	x37 = 1,	Z1 = 28695095.4655803        
DEBUG EVAL: First branch cutoff check: z=28695095.465580, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 37 = 0
ITER 1: row=45, varin=47, theta=0.125000, up=999999999999999983222784.000000
  % 	x37 = 0,	Z0 = 28571430.0027           
DEBUG EVAL: Second branch cutoff check: z=28571430.002700, best_z=INF, threshold=INF
  % Best branch is x34, Z0 = 28658699.3527079        , Z1 = 28963142.6089147        

DEBUG CAREFUL: Final result - returning best.var = 34
DEBUG BB: Branching variable chosen: j=34
 % @NC   53   35	x34 = 0	28658699.352708
 % @NC   54   35	x34 = 1	28963142.608915
 %      35    23 28568776.8596               28573601.4048   x36 D    21     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f605a7a0
% @LO 0.06  28.56877685963085156118 99.9000000000
% @LN 0.06  28.57360140477025467476 99.9000000000
% Resuming node 34 at  28.57360140477025467476
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=49, expected 49
 % @PAP adding 48 rows, 206 nz to LP
DEBUG BB: Processing node 34, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=43, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=20, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=30, varin=5, theta=2.619907, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28573601.404770
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.126698
DEBUG SOLUTION: lp->best_solution[3] = 0.126698
DEBUG SOLUTION: lp->best_solution[4] = 0.126698
DEBUG SOLUTION: lp->best_solution[5] = 0.380093
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 266 nonzeros, 8 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=51, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=5, varin=30, theta=586979.000000, up=999999999999999983222784.000000
ITER 4: row=30, varin=70, theta=0.500000, up=1.000000
ITER 5: row=5, varin=54, theta=0.656024, up=1.000000
ITER 6: row=7, varin=55, theta=0.649550, up=1.000000
ITER 7: row=21, varin=59, theta=0.798485, up=1.000000
ITER 8: row=46, varin=53, theta=1.666434, up=1.000000
ITER 9: row=46, varin=56, theta=0.364394, up=1.000000
ITER 10: row=6, varin=53, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=19)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28975919.089124
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 286 nonzeros, 6 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 6 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=55, theta=0.117427, up=1.000000
ITER 2: row=49, varin=75, theta=0.823782, up=1.000000
ITER 3: row=20, varin=54, theta=0.085778, up=1.000000
ITER 4: row=7, varin=63, theta=0.048419, up=1.000000
ITER 5: row=24, varin=59, theta=0.058207, up=1.000000
ITER 6: row=42, varin=107, theta=0.037452, up=1.000000
ITER 7: row=41, varin=56, theta=0.049200, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 29100799.759850
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 283 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=82, theta=1.039040, up=1.000000
ITER 2: row=55, varin=80, theta=0.097216, up=1.000000
ITER 3: row=52, varin=82, theta=1.000000, up=1.000000
ITER 4: row=55, varin=74, theta=0.118958, up=1.000000
ITER 5: row=54, varin=85, theta=0.909170, up=1.000000
ITER 6: row=25, varin=80, theta=1.000000, up=1.000000
ITER 7: row=54, varin=84, theta=0.269552, up=1.000000
ITER 8: row=21, varin=34, theta=0.052516, up=999999999999999983222784.000000
ITER 9: row=1, varin=39, theta=0.057187, up=999999999999999983222784.000000
ITER 10: row=55, varin=41, theta=0.105182, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 299 nonzeros, 4 slack, 52 tight.
  % Node 34 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.049200 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 1.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.901599 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 34 is INFEASIBLE
 %      34    22    infeasible               28575223.4619   x18 U    31    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f605a130
% @LO 0.06  28.57360140477025467476 99.9000000000
% @LN 0.06  28.57522346190850370817 99.9000000000
% Resuming node 39 at  28.57522346190850370817
DEBUG CONSTRNT: LP rows=56, pool->nlprows=56, pool->npend=0
DEBUG CONSTRNT: Checking 56 LP rows (pool tracks 56, total LP rows 56)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=55, expected 55
 % @PAP adding 56 rows, 246 nz to LP
DEBUG BB: Processing node 39, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 39 LP 4 Solution, length = 28575223.461909, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.113676 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.113676 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.113676 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.113676 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.113676 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.113676 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.045295 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.886324 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.886324 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.886324 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.886324 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.886324 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.886324 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.886324 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28575223.461909, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28575223.461909, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 39 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 39
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.113676
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.113676)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.113676
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.113676)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.113676
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.113676)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.113676
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.113676)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.113676
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.113676)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.113676
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.113676)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.045295
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.045295)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[2] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[4] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[5] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[6] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[7] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[8] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x5, Z0 = 28618535.5926944        , Z1 = 28791228.533528         

DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=44, varin=54, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=39, theta=0.373319, up=999999999999999983222784.000000
ITER 3: row=39, varin=55, theta=0.333652, up=999999999999999983222784.000000
ITER 4: row=41, varin=53, theta=0.000250, up=999999999999999983222784.000000
ITER 5: row=53, varin=51, theta=0.000236, up=999999999999999983222784.000000
ITER 6: row=51, varin=23, theta=0.000276, up=999999999999999983222784.000000
ITER 7: row=23, varin=44, theta=0.000246, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28618519.276763
  % 	x34 = 0,	Z0 = 28618519.2767629        
DEBUG EVAL: First branch cutoff check: z=28618519.276763, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=54, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=39, theta=0.373319, up=999999999999999983222784.000000
ITER 3: row=39, varin=55, theta=0.333652, up=999999999999999983222784.000000
ITER 4: row=41, varin=53, theta=0.000250, up=999999999999999983222784.000000
ITER 5: row=53, varin=51, theta=0.000236, up=999999999999999983222784.000000
ITER 6: row=51, varin=23, theta=0.000276, up=999999999999999983222784.000000
ITER 7: row=23, varin=41, theta=0.000235, up=999999999999999983222784.000000
ITER 8: row=36, varin=47, theta=0.000252, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28618535.592694
  % 	x5 = 0,	Z0 = 28618535.5926944        
DEBUG EVAL: First branch cutoff check: z=28618535.592694, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=33, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=94, theta=0.175455, up=1.000000
ITER 3: row=46, varin=88, theta=0.175045, up=1.000000
ITER 4: row=47, varin=22, theta=0.023575, up=999999999999999983222784.000000
ITER 5: row=41, varin=94, theta=-0.175045, up=1.000000
ITER 6: row=41, varin=86, theta=0.748494, up=1.000000
ITER 7: row=18, varin=35, theta=0.034972, up=999999999999999983222784.000000
ITER 8: row=43, varin=41, theta=0.024809, up=999999999999999983222784.000000
ITER 9: row=1, varin=89, theta=-2.886923, up=1.000000
ITER 10: row=1, varin=17, theta=0.070446, up=999999999999999983222784.000000
  % 	x5 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=54, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=39, theta=0.373319, up=999999999999999983222784.000000
ITER 3: row=39, varin=55, theta=0.333652, up=999999999999999983222784.000000
ITER 4: row=41, varin=53, theta=0.000250, up=999999999999999983222784.000000
ITER 5: row=53, varin=51, theta=0.000236, up=999999999999999983222784.000000
ITER 6: row=51, varin=23, theta=0.000276, up=999999999999999983222784.000000
ITER 7: row=23, varin=41, theta=0.000235, up=999999999999999983222784.000000
ITER 8: row=36, varin=47, theta=0.000252, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28618535.592694
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 306 nonzeros, 6 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 6 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 39 at  28.61853559269436075851
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60410f0
% @LO 0.06  28.57522346190850370817 99.9000000000
% @LN 0.06  28.59261265083862468828 99.9000000000
% Resuming node 43 at  28.59261265083862468828
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=49, expected 49
 % @PAP adding 54 rows, 228 nz to LP
DEBUG BB: Processing node 43, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=41, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28592612.650839
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 288 nonzeros, 1 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 43 LP 1 Solution, length = 28592612.650839, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.071377 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.428623 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.428623 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.428623 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.571377 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.571377 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.571377 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.571377 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.571377 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.571377 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28592612.650839, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28592612.650839, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 43 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 43
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.071377
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.071377)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.428623
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.428623)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.428623
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.428623)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.428623
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.428623)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x18, Z0 = 28592612.6508386        , Z1 = 34622836.6510184        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=52, theta=1.088609, up=999999999999999983222784.000000
ITER 2: row=24, varin=47, theta=0.246469, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28664380.952854
  % 	x3 = 1,	Z1 = 28664380.9528536        
DEBUG EVAL: First branch cutoff check: z=28664380.952854, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=1, varin=91, theta=0.156472, up=1.000000
  % 	x3 = 0,	Z0 = 28593186.179925         
DEBUG EVAL: Second branch cutoff check: z=28593186.179925, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28593186.179925         
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=40, theta=0.817661, up=999999999999999983222784.000000
ITER 2: row=44, varin=39, theta=0.981712, up=999999999999999983222784.000000
ITER 3: row=53, varin=30, theta=1.228116, up=999999999999999983222784.000000
ITER 4: row=1, varin=42, theta=3.047699, up=999999999999999983222784.000000
ITER 5: row=42, varin=81, theta=0.478494, up=1.000000
ITER 6: row=24, varin=58, theta=0.795361, up=1.000000
ITER 7: row=42, varin=52, theta=0.172117, up=999999999999999983222784.000000
ITER 8: row=39, varin=79, theta=3.387804, up=1.000000
ITER 9: row=39, varin=76, theta=0.316709, up=1.000000
ITER 10: row=3, varin=79, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 1 gives z=29397288.075972
  % 	x17 = 1,	Z1 = 29397288.075972         
DEBUG EVAL: First branch cutoff check: z=29397288.075972, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=29, varin=46, theta=0.525552, up=999999999999999983222784.000000
  % 	x17 = 0,	Z0 = 28663760.9811453        
DEBUG EVAL: Second branch cutoff check: z=28663760.981145, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28663760.9811453        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=38, theta=2.418396, up=999999999999999983222784.000000
ITER 2: row=54, varin=46, theta=3.098037, up=999999999999999983222784.000000
ITER 3: row=29, varin=42, theta=2.037568, up=999999999999999983222784.000000
ITER 4: row=42, varin=81, theta=5.799684, up=1.000000
ITER 5: row=42, varin=79, theta=27.526291, up=1.000000
ITER 6: row=42, varin=76, theta=3.518340, up=1.000000
ITER 7: row=42, varin=30, theta=1.848569, up=999999999999999983222784.000000
ITER 8: row=3, varin=79, theta=1.000000, up=1.000000
ITER 9: row=34, varin=76, theta=1.000000, up=1.000000
ITER 10: row=24, varin=77, theta=2.386594, up=1.000000
DEBUG EVAL: Branch var 18 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=52, theta=1.214105, up=999999999999999983222784.000000
ITER 2: row=24, varin=47, theta=0.246469, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
ITER 3: row=29, varin=65, theta=0.654585, up=1.000000
ITER 4: row=41, varin=91, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28620426.149975
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 288 nonzeros, 5 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=40, theta=0.349170, up=999999999999999983222784.000000
ITER 2: row=53, varin=90, theta=1.241543, up=1.000000
ITER 3: row=53, varin=39, theta=0.015702, up=999999999999999983222784.000000
ITER 4: row=44, varin=80, theta=0.560439, up=1.000000
ITER 5: row=3, varin=97, theta=0.142468, up=1.000000
ITER 6: row=6, varin=100, theta=0.088285, up=1.000000
ITER 7: row=16, varin=29, theta=148986.000000, up=999999999999999983222784.000000
ITER 8: row=11, varin=6, theta=0.232135, up=999999999999999983222784.000000
ITER 9: row=12, varin=109, theta=0.166170, up=1.000000
% Column 60 singular!
% SINGULAR BASIS!  Will attempt to recover.
LP PHASE: Starting dual phase (iter=9)
ITER 10: row=29, varin=115, theta=0.786353, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28732298.261902
DEBUG SOLUTION: lp->best_solution[1] = 19.047477
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 309 nonzeros, 5 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 3 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=73, theta=4.250000, up=1.000000
ITER 2: row=1, varin=64, theta=6.500000, up=1.000000
ITER 3: row=1, varin=69, theta=3.666667, up=1.000000
ITER 4: row=1, varin=68, theta=2.666667, up=1.000000
ITER 5: row=1, varin=61, theta=2.500000, up=1.000000
ITER 6: row=1, varin=94, theta=3.000000, up=1.000000
ITER 7: row=1, varin=95, theta=2.000000, up=1.000000
ITER 8: row=1, varin=96, theta=1.000000, up=1.000000
ITER 9: row=28, varin=94, theta=1.000000, up=1.000000
ITER 10: row=31, varin=68, theta=3.000000, up=1.000000
LP PHASE: Switching to primal (iter=48)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28686433.046543
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 268 nonzeros, 2 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 5 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=93, theta=0.222222, up=1.000000
ITER 2: row=54, varin=58, theta=2.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28692319.489250
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 289 nonzeros, 2 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 43 at  28.69231948924991471017
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6070ba0
% @LO 0.06  28.59261265083862468828 99.9000000000
% @LN 0.06  28.59354021262722511665 99.9000000000
% Resuming node 50 at  28.59354021262722511665
DEBUG CONSTRNT: LP rows=58, pool->nlprows=58, pool->npend=0
DEBUG CONSTRNT: Checking 58 LP rows (pool tracks 58, total LP rows 58)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=57, expected 57
 % @PAP adding 51 rows, 189 nz to LP
DEBUG BB: Processing node 50, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 50 LP 2 Solution, length = 28593540.212627, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.200000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.200000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.200000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.200000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.800000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.800000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.800000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.800000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28593540.212627, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28593540.212627, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 50 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 50
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.200000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.200000
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.200000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.200000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[3] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
  % Initial guess is x4, Z0 = 28593540.2126272        , Z1 = 28870379.7723901        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=50, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=21, varin=48, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28684585.842790
  % 	x17 = 1,	Z1 = 28684585.8427904        
DEBUG EVAL: First branch cutoff check: z=28684585.842790, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=35, varin=102, theta=0.789474, up=1.000000
ITER 2: row=2, varin=75, theta=2.000000, up=1.000000
ITER 3: row=2, varin=36, theta=0.250000, up=999999999999999983222784.000000
ITER 4: row=23, varin=76, theta=1.000000, up=1.000000
ITER 5: row=3, varin=75, theta=1.000000, up=1.000000
ITER 6: row=49, varin=89, theta=1.000000, up=1.000000
  % 	x17 = 0,	Z0 = 28716981.3421297        
DEBUG EVAL: Second branch cutoff check: z=28716981.342130, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28684585.8427904        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=46, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28614252.440465
  % 	x2 = 0,	Z0 = 28614252.4404653        
DEBUG EVAL: First branch cutoff check: z=28614252.440465, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=48, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=48, varin=47, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=47, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=29, varin=46, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=17, theta=0.441176, up=999999999999999983222784.000000
ITER 6: row=10, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=43, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=40, varin=6, theta=0.384615, up=999999999999999983222784.000000
ITER 9: row=6, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=51, varin=7, theta=0.483871, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28986949.977248
  % 	x4 = 1,	Z1 = 28986949.9772478        
DEBUG EVAL: First branch cutoff check: z=28986949.977248, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=21, varin=50, theta=0.333333, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28604593.3707747        
DEBUG EVAL: Second branch cutoff check: z=28604593.370775, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=48, varin=50, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=21, varin=47, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=47, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=29, varin=46, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=17, theta=0.441176, up=999999999999999983222784.000000
ITER 6: row=10, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=43, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=40, varin=6, theta=0.384615, up=999999999999999983222784.000000
ITER 9: row=6, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=49, varin=7, theta=0.483871, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28962223.295969
  % 	x11 = 1,	Z1 = 28962223.2959695        
DEBUG EVAL: First branch cutoff check: z=28962223.295969, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=48, varin=48, theta=0.333333, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28612835.5978675        
DEBUG EVAL: Second branch cutoff check: z=28612835.597867, best_z=INF, threshold=INF
  % Best branch is x17, Z0 = 28716981.3421297        , Z1 = 28684585.8427904        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC   55   50	x17 = 1	28684585.842790
 % @NC   56   50	x17 = 0	28716981.342130
 %      50    23 28593540.2126               28593920.3895   x10 U    45    12
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6042690
% @LO 0.06  28.59354021262722511665 99.9000000000
% @LN 0.06  28.59392038950597481062 99.9000000000
% Resuming node 51 at  28.59392038950597481062
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=50, expected 50
 % @PAP adding 50 rows, 225 nz to LP
DEBUG BB: Processing node 51, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=49, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28593920.389506
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 285 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=40, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28721676.032874
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 289 nonzeros, 5 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=62, theta=0.500000, up=1.000000
ITER 2: row=50, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=27, theta=0.058824, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28746927.139065
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 251 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 5 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=80, theta=1.125000, up=1.000000
ITER 2: row=49, varin=58, theta=0.058824, up=1.000000
ITER 3: row=46, varin=80, theta=1.000000, up=1.000000
ITER 4: row=50, varin=39, theta=0.070866, up=999999999999999983222784.000000
ITER 5: row=53, varin=49, theta=0.007874, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28767433.776090
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 271 nonzeros, 6 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 5 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=103, theta=0.789474, up=1.000000
ITER 2: row=2, varin=76, theta=2.000000, up=1.000000
ITER 3: row=2, varin=45, theta=1.021739, up=999999999999999983222784.000000
ITER 4: row=23, varin=76, theta=1.000000, up=1.000000
ITER 5: row=48, varin=46, theta=1.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28842500.480152
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 268 nonzeros, 3 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=75, theta=0.285667, up=1.000000
ITER 2: row=3, varin=88, theta=0.298143, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28853989.596629
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 281 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=75, theta=0.140252, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28854047.646715
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 291 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=82, theta=0.148787, up=1.000000
ITER 2: row=40, varin=29, theta=0.013581, up=999999999999999983222784.000000
ITER 3: row=56, varin=79, theta=0.141890, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28860681.471077
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 305 nonzeros, 0 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 51 LP 1 Solution, length = 28860681.471077, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.214528 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.214528 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.214528 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.214528 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.141890 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.785472 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.785472 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.785472 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.785472 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.785472 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28860681.471077, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 51 at  28.86068147107734560564
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6055740
% @LO 0.06  28.59392038950597481062 99.9000000000
% @LN 0.06  28.60021943909494268610 99.9000000000
% Resuming node 29 at  28.60021943909494268610
DEBUG CONSTRNT: LP rows=56, pool->nlprows=56, pool->npend=0
DEBUG CONSTRNT: Checking 56 LP rows (pool tracks 56, total LP rows 56)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=55, expected 55
 % @PAP adding 57 rows, 209 nz to LP
DEBUG BB: Processing node 29, calling compute_good_lower_bound
LP PHASE: Starting primal phase (iter=0)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28600219.439095
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
  % @PL 57 rows, 60 cols, 269 nonzeros, 0 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 29 LP 3 Solution, length = 28600219.439095, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.142857 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.142857 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.142857 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.142857 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.142857 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.142857 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.142857 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.142857 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.142857 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.142857 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.142857 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.142857 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.142857 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.857143 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.857143 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.857143 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.857143 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.857143 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.857143 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.857143 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.857143 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.857143 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 13 fractional variables
DEBUG CG: LP optimal, z=28600219.439095, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28600219.439095, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 29 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 29
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.142857
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.142857
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.142857
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.142857
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.142857
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.142857
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.142857
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.142857
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.142857
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.142857
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.142857
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.142857
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.142857
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 13 fractional variables

  %  Carefully choosing branching variable, nfrac = 13
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[2] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[3] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[4] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[5] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[6] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[7] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 33
DEBUG CAREFUL: Testing fvar[8] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[9] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 30
DEBUG CAREFUL: New best var: 30
DEBUG CAREFUL: Testing fvar[10] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[11] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[12] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
  % Initial guess is x30, Z0 = 28600219.4390949        , Z1 = 28615899.6805396        

DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=3, theta=0.166667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28609140.292187
  % 	x34 = 0,	Z0 = 28609140.2921872        
DEBUG EVAL: First branch cutoff check: z=28609140.292187, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 1
ITER 1: row=35, varin=51, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=50, varin=36, theta=0.750000, up=999999999999999983222784.000000
  % 	x34 = 1,	Z1 = 28756653.5394011        
DEBUG EVAL: Second branch cutoff check: z=28756653.539401, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28609140.2921872        
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=3, theta=0.166667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 0 gives z=28609140.292187
  % 	x36 = 0,	Z0 = 28609140.2921872        
DEBUG EVAL: First branch cutoff check: z=28609140.292187, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 1
ITER 1: row=34, varin=51, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=50, varin=25, theta=0.428571, up=999999999999999983222784.000000
ITER 3: row=24, varin=54, theta=2.333333, up=999999999999999983222784.000000
ITER 4: row=41, varin=50, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=48, varin=71, theta=3.000000, up=1.000000
ITER 6: row=48, varin=49, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=30, varin=71, theta=1.000000, up=1.000000
  % 	x36 = 1,	Z1 = 28888614.0667028        
DEBUG EVAL: Second branch cutoff check: z=28888614.066703, best_z=INF, threshold=INF
  %   New best:  x36, Z = 28609140.2921872        
DEBUG EVAL: Testing var 31 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=48, varin=51, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 0 gives z=28609734.754583
  % 	x31 = 0,	Z0 = 28609734.7545828        
DEBUG EVAL: First branch cutoff check: z=28609734.754583, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 1
ITER 1: row=48, varin=56, theta=1.200000, up=999999999999999983222784.000000
ITER 2: row=6, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=3, varin=54, theta=0.777778, up=999999999999999983222784.000000
ITER 4: row=41, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=50, varin=71, theta=1.000000, up=1.000000
ITER 6: row=30, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=8, varin=53, theta=0.470588, up=999999999999999983222784.000000
ITER 8: row=22, varin=11, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=11, varin=48, theta=1.000000, up=999999999999999983222784.000000
  % 	x31 = 1,	Z1 = 28781392.9899966        
DEBUG EVAL: Second branch cutoff check: z=28781392.989997, best_z=INF, threshold=INF
  %   New best:  x31, Z = 28609734.7545828        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=56, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28614663.746042
  % 	x0 = 0,	Z0 = 28614663.746042         
DEBUG EVAL: First branch cutoff check: z=28614663.746042, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=51, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=50, varin=3, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=3, varin=54, theta=1.555556, up=999999999999999983222784.000000
ITER 4: row=41, varin=50, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=48, varin=71, theta=2.000000, up=1.000000
ITER 6: row=48, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=30, varin=71, theta=1.000000, up=1.000000
ITER 8: row=8, varin=53, theta=0.470588, up=999999999999999983222784.000000
ITER 9: row=22, varin=11, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 28925539.2039083        
DEBUG EVAL: Second branch cutoff check: z=28925539.203908, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28614663.746042         
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=56, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28614663.746042
  % 	x29 = 0,	Z0 = 28614663.746042         
DEBUG EVAL: First branch cutoff check: z=28614663.746042, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=11, varin=51, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=50, varin=3, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=3, varin=54, theta=1.555556, up=999999999999999983222784.000000
ITER 4: row=41, varin=50, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=48, varin=71, theta=2.000000, up=1.000000
ITER 6: row=48, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=30, varin=71, theta=1.000000, up=1.000000
ITER 8: row=8, varin=53, theta=0.470588, up=999999999999999983222784.000000
ITER 9: row=22, varin=48, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=47, varin=4, theta=1.000000, up=999999999999999983222784.000000
  % 	x29 = 1,	Z1 = 28948058.475684         
DEBUG EVAL: Second branch cutoff check: z=28948058.475684, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28614663.746042         
DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=3, theta=0.166667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 24 = 0 gives z=28609140.292187
  % 	x24 = 0,	Z0 = 28609140.2921872        
DEBUG EVAL: First branch cutoff check: z=28609140.292187, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=56, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28614663.746042
  % 	x1 = 0,	Z0 = 28614663.746042         
DEBUG EVAL: First branch cutoff check: z=28614663.746042, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=51, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=50, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=14, varin=3, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=3, varin=54, theta=1.555556, up=999999999999999983222784.000000
ITER 5: row=41, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=10, varin=50, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=48, varin=71, theta=2.000000, up=1.000000
ITER 8: row=48, varin=14, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=30, varin=71, theta=1.000000, up=1.000000
ITER 10: row=8, varin=53, theta=0.470588, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28888886.3836696        
DEBUG EVAL: Second branch cutoff check: z=28888886.383670, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 33 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=56, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 0 gives z=28614663.746042
  % 	x33 = 0,	Z0 = 28614663.746042         
DEBUG EVAL: First branch cutoff check: z=28614663.746042, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 1
ITER 1: row=4, varin=51, theta=2.000000, up=999999999999999983222784.000000
  % 	x33 = 1,	Z1 = 28676341.9629981        
DEBUG EVAL: Second branch cutoff check: z=28676341.962998, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=3, theta=0.166667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28609140.292187
  % 	x23 = 0,	Z0 = 28609140.2921872        
DEBUG EVAL: First branch cutoff check: z=28609140.292187, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=51, theta=2.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=28676341.962998
  % 	x30 = 1,	Z1 = 28676341.9629981        
DEBUG EVAL: First branch cutoff check: z=28676341.962998, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=8, varin=8, theta=0.166667, up=999999999999999983222784.000000
  % 	x30 = 0,	Z0 = 28614501.3738323        
DEBUG EVAL: Second branch cutoff check: z=28614501.373832, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 32 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=50, varin=51, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 0 gives z=28609734.754583
  % 	x32 = 0,	Z0 = 28609734.7545828        
DEBUG EVAL: First branch cutoff check: z=28609734.754583, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=51, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28609734.754583
  % 	x2 = 0,	Z0 = 28609734.7545828        
DEBUG EVAL: First branch cutoff check: z=28609734.754583, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=47, varin=51, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 0 gives z=28609734.754583
  % 	x27 = 0,	Z0 = 28609734.7545828        
DEBUG EVAL: First branch cutoff check: z=28609734.754583, best_z=INF, threshold=INF
  % Best branch is x29, Z0 = 28614663.746042         , Z1 = 28948058.475684         

DEBUG CAREFUL: Final result - returning best.var = 29
DEBUG BB: Branching variable chosen: j=29
 % @NC   57   29	x29 = 0	28614663.746042
 % @NC   58   29	x29 = 1	28948058.475684
 %      29    24 28600219.4391               28614663.7460    x3 D    11     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6070ba0
% @LO 0.07  28.60021943909494268610 99.9000000000
% @LN 0.07  28.61466374604198037446 99.9000000000
% Resuming node 57 at  28.61466374604198037446
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=56, expected 56
 % @PAP adding 57 rows, 209 nz to LP
DEBUG BB: Processing node 57, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=11, varin=56, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28614663.746042
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
  % @PL 57 rows, 60 cols, 269 nonzeros, 2 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 57 LP 1 Solution, length = 28614663.746042, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28614663.746042, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28614663.746042, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 57 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 57
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.500000
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 31
DEBUG CAREFUL: New best var: 31
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
  % Initial guess is x31, Z0 = 28614663.746042         , Z1 = 28781392.9899966        

DEBUG EVAL: Testing var 31 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=48, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=3, varin=54, theta=0.777778, up=999999999999999983222784.000000
ITER 3: row=41, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=51, varin=71, theta=1.000000, up=1.000000
ITER 5: row=30, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=8, varin=53, theta=0.470588, up=999999999999999983222784.000000
ITER 7: row=22, varin=48, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 1 gives z=28781392.989997
  % 	x31 = 1,	Z1 = 28781392.9899966        
DEBUG EVAL: First branch cutoff check: z=28781392.989997, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 0
ITER 1: row=48, varin=11, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=56, varin=50, theta=0.200000, up=999999999999999983222784.000000
  % 	x31 = 0,	Z0 = 28644947.695482         
DEBUG EVAL: Second branch cutoff check: z=28644947.695482, best_z=INF, threshold=INF
  %   New best:  x31, Z = 28644947.695482         
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=11, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=56, varin=51, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28662253.785040
  % 	x2 = 0,	Z0 = 28662253.7850401        
DEBUG EVAL: First branch cutoff check: z=28662253.785040, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=3, varin=54, theta=0.777778, up=999999999999999983222784.000000
ITER 3: row=41, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=51, varin=50, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28704707.5590403        
DEBUG EVAL: Second branch cutoff check: z=28704707.559040, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28662253.7850401        
DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=47, varin=11, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=56, varin=48, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 0 gives z=28660284.781673
  % 	x27 = 0,	Z0 = 28660284.7816733        
DEBUG EVAL: First branch cutoff check: z=28660284.781673, best_z=INF, threshold=INF
  % Best branch is x2, Z0 = 28662253.7850401        , Z1 = 28704707.5590403        

DEBUG CAREFUL: Final result - returning best.var = 2
DEBUG BB: Branching variable chosen: j=2
 % @NC   59   57	x2 = 0	28662253.785040
 % @NC   60   57	x2 = 1	28704707.559040
 %      57    25 28614663.7460               28618535.5927   x29 D    29     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f605a130
% @LO 0.07  28.61466374604198037446 99.9000000000
% @LN 0.07  28.61853559269436075851 99.9000000000
% Resuming node 39 at  28.61853559269436075851
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=56, expected 56
 % @PAP adding 50 rows, 223 nz to LP
DEBUG BB: Processing node 39, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 39 LP 5 Solution, length = 28618535.592694, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333417 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333417 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333417 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333417 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333165 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666583 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666583 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666583 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666583 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666583 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666583 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666583 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28618535.592694, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28618535.592694, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 39 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 39
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333417
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333417)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.333417
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.333417)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333417
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333417)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333417
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333417)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333165
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333165)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x3, Z0 = 28618535.5926944        , Z1 = 29393407.0016118        

DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=17, theta=0.490743, up=999999999999999983222784.000000
ITER 2: row=10, varin=6, theta=0.445916, up=999999999999999983222784.000000
ITER 3: row=2, varin=46, theta=509035.000000, up=999999999999999983222784.000000
ITER 4: row=25, varin=47, theta=0.415545, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28648294.498773
  % 	x26 = 1,	Z1 = 28880067.0303363        
DEBUG EVAL: First branch cutoff check: z=28880067.030336, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=42, varin=36, theta=0.241109, up=999999999999999983222784.000000
ITER 2: row=41, varin=74, theta=0.706936, up=1.000000
ITER 3: row=23, varin=72, theta=0.319021, up=1.000000
ITER 4: row=48, varin=76, theta=0.330994, up=1.000000
ITER 5: row=50, varin=88, theta=0.478955, up=1.000000
  % 	x26 = 0,	Z0 = 28698235.3414613        
DEBUG EVAL: Second branch cutoff check: z=28698235.341461, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28698235.3414613        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=36, theta=0.964802, up=999999999999999983222784.000000
ITER 2: row=42, varin=17, theta=0.476190, up=999999999999999983222784.000000
ITER 3: row=10, varin=6, theta=0.425532, up=999999999999999983222784.000000
ITER 4: row=41, varin=77, theta=2.666083, up=1.000000
ITER 5: row=41, varin=74, theta=3.957222, up=1.000000
ITER 6: row=41, varin=35, theta=0.496216, up=999999999999999983222784.000000
ITER 7: row=2, varin=74, theta=3.000583, up=1.000000
ITER 8: row=2, varin=45, theta=1.166024, up=999999999999999983222784.000000
ITER 9: row=43, varin=27, theta=1.747213, up=999999999999999983222784.000000
ITER 10: row=1, varin=77, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 3 = 1 gives z=29432388.867608
  % 	x3 = 1,	Z1 = 29432388.867608         
DEBUG EVAL: First branch cutoff check: z=29432388.867608, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=21, varin=42, theta=0.388107, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28705604.7044542        
DEBUG EVAL: Second branch cutoff check: z=28705604.704454, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28705604.7044542        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=47, theta=1.102712, up=999999999999999983222784.000000
ITER 2: row=42, varin=46, theta=509035.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28633965.691744
  % 	x17 = 0,	Z0 = 28633965.6917445        
DEBUG EVAL: First branch cutoff check: z=28633965.691744, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=47, theta=0.955484, up=999999999999999983222784.000000
ITER 2: row=42, varin=36, theta=1.291659, up=999999999999999983222784.000000
ITER 3: row=41, varin=74, theta=1.977075, up=1.000000
ITER 4: row=41, varin=72, theta=0.390936, up=1.000000
ITER 5: row=23, varin=74, theta=1.000000, up=1.000000
ITER 6: row=48, varin=73, theta=0.803028, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28884686.235770
  % 	x10 = 1,	Z1 = 28884686.23577          
DEBUG EVAL: First branch cutoff check: z=28884686.235770, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=20, varin=27, theta=0.444261, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28722730.4047401        
DEBUG EVAL: Second branch cutoff check: z=28722730.404740, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28722730.4047401        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=45, theta=0.376882, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28634211.165707
  % 	x2 = 0,	Z0 = 28634211.1657069        
DEBUG EVAL: First branch cutoff check: z=28634211.165707, best_z=INF, threshold=INF
  % Best branch is x10, Z0 = 28722730.4047401        , Z1 = 28884686.23577          

DEBUG CAREFUL: Final result - returning best.var = 10
DEBUG BB: Branching variable chosen: j=10
 % @NC   61   39	x10 = 0	28722730.404740
 % @NC   62   39	x10 = 1	28884686.235770
 %      39    26 28618535.5927               28634412.6892   x36 D    32    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6038600
% @LO 0.07  28.61853559269436075851 99.9000000000
% @LN 0.07  28.63441268922898430560 99.9000000000
% Resuming node 7 at  28.63441268922898430560
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=49, expected 49
 % @PAP adding 57 rows, 246 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 7 LP 8 Solution, length = 28634412.689229, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.103061 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.103061 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.103061 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.278574 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.103061 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.103061 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.278574 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.103061 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.103061 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.103061 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.103061 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.103061 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.103061 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.103061 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.278574 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.896939 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.896939 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.896939 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.896939 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.896939 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.896939 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.721426 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.896939 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.721426 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.896939 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.721426 (terminal 19)
 % 15 fractional variables
DEBUG CG: LP optimal, z=28634412.689229, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28634412.689229, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.103061
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.103061)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.103061
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.103061)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.103061
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.103061)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.278574
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.278574)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.103061
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.103061)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.103061
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.103061)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.278574
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.278574)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.103061
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.103061)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.103061
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.103061)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.103061
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.103061)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.103061
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.103061)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.103061
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.103061)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.103061
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.103061)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.103061
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.103061)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.278574
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.278574)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 15 fractional variables

  %  Carefully choosing branching variable, nfrac = 15
DEBUG CAREFUL: Testing fvar[0] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 36
DEBUG CAREFUL: New best var: 36
DEBUG CAREFUL: Testing fvar[1] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 32
DEBUG CAREFUL: New best var: 32
DEBUG CAREFUL: Testing fvar[2] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[3] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 33
DEBUG CAREFUL: New best var: 33
DEBUG CAREFUL: Testing fvar[4] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
DEBUG CAREFUL: Testing fvar[5] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[6] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[7] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[8] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[9] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[10] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[11] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[12] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[13] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 37
DEBUG CAREFUL: Testing fvar[14] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 31
DEBUG CAREFUL: New best var: 31
  % Initial guess is x31, Z0 = 28634412.689229         , Z1 = 29078137.2662244        

DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=56, theta=0.317022, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 0 gives z=28644069.378849
  % 	x36 = 0,	Z0 = 28644069.3788494        
DEBUG EVAL: First branch cutoff check: z=28644069.378849, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 1
ITER 1: row=38, varin=24, theta=0.458043, up=999999999999999983222784.000000
ITER 2: row=23, varin=10, theta=1.747176, up=999999999999999983222784.000000
ITER 3: row=20, varin=55, theta=1.118901, up=999999999999999983222784.000000
ITER 4: row=9, varin=4, theta=1.389492, up=999999999999999983222784.000000
ITER 5: row=8, varin=11, theta=0.939754, up=999999999999999983222784.000000
ITER 6: row=5, varin=115, theta=0.547003, up=1.000000
ITER 7: row=27, varin=56, theta=1.898923, up=999999999999999983222784.000000
ITER 8: row=49, varin=47, theta=2.056719, up=999999999999999983222784.000000
  % 	x36 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=56, theta=0.317022, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28644069.378849
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 306 nonzeros, 2 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 7 at  28.64406937884939097216
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6050790
% @LO 0.07  28.63441268922898430560 99.9000000000
% @LN 0.07  28.64154585503956340631 99.9000000000
% Resuming node 24 at  28.64154585503956340631
DEBUG CONSTRNT: LP rows=55, pool->nlprows=55, pool->npend=0
DEBUG CONSTRNT: Checking 55 LP rows (pool tracks 55, total LP rows 55)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=54, expected 54
 % @PAP adding 58 rows, 249 nz to LP
DEBUG BB: Processing node 24, calling compute_good_lower_bound
LP PHASE: Starting primal phase (iter=0)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28641545.855040
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 309 nonzeros, 0 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 24 LP 2 Solution, length = 28641545.855040, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.155334 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.155334 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.155334 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.155334 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.155334 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.067999 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.155334 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.844666 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.844666 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.844666 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.844666 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.844666 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.844666 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.844666 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28641545.855040, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28641545.855040, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 24 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 24
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.155334
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.155334)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.155334
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.155334)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.155334
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.155334)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.155334
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.155334)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.155334
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.155334)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.067999
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.067999)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.155334
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.155334)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[5] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[6] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x22, Z0 = 28641545.8550396        , Z1 = 28933716.3394402        

DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=32, theta=0.918601, up=999999999999999983222784.000000
ITER 2: row=32, varin=49, theta=2.275144, up=999999999999999983222784.000000
ITER 3: row=49, varin=12, theta=1.841491, up=999999999999999983222784.000000
ITER 4: row=3, varin=75, theta=2.700477, up=1.000000
ITER 5: row=3, varin=13, theta=1.231473, up=999999999999999983222784.000000
ITER 6: row=11, varin=58, theta=1.205305, up=999999999999999983222784.000000
ITER 7: row=6, varin=75, theta=1.000000, up=1.000000
ITER 8: row=1, varin=55, theta=0.907593, up=999999999999999983222784.000000
ITER 9: row=52, varin=48, theta=1.115432, up=999999999999999983222784.000000
ITER 10: row=48, varin=52, theta=0.459922, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=28944496.323688
  % 	x22 = 1,	Z1 = 28944496.3236883        
DEBUG EVAL: First branch cutoff check: z=28944496.323688, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=42, varin=29, theta=0.233404, up=999999999999999983222784.000000
ITER 2: row=47, varin=70, theta=0.096753, up=1.000000
  % 	x22 = 0,	Z0 = 28644236.2376475        
DEBUG EVAL: Second branch cutoff check: z=28644236.237648, best_z=INF, threshold=INF
  %   New best:  x22, Z = 28644236.2376475        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=42, theta=0.977276, up=999999999999999983222784.000000
ITER 2: row=53, varin=75, theta=8.977530, up=1.000000
ITER 3: row=53, varin=28, theta=4.380689, up=999999999999999983222784.000000
ITER 4: row=22, varin=12, theta=3.496822, up=999999999999999983222784.000000
ITER 5: row=2, varin=39, theta=1.668412, up=999999999999999983222784.000000
ITER 6: row=51, varin=50, theta=0.989496, up=999999999999999983222784.000000
ITER 7: row=6, varin=75, theta=1.000000, up=1.000000
ITER 8: row=54, varin=13, theta=7.718183, up=999999999999999983222784.000000
ITER 9: row=11, varin=58, theta=7.873824, up=999999999999999983222784.000000
ITER 10: row=1, varin=51, theta=2.467635, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x3 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=29, theta=1.315150, up=999999999999999983222784.000000
ITER 2: row=47, varin=70, theta=0.718477, up=1.000000
ITER 3: row=42, varin=32, theta=0.427343, up=999999999999999983222784.000000
ITER 4: row=32, varin=52, theta=0.104047, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28697503.928562
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 309 nonzeros, 3 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=80, theta=0.152680, up=1.000000
ITER 2: row=32, varin=63, theta=0.201666, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28705575.818405
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 309 nonzeros, 0 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=84, theta=0.065049, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28707537.945296
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 61 rows, 60 cols, 315 nonzeros, 0 slack, 61 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 24 at  28.70753794529606750530
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6038600
% @LO 0.07  28.64154585503956340631 99.9000000000
% @LN 0.07  28.64406937884939097216 99.9000000000
% Resuming node 7 at  28.64406937884939097216
DEBUG CONSTRNT: LP rows=61, pool->nlprows=61, pool->npend=0
DEBUG CONSTRNT: Checking 61 LP rows (pool tracks 61, total LP rows 61)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=60, expected 60
 % @PAP adding 55 rows, 240 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 7 LP 9 Solution, length = 28644069.378849, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.317022 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.365957 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.365957 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.317022 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.317022 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.365957 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.682978 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.634043 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.682978 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.634043 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.634043 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28644069.378849, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28644069.378849, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.317022
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.317022)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.365957
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.365957)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.365957
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.365957)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.317022
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.317022)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.317022
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.317022)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.365957
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.365957)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 37
DEBUG CAREFUL: Testing fvar[3] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 31
DEBUG CAREFUL: New best var: 31
  % Initial guess is x31, Z0 = 28644069.3788494        , Z1 = 29078137.2662244        

DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=3, theta=0.627574, up=999999999999999983222784.000000
ITER 2: row=41, varin=49, theta=113218.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28723533.136403
  % 	x26 = 0,	Z0 = 28723533.1364031        
DEBUG EVAL: First branch cutoff check: z=28723533.136403, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=33, varin=24, theta=0.665372, up=999999999999999983222784.000000
ITER 2: row=7, varin=22, theta=0.572839, up=999999999999999983222784.000000
ITER 3: row=43, varin=6, theta=1.634054, up=999999999999999983222784.000000
ITER 4: row=9, varin=113, theta=1.060502, up=1.000000
ITER 5: row=9, varin=7, theta=0.129637, up=999999999999999983222784.000000
ITER 6: row=27, varin=113, theta=1.000000, up=1.000000
ITER 7: row=2, varin=11, theta=1.512510, up=999999999999999983222784.000000
ITER 8: row=14, varin=39, theta=3.170022, up=999999999999999983222784.000000
ITER 9: row=20, varin=47, theta=115.729313, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=3, theta=0.627574, up=999999999999999983222784.000000
ITER 2: row=41, varin=49, theta=113218.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28723533.136403
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.750000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 2.750000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 300 nonzeros, 3 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=82, theta=0.166667, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28726294.863330
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 4.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
   % @PL 54 rows, 60 cols, 260 nonzeros, 0 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 7 at  28.72629486333048021152
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6043950
% @LO 0.07  28.64406937884939097216 99.9000000000
% @LN 0.07  28.65232040096712751165 99.9000000000
% Resuming node 38 at  28.65232040096712751165
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=53, expected 53
 % @PAP adding 55 rows, 216 nz to LP
DEBUG BB: Processing node 38, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=20, varin=58, theta=1.000000, up=1.000000
ITER 3: row=50, varin=52, theta=0.555556, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28652320.400967
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 276 nonzeros, 10 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=50, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=57, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=55, varin=69, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28672012.156560
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 290 nonzeros, 12 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 12 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=74, theta=0.443449, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28682273.255029
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 266 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=62, theta=0.150678, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28686476.271060
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 273 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 38 LP 1 Solution, length = 28686476.271060, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.232881 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.232881 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.232881 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.150678 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.232881 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.232881 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.767119 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.767119 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.767119 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.767119 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.767119 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.767119 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.767119 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28686476.271060, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 38 at  28.68647627106006581243
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f605a370
% @LO 0.07  28.65232040096712751165 99.9000000000
% @LN 0.07  28.65869935270790591630 99.9000000000
% Resuming node 53 at  28.65869935270790591630
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=49, expected 49
 % @PAP adding 50 rows, 179 nz to LP
DEBUG BB: Processing node 53, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=43, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28658699.352708
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 239 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=73, theta=0.803922, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28676844.678392
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 279 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=77, theta=0.854384, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28702621.179950
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 281 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=75, theta=0.813592, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28714327.849151
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 286 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=85, theta=0.868781, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28722020.901942
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 305 nonzeros, 2 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=44, theta=0.995544, up=999999999999999983222784.000000
ITER 2: row=49, varin=38, theta=0.631196, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28738612.287641
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 298 nonzeros, 1 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 53 LP 1 Solution, length = 28738612.287641, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.166667 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.368804 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.166667 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.166667 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.166667 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.166667 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.166667 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.631196 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.631196 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.833333 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28738612.287641, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 53 at  28.73861228764144826187
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60743c0
% @LO 0.07  28.65869935270790591630 99.9000000000
% @LN 0.07  28.66032766597819048116 99.9000000000
% Resuming node 52 at  28.66032766597819048116
DEBUG CONSTRNT: LP rows=55, pool->nlprows=55, pool->npend=0
DEBUG CONSTRNT: Checking 55 LP rows (pool tracks 55, total LP rows 55)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=54, expected 54
 % @PAP adding 50 rows, 225 nz to LP
DEBUG BB: Processing node 52, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=75, theta=1.200000, up=1.000000
ITER 2: row=1, varin=74, theta=0.333333, up=1.000000
ITER 3: row=3, varin=75, theta=1.000000, up=1.000000
ITER 4: row=1, varin=43, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=32, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=29, varin=7, theta=2.500000, up=999999999999999983222784.000000
ITER 7: row=11, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=23, varin=74, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28660327.665978
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.500000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.500000
DEBUG SOLUTION: lp->best_solution[5] = 2.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 285 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=32, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=41, varin=23, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=24, varin=50, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28673894.541515
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 293 nonzeros, 4 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=34, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28688343.939661
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.750000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.750000
DEBUG SOLUTION: lp->best_solution[5] = 2.500000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 297 nonzeros, 8 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=95, theta=0.235294, up=1.000000
ITER 2: row=4, varin=26, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=34, varin=27, theta=0.200000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28693413.919327
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 4.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 5.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 280 nonzeros, 3 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=32, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28695891.713091
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 4.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 5.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 275 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=13, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28698062.537876
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.833333
DEBUG SOLUTION: lp->best_solution[6] = 0.833333
DEBUG SOLUTION: lp->best_solution[7] = 3.666667
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.833333
DEBUG SOLUTION: lp->best_solution[11] = 0.833333
DEBUG SOLUTION: lp->best_solution[12] = 0.833333
DEBUG SOLUTION: lp->best_solution[13] = 4.500000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 284 nonzeros, 10 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 10 slack rows
  % Node 52 LP 1 Solution, length = 28698062.537876, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.166667 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.166667 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.166667 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.166667 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.166667 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.166667 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.833333 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.833333 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.833333 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.833333 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.833333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.833333 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.833333 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.833333 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28698062.537876, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 52 at  28.69806253787601235672
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6046ac0
% @LO 0.07  28.66032766597819048116 99.9000000000
% @LN 0.07  28.66191725836761250434 99.9000000000
% Resuming node 47 at  28.66191725836761250434
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=33, expected 33
 % @PAP adding 53 rows, 230 nz to LP
DEBUG BB: Processing node 47, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=99, theta=0.388627, up=1.000000
ITER 2: row=44, varin=49, theta=0.331250, up=999999999999999983222784.000000
ITER 3: row=46, varin=43, theta=0.297927, up=999999999999999983222784.000000
ITER 4: row=47, varin=48, theta=0.376422, up=999999999999999983222784.000000
ITER 5: row=17, varin=107, theta=1.450566, up=1.000000
ITER 6: row=17, varin=45, theta=0.158543, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
ITER 7: row=20, varin=30, theta=287322.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 29215573.640007
DEBUG SOLUTION: lp->best_solution[1] = 19.317085
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 290 nonzeros, 7 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=60, theta=8.500000, up=1.000000
ITER 2: row=1, varin=64, theta=5.000000, up=1.000000
ITER 3: row=1, varin=57, theta=6.000000, up=1.000000
ITER 4: row=1, varin=55, theta=5.000000, up=1.000000
ITER 5: row=1, varin=90, theta=8.000000, up=1.000000
ITER 6: row=1, varin=91, theta=7.000000, up=1.000000
ITER 7: row=1, varin=92, theta=6.000000, up=1.000000
ITER 8: row=1, varin=93, theta=5.000000, up=1.000000
ITER 9: row=1, varin=94, theta=4.000000, up=1.000000
ITER 10: row=1, varin=95, theta=3.000000, up=1.000000
LP PHASE: Switching to primal (iter=51)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28676469.218707
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 250 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=96, theta=0.115676, up=1.000000
ITER 2: row=17, varin=16, theta=-1.776929, up=999999999999999983222784.000000
ITER 3: row=17, varin=77, theta=0.392957, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28685561.984336
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 290 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=65, theta=0.081588, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28687837.789520
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 297 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 47 LP 1 Solution, length = 28687837.789520, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.278942 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.278942 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.278942 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.081588 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.278942 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.278942 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.721058 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.721058 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.721058 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.721058 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.721058 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.721058 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.721058 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28687837.789520, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 47 at  28.68783778952049345889
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6055740
% @LO 0.07  28.66191725836761250434 99.9000000000
% @LN 0.07  28.66225378504014287273 99.9000000000
% Resuming node 59 at  28.66225378504014287273
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=52, expected 52
 % @PAP adding 57 rows, 209 nz to LP
DEBUG BB: Processing node 59, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=11, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=56, varin=51, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28662253.785040
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.666667
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 4.666667
  % @PL 57 rows, 60 cols, 269 nonzeros, 6 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=98, theta=0.077049, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28663726.999606
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.692350
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 4.692350
  % @PL 58 rows, 60 cols, 309 nonzeros, 6 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 4 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=95, theta=0.071226, up=1.000000
ITER 2: row=56, varin=53, theta=0.050554, up=999999999999999983222784.000000
ITER 3: row=43, varin=33, theta=0.003013, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28667252.988480
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 310 nonzeros, 7 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 5 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=94, theta=0.084663, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28670967.563416
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 307 nonzeros, 2 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=6, theta=0.132413, up=999999999999999983222784.000000
ITER 2: row=10, varin=18, theta=0.062666, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28691377.676606
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 314 nonzeros, 2 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 59 LP 1 Solution, length = 28691377.676606, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.312445 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.312445 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.312445 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.312445 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.062666 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.312445 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.062666 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.312445 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.312445 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.312445 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.687555 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.687555 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.687555 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.687555 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.687555 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.687555 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.937334 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.687555 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28691377.676606, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 59 at  28.69137767660551929794
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f605a7a0
% @LO 0.07  28.66225378504014287273 99.9000000000
% @LN 0.07  28.68458584279036216458 99.9000000000
% Resuming node 55 at  28.68458584279036216458
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=52, expected 52
 % @PAP adding 51 rows, 189 nz to LP
DEBUG BB: Processing node 55, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=50, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=21, varin=48, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28684585.842790
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 249 nonzeros, 4 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=34, theta=0.427288, up=999999999999999983222784.000000
ITER 2: row=33, varin=76, theta=3.348063, up=1.000000
ITER 3: row=33, varin=74, theta=0.828296, up=1.000000
ITER 4: row=1, varin=39, theta=1.217974, up=999999999999999983222784.000000
ITER 5: row=29, varin=33, theta=0.502109, up=999999999999999983222784.000000
ITER 6: row=32, varin=17, theta=0.632927, up=999999999999999983222784.000000
ITER 7: row=10, varin=46, theta=1.669400, up=999999999999999983222784.000000
ITER 8: row=21, varin=40, theta=0.644733, up=999999999999999983222784.000000
ITER 9: row=40, varin=43, theta=0.721006, up=999999999999999983222784.000000
ITER 10: row=43, varin=6, theta=0.231456, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 289 nonzeros, 6 slack, 46 tight.
  % Node 55 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 55 is INFEASIBLE
 %      55    25    infeasible               28686476.2711   x17 U    50    13
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6043950
% @LO 0.07  28.68458584279036216458 99.9000000000
% @LN 0.07  28.68647627106006581243 99.9000000000
% Resuming node 38 at  28.68647627106006581243
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=51, expected 51
 % @PAP adding 50 rows, 213 nz to LP
DEBUG BB: Processing node 38, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 38 LP 2 Solution, length = 28686476.271060, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.232881 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.232881 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.232881 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.150678 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.232881 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.232881 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.767119 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.767119 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.767119 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.767119 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.767119 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.767119 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.767119 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28686476.271060, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28686476.271060, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 38 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 38
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.232881
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.232881)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.232881
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.232881)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.232881
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.232881)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.150678
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.150678)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.232881
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.232881)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.232881
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.232881)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x11, Z0 = 28686476.2710601        , Z1 = 28883718.7385818        

DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=48, theta=0.931025, up=999999999999999983222784.000000
ITER 2: row=47, varin=47, theta=728258.000000, up=999999999999999983222784.000000
ITER 3: row=39, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=31, varin=46, theta=0.333333, up=999999999999999983222784.000000
ITER 5: row=37, varin=45, theta=0.572751, up=999999999999999983222784.000000
ITER 6: row=45, varin=36, theta=0.252958, up=999999999999999983222784.000000
ITER 7: row=37, varin=17, theta=0.228858, up=999999999999999983222784.000000
ITER 8: row=10, varin=6, theta=0.205593, up=999999999999999983222784.000000
ITER 9: row=6, varin=42, theta=0.611450, up=999999999999999983222784.000000
ITER 10: row=42, varin=39, theta=0.361411, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x11 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=55, theta=0.157667, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28690687.958444
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 273 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 38 at  28.69068795844437502751
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6046ac0
% @LO 0.07  28.68647627106006581243 99.9000000000
% @LN 0.07  28.68783778952049345889 99.9000000000
% Resuming node 47 at  28.68783778952049345889
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=49, expected 49
 % @PAP adding 53 rows, 237 nz to LP
DEBUG BB: Processing node 47, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 47 LP 2 Solution, length = 28687837.789520, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.278942 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.278942 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.278942 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.081588 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.278942 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.278942 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.721058 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.721058 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.721058 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.721058 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.721058 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.721058 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.721058 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28687837.789520, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28687837.789520, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 47 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 47
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.278942
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.278942)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.278942
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.278942)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.278942
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.278942)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.081588
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.081588)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.278942
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.278942)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.278942
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.278942)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[2] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x3, Z0 = 29215573.6400069        , Z1 = 29510598.668264         

DEBUG EVAL: Testing var 11 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=43, varin=40, theta=0.083375, up=999999999999999983222784.000000
ITER 2: row=42, varin=58, theta=0.085372, up=1.000000
DEBUG EVAL: Branch var 11 = 0 gives z=28690118.289979
  % 	x11 = 0,	Z0 = 29215573.6400069        
DEBUG EVAL: First branch cutoff check: z=29215573.640007, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 1
ITER 1: row=43, varin=51, theta=1.006762, up=999999999999999983222784.000000
ITER 2: row=50, varin=17, theta=0.739247, up=999999999999999983222784.000000
ITER 3: row=10, varin=6, theta=0.671720, up=999999999999999983222784.000000
ITER 4: row=2, varin=50, theta=766801.000000, up=999999999999999983222784.000000
ITER 5: row=49, varin=48, theta=0.391304, up=999999999999999983222784.000000
ITER 6: row=40, varin=47, theta=0.875000, up=999999999999999983222784.000000
ITER 7: row=47, varin=49, theta=7.000000, up=999999999999999983222784.000000
ITER 8: row=2, varin=3, theta=1.723531, up=999999999999999983222784.000000
ITER 9: row=3, varin=45, theta=0.650268, up=999999999999999983222784.000000
ITER 10: row=45, varin=39, theta=0.208910, up=999999999999999983222784.000000
  % 	x11 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=40, theta=0.083375, up=999999999999999983222784.000000
ITER 2: row=42, varin=58, theta=0.085372, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28690118.289979
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 297 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 47 at  28.69011828997931701224
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6046ac0
% @LO 0.07  28.68783778952049345889 99.9000000000
% @LN 0.07  28.69011828997931701224 99.9000000000
% Resuming node 47 at  28.69011828997931701224
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=52, expected 52
 % @PAP adding 53 rows, 237 nz to LP
DEBUG BB: Processing node 47, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 47 LP 3 Solution, length = 28690118.289979, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.276419 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.276419 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.085372 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.276419 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.276419 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.276419 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.723581 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.723581 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.723581 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.723581 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.723581 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.723581 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.723581 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28690118.289979, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28690118.289979, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 47 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 47
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.276419
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.276419)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.276419
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.276419)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.085372
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.085372)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.276419
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.276419)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.276419
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.276419)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.276419
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.276419)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[2] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x3, Z0 = 29215573.6400069        , Z1 = 29510598.668264         

DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=42, theta=0.272074, up=999999999999999983222784.000000
ITER 2: row=40, varin=50, theta=221053.000000, up=999999999999999983222784.000000
ITER 3: row=49, varin=48, theta=0.071429, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28301045.944968
  % 	x3 = 0,	Z0 = 29215573.6400069        
DEBUG EVAL: First branch cutoff check: z=29215573.640007, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=21, varin=75, theta=2.095169, up=1.000000
ITER 2: row=21, varin=39, theta=0.617997, up=999999999999999983222784.000000
ITER 3: row=42, varin=17, theta=0.944528, up=999999999999999983222784.000000
ITER 4: row=10, varin=6, theta=0.876986, up=999999999999999983222784.000000
ITER 5: row=2, varin=75, theta=0.828721, up=1.000000
ITER 6: row=44, varin=45, theta=4.085675, up=999999999999999983222784.000000
ITER 7: row=45, varin=27, theta=2.726904, up=999999999999999983222784.000000
ITER 8: row=50, varin=47, theta=3.412131, up=999999999999999983222784.000000
ITER 9: row=1, varin=41, theta=0.872735, up=999999999999999983222784.000000
ITER 10: row=2, varin=76, theta=0.760687, up=1.000000
  % 	x3 = 1,	Z1 = 29720517.033948         
DEBUG EVAL: Second branch cutoff check: z=29720517.033948, best_z=INF, threshold=INF
  %   New best:  x3, Z = 29215573.6400069        
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=50, varin=51, theta=0.212134, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28700925.430855
  % 	x26 = 0,	Z0 = 29215573.6400069        
DEBUG EVAL: First branch cutoff check: z=29215573.640007, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=50, varin=48, theta=1.711567, up=999999999999999983222784.000000
ITER 2: row=41, varin=22, theta=0.631548, up=999999999999999983222784.000000
ITER 3: row=53, varin=75, theta=0.871046, up=1.000000
  % 	x26 = 1,	Z1 = 29244058.6040726        
DEBUG EVAL: Second branch cutoff check: z=29244058.604073, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=75, theta=0.083859, up=1.000000
DEBUG EVAL: Branch var 4 = 0 gives z=28702512.484237
  % 	x4 = 0,	Z0 = 29215573.6400069        
DEBUG EVAL: First branch cutoff check: z=29215573.640007, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 1
ITER 1: row=42, varin=42, theta=0.893233, up=999999999999999983222784.000000
ITER 2: row=40, varin=51, theta=0.958173, up=999999999999999983222784.000000
ITER 3: row=50, varin=17, theta=0.715408, up=999999999999999983222784.000000
ITER 4: row=10, varin=6, theta=0.650059, up=999999999999999983222784.000000
ITER 5: row=2, varin=50, theta=742074.000000, up=999999999999999983222784.000000
ITER 6: row=49, varin=48, theta=0.391304, up=999999999999999983222784.000000
ITER 7: row=1, varin=49, theta=7.000000, up=999999999999999983222784.000000
ITER 8: row=2, varin=3, theta=1.816546, up=999999999999999983222784.000000
ITER 9: row=3, varin=45, theta=0.685362, up=999999999999999983222784.000000
ITER 10: row=45, varin=40, theta=0.457813, up=999999999999999983222784.000000
  % 	x4 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=75, theta=0.083859, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28702512.484237
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 297 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=83, theta=0.088565, up=1.000000
ITER 2: row=57, varin=80, theta=0.084766, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28706593.096539
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 313 nonzeros, 1 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 47 at  28.70659309653909474491
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6043950
% @LO 0.08  28.69011828997931701224 99.9000000000
% @LN 0.08  28.69068795844437502751 99.9000000000
% Resuming node 38 at  28.69068795844437502751
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=56, expected 56
 % @PAP adding 50 rows, 213 nz to LP
DEBUG BB: Processing node 38, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 38 LP 3 Solution, length = 28690687.958444, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.228222 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.228222 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.157667 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.228222 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.228222 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.228222 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.771778 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.771778 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.771778 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.771778 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.771778 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.771778 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.771778 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28690687.958444, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28690687.958444, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 38 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 38
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.228222
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.228222)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.228222
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.228222)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.157667
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.157667)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.228222
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.228222)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.228222
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.228222)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.228222
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.228222)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x4, Z0 = 28690687.9584444        , Z1 = 28889175.7996246        

DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=48, theta=0.882436, up=999999999999999983222784.000000
ITER 2: row=47, varin=47, theta=703531.000000, up=999999999999999983222784.000000
ITER 3: row=39, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=31, varin=46, theta=0.333333, up=999999999999999983222784.000000
ITER 5: row=37, varin=45, theta=0.647694, up=999999999999999983222784.000000
ITER 6: row=1, varin=36, theta=0.286056, up=999999999999999983222784.000000
ITER 7: row=37, varin=17, theta=0.258803, up=999999999999999983222784.000000
ITER 8: row=10, varin=6, theta=0.232494, up=999999999999999983222784.000000
ITER 9: row=6, varin=42, theta=0.691456, up=999999999999999983222784.000000
ITER 10: row=42, varin=39, theta=0.408701, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x4 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=74, theta=0.361492, up=1.000000
ITER 2: row=23, varin=72, theta=0.154873, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28713577.877800
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 273 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=36, theta=0.394510, up=999999999999999983222784.000000
ITER 2: row=40, varin=80, theta=0.163563, up=1.000000
ITER 3: row=54, varin=77, theta=0.156547, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28721114.058417
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 289 nonzeros, 0 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 38 at  28.72111405841651787796
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6055740
% @LO 0.08  28.69068795844437502751 99.9000000000
% @LN 0.08  28.69137767660551929794 99.9000000000
% Resuming node 59 at  28.69137767660551929794
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=53, expected 53
 % @PAP adding 53 rows, 248 nz to LP
DEBUG BB: Processing node 59, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 59 LP 2 Solution, length = 28691377.676606, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.312445 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.312445 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.312445 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.312445 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.062666 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.312445 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.062666 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.312445 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.312445 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.312445 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.687555 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.687555 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.687555 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.687555 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.687555 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.687555 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.937334 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.687555 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28691377.676606, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28691377.676606, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 59 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 59
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.312445
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.312445)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.312445
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.312445)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.312445
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.312445)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.312445
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.312445)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.062666
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.062666)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.312445
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.312445)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.062666
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.062666)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.312445
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.312445)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.312445
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.312445)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.312445
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.312445)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 36
DEBUG CAREFUL: New best var: 36
DEBUG CAREFUL: Testing fvar[2] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
DEBUG CAREFUL: Testing fvar[3] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[4] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[5] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[6] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[7] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 33
DEBUG CAREFUL: Testing fvar[8] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[9] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
  % Initial guess is x0, Z0 = 28691377.6766055        , Z1 = 28925539.2039083        

DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=43, theta=0.831293, up=999999999999999983222784.000000
ITER 2: row=49, varin=10, theta=3.915900, up=999999999999999983222784.000000
ITER 3: row=6, varin=30, theta=0.941826, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=29230390.138247
  % 	x34 = 1,	Z1 = 29230390.1382468        
DEBUG EVAL: First branch cutoff check: z=29230390.138247, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=29, varin=3, theta=0.531064, up=999999999999999983222784.000000
ITER 2: row=38, varin=10, theta=0.154112, up=999999999999999983222784.000000
ITER 3: row=6, varin=51, theta=0.088051, up=999999999999999983222784.000000
ITER 4: row=45, varin=46, theta=15968.500000, up=999999999999999983222784.000000
ITER 5: row=39, varin=48, theta=0.113582, up=999999999999999983222784.000000
ITER 6: row=45, varin=47, theta=0.025573, up=999999999999999983222784.000000
ITER 7: row=44, varin=46, theta=15968.500000, up=999999999999999983222784.000000
ITER 8: row=6, varin=44, theta=0.074061, up=999999999999999983222784.000000
ITER 9: row=45, varin=85, theta=0.002572, up=1.000000
  % 	x34 = 0,	Z0 = 28691377.6766055        
DEBUG EVAL: Second branch cutoff check: z=28691377.676606, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28691377.6766055        
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=43, theta=0.831293, up=999999999999999983222784.000000
ITER 2: row=49, varin=10, theta=3.915900, up=999999999999999983222784.000000
ITER 3: row=6, varin=20, theta=0.663026, up=999999999999999983222784.000000
ITER 4: row=19, varin=48, theta=2.554754, up=999999999999999983222784.000000
ITER 5: row=44, varin=42, theta=1.506314, up=999999999999999983222784.000000
ITER 6: row=52, varin=51, theta=3.139029, up=999999999999999983222784.000000
ITER 7: row=45, varin=40, theta=1.585469, up=999999999999999983222784.000000
ITER 8: row=47, varin=93, theta=4.711097, up=1.000000
ITER 9: row=47, varin=2, theta=6.473624, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x36 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=3, theta=0.531064, up=999999999999999983222784.000000
ITER 2: row=38, varin=10, theta=0.154112, up=999999999999999983222784.000000
ITER 3: row=6, varin=51, theta=0.088051, up=999999999999999983222784.000000
ITER 4: row=45, varin=46, theta=15968.500000, up=999999999999999983222784.000000
ITER 5: row=39, varin=48, theta=0.113582, up=999999999999999983222784.000000
ITER 6: row=45, varin=47, theta=0.025573, up=999999999999999983222784.000000
ITER 7: row=44, varin=46, theta=15968.500000, up=999999999999999983222784.000000
ITER 8: row=6, varin=44, theta=0.074061, up=999999999999999983222784.000000
ITER 9: row=45, varin=85, theta=0.002572, up=1.000000
LP PHASE: Switching to primal (iter=9)
ITER 10: row=44, varin=92, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28720033.517290
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.500000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 2.500000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 308 nonzeros, 3 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 1 rows, 3 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=91, theta=0.333333, up=1.000000
ITER 2: row=48, varin=42, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=50, varin=48, theta=0.072464, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28742081.099039
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 265 nonzeros, 4 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=43, theta=0.416667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28775748.833549
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 242 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 59 at  28.77574883354946067016
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60410f0
% @LO 0.08  28.69137767660551929794 99.9000000000
% @LN 0.08  28.69231948924991471017 99.9000000000
% Resuming node 43 at  28.69231948924991471017
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=47, expected 47
 % @PAP adding 58 rows, 229 nz to LP
DEBUG BB: Processing node 43, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 43 LP 2 Solution, length = 28692319.489250, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.500000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28692319.489250, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28692319.489250, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 43 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 43
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.500000
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x34, Z0 = 28797278.4928938        , Z1 = 28732298.2619018        

DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=56, varin=42, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=52, varin=103, theta=0.400000, up=1.000000
ITER 4: row=16, varin=112, theta=1.000000, up=1.000000
ITER 5: row=49, varin=114, theta=0.112676, up=1.000000
ITER 6: row=51, varin=52, theta=0.875000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=29019288.150119
  % 	x34 = 1,	Z1 = 29019288.1501191        
DEBUG EVAL: First branch cutoff check: z=29019288.150119, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=38, varin=54, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=52, varin=103, theta=0.400000, up=1.000000
ITER 3: row=16, varin=112, theta=1.000000, up=1.000000
ITER 4: row=49, varin=114, theta=0.112676, up=1.000000
ITER 5: row=51, varin=52, theta=0.875000, up=999999999999999983222784.000000
  % 	x34 = 0,	Z0 = 28797278.4928938        
DEBUG EVAL: Second branch cutoff check: z=28797278.492894, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28797278.4928938        
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=54, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=52, varin=103, theta=0.400000, up=1.000000
ITER 3: row=16, varin=112, theta=1.000000, up=1.000000
ITER 4: row=49, varin=114, theta=0.112676, up=1.000000
ITER 5: row=51, varin=52, theta=0.875000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 0 gives z=28714844.893912
  % 	x36 = 0,	Z0 = 28732298.2619018        
DEBUG EVAL: First branch cutoff check: z=28732298.261902, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=54, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=52, varin=103, theta=0.400000, up=1.000000
ITER 3: row=16, varin=112, theta=1.000000, up=1.000000
ITER 4: row=49, varin=114, theta=0.112676, up=1.000000
ITER 5: row=51, varin=52, theta=0.875000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28714844.893912
  % 	x7 = 1,	Z1 = 28732298.2619018        
DEBUG EVAL: First branch cutoff check: z=28732298.261902, best_z=INF, threshold=INF
  % Best branch is x34, Z0 = 28797278.4928938        , Z1 = 29019288.1501191        

DEBUG CAREFUL: Final result - returning best.var = 34
DEBUG BB: Branching variable chosen: j=34
 % @NC   63   43	x34 = 0	28797278.492894
 % @NC   64   43	x34 = 1	29019288.150119
 %      43    26 28692319.4892               28698062.5379    x5 D    28     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60743c0
% @LO 0.08  28.69231948924991471017 99.9000000000
% @LN 0.08  28.69806253787601235672 99.9000000000
% Resuming node 52 at  28.69806253787601235672
DEBUG CONSTRNT: LP rows=58, pool->nlprows=58, pool->npend=0
DEBUG CONSTRNT: Checking 58 LP rows (pool tracks 58, total LP rows 58)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=57, expected 57
 % @PAP adding 34 rows, 189 nz to LP
DEBUG BB: Processing node 52, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 52 LP 2 Solution, length = 28698062.537876, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.166667 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.166667 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.166667 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.166667 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.166667 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.166667 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.833333 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.833333 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.833333 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.833333 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.833333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.833333 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.833333 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.833333 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28698062.537876, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28698062.537876, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 52 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 52
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.166667
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.166667
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.166667
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.166667
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.166667
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.166667
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[2] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[3] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[4] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[5] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x1, Z0 = 28698062.537876         , Z1 = 28698062.537876         

DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=61, theta=0.200000, up=1.000000
ITER 2: row=29, varin=15, theta=0.023810, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28700005.881466
  % 	x1 = 0,	Z0 = 28700005.8814657        
DEBUG EVAL: First branch cutoff check: z=28700005.881466, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=3, varin=34, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=13, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=22, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=9, varin=13, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=3, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=6, varin=28, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=31, varin=22, theta=0.666667, up=999999999999999983222784.000000
ITER 8: row=32, varin=9, theta=0.640000, up=999999999999999983222784.000000
ITER 9: row=30, varin=24, theta=0.666667, up=999999999999999983222784.000000
ITER 10: row=4, varin=5, theta=0.666667, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28875885.2622716        
DEBUG EVAL: Second branch cutoff check: z=28875885.262272, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28700005.8814657        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=61, theta=0.200000, up=1.000000
ITER 2: row=29, varin=15, theta=0.023810, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28700005.881466
  % 	x0 = 0,	Z0 = 28700005.8814657        
DEBUG EVAL: First branch cutoff check: z=28700005.881466, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=34, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=13, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=22, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=9, varin=4, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 28739991.100403         
DEBUG EVAL: Second branch cutoff check: z=28739991.100403, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=23, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 0 gives z=28704134.036107
  % 	x36 = 0,	Z0 = 28704134.0361074        
DEBUG EVAL: First branch cutoff check: z=28704134.036107, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 1
ITER 1: row=23, varin=34, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=13, varin=61, theta=4.000000, up=1.000000
ITER 3: row=13, varin=12, theta=0.750000, up=999999999999999983222784.000000
ITER 4: row=29, varin=61, theta=1.000000, up=1.000000
ITER 5: row=2, varin=15, theta=0.333333, up=999999999999999983222784.000000
ITER 6: row=1, varin=28, theta=1.625000, up=999999999999999983222784.000000
ITER 7: row=31, varin=27, theta=3.571429, up=999999999999999983222784.000000
ITER 8: row=4, varin=46, theta=1.145455, up=1.000000
ITER 9: row=4, varin=26, theta=0.142857, up=999999999999999983222784.000000
ITER 10: row=29, varin=46, theta=0.503937, up=1.000000
  % 	x36 = 1,	Z1 = 29014872.3749223        
DEBUG EVAL: Second branch cutoff check: z=29014872.374922, best_z=INF, threshold=INF
  %   New best:  x36, Z = 28704134.0361074        
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=13, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28705753.601763
  % 	x23 = 0,	Z0 = 28705753.6017632        
DEBUG EVAL: First branch cutoff check: z=28705753.601763, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 23 = 1
ITER 1: row=4, varin=34, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=13, varin=61, theta=4.000000, up=1.000000
ITER 3: row=13, varin=12, theta=0.750000, up=999999999999999983222784.000000
ITER 4: row=29, varin=61, theta=1.000000, up=1.000000
ITER 5: row=2, varin=15, theta=0.333333, up=999999999999999983222784.000000
ITER 6: row=1, varin=23, theta=1.625000, up=999999999999999983222784.000000
ITER 7: row=23, varin=28, theta=0.625000, up=999999999999999983222784.000000
ITER 8: row=31, varin=46, theta=0.572727, up=1.000000
ITER 9: row=29, varin=26, theta=0.318898, up=999999999999999983222784.000000
ITER 10: row=11, varin=13, theta=1.000000, up=999999999999999983222784.000000
  % 	x23 = 1,	Z1 = 29038200.3443267        
DEBUG EVAL: Second branch cutoff check: z=29038200.344327, best_z=INF, threshold=INF
  %   New best:  x23, Z = 28705753.6017632        
DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=12, theta=0.125000, up=999999999999999983222784.000000
ITER 2: row=11, varin=13, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 24 = 0 gives z=28713399.046888
  % 	x24 = 0,	Z0 = 28713399.0468879        
DEBUG EVAL: First branch cutoff check: z=28713399.046888, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 24 = 1
ITER 1: row=2, varin=34, theta=5.000000, up=999999999999999983222784.000000
ITER 2: row=13, varin=61, theta=4.000000, up=1.000000
ITER 3: row=13, varin=13, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=29, varin=61, theta=1.000000, up=1.000000
ITER 5: row=4, varin=15, theta=0.333333, up=999999999999999983222784.000000
ITER 6: row=1, varin=23, theta=1.250000, up=999999999999999983222784.000000
ITER 7: row=2, varin=28, theta=1.250000, up=999999999999999983222784.000000
  % 	x24 = 1,	Z1 = 28820210.7240226        
DEBUG EVAL: Second branch cutoff check: z=28820210.724023, best_z=INF, threshold=INF
  %   New best:  x24, Z = 28713399.0468879        
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=34, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28698496.702833
  % 	x34 = 0,	Z0 = 28698496.702833         
DEBUG EVAL: First branch cutoff check: z=28698496.702833, best_z=INF, threshold=INF
  % Best branch is x24, Z0 = 28713399.0468879        , Z1 = 28820210.7240226        

DEBUG CAREFUL: Final result - returning best.var = 24
DEBUG BB: Branching variable chosen: j=24
 % @NC   65   52	x24 = 0	28713399.046888
 % @NC   66   52	x24 = 1	28820210.724023
 %      52    27 28698062.5379               28704707.5590    x5 D    49    13
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60758b0
% @LO 0.08  28.69806253787601235672 99.9000000000
% @LN 0.08  28.70470755904030824013 99.9000000000
% Resuming node 60 at  28.70470755904030824013
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=33, expected 33
 % @PAP adding 57 rows, 209 nz to LP
DEBUG BB: Processing node 60, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=3, varin=54, theta=0.777778, up=999999999999999983222784.000000
ITER 3: row=41, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=51, varin=50, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28704707.559040
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
  % @PL 57 rows, 60 cols, 269 nonzeros, 3 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=48, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28781392.989997
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
  % @PL 58 rows, 60 cols, 271 nonzeros, 3 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=89, theta=1.000000, up=1.000000
ITER 2: row=50, varin=68, theta=0.888889, up=1.000000
ITER 3: row=53, varin=81, theta=1.000000, up=1.000000
ITER 4: row=3, varin=11, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28886780.786545
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.750000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 4.750000
  % @PL 56 rows, 60 cols, 265 nonzeros, 5 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=6, theta=0.541215, up=999999999999999983222784.000000
ITER 2: row=10, varin=92, theta=1.271246, up=1.000000
ITER 3: row=10, varin=3, theta=0.231629, up=999999999999999983222784.000000
ITER 4: row=3, varin=48, theta=0.136696, up=999999999999999983222784.000000
ITER 5: row=47, varin=91, theta=0.605848, up=1.000000
ITER 6: row=6, varin=22, theta=0.190569, up=999999999999999983222784.000000
ITER 7: row=22, varin=30, theta=0.276633, up=999999999999999983222784.000000
ITER 8: row=30, varin=47, theta=1.382964, up=999999999999999983222784.000000
ITER 9: row=47, varin=7, theta=0.922243, up=999999999999999983222784.000000
ITER 10: row=7, varin=91, theta=5.715657, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.750000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 4.750000
  % @PL 52 rows, 60 cols, 290 nonzeros, 5 slack, 47 tight.
  % Node 60 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.250000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.250000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.250000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.250000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.250000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.250000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.250000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.750000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.750000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.750000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.750000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 60 is INFEASIBLE
 %      60    26    infeasible               28706593.0965    x2 U    57     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6046ac0
% @LO 0.08  28.70470755904030824013 99.9000000000
% @LN 0.08  28.70659309653909474491 99.9000000000
% Resuming node 47 at  28.70659309653909474491
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=51, expected 51
 % @PAP adding 57 rows, 253 nz to LP
DEBUG BB: Processing node 47, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 47 LP 4 Solution, length = 28706593.096539, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.305078 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.305078 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.305078 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.305078 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.084766 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.305078 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.694922 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.694922 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.694922 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.694922 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.694922 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.694922 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.694922 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28706593.096539, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28706593.096539, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 47 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 47
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.305078
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.305078)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.305078
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.305078)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.305078
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.305078)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.305078
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.305078)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.084766
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.084766)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.305078
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.305078)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
  % Initial guess is x3, Z0 = 29215573.6400069        , Z1 = 29720517.033948         

DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=42, theta=0.453832, up=999999999999999983222784.000000
ITER 2: row=40, varin=81, theta=4.881102, up=1.000000
ITER 3: row=40, varin=43, theta=0.291688, up=999999999999999983222784.000000
ITER 4: row=23, varin=81, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28924952.770761
  % 	x3 = 0,	Z0 = 29215573.6400069        
DEBUG EVAL: First branch cutoff check: z=29215573.640007, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=21, varin=39, theta=1.086604, up=999999999999999983222784.000000
ITER 2: row=44, varin=27, theta=2.737218, up=999999999999999983222784.000000
ITER 3: row=50, varin=57, theta=30.844918, up=999999999999999983222784.000000
ITER 4: row=57, varin=17, theta=1.137324, up=999999999999999983222784.000000
ITER 5: row=10, varin=6, theta=0.989150, up=999999999999999983222784.000000
ITER 6: row=2, varin=45, theta=2.621380, up=999999999999999983222784.000000
ITER 7: row=45, varin=47, theta=3.480709, up=999999999999999983222784.000000
ITER 8: row=1, varin=41, theta=0.890550, up=999999999999999983222784.000000
ITER 9: row=42, varin=83, theta=0.849965, up=1.000000
ITER 10: row=50, varin=86, theta=0.919501, up=1.000000
  % 	x3 = 1,	Z1 = 29842847.8352389        
DEBUG EVAL: Second branch cutoff check: z=29842847.835239, best_z=INF, threshold=INF
  %   New best:  x3, Z = 29215573.6400069        
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=50, varin=51, theta=0.310483, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28779603.834812
  % 	x26 = 0,	Z0 = 29215573.6400069        
DEBUG EVAL: First branch cutoff check: z=29215573.640007, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=50, varin=22, theta=0.731574, up=999999999999999983222784.000000
ITER 2: row=53, varin=48, theta=0.974059, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 29244058.6040726        
DEBUG EVAL: Second branch cutoff check: z=29244058.604073, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=81, theta=4.881102, up=1.000000
ITER 2: row=39, varin=39, theta=0.672954, up=999999999999999983222784.000000
ITER 3: row=44, varin=95, theta=1.500579, up=1.000000
ITER 4: row=44, varin=50, theta=130351.250000, up=999999999999999983222784.000000
ITER 5: row=49, varin=48, theta=0.142857, up=999999999999999983222784.000000
ITER 6: row=42, varin=44, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=1, varin=57, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=57, varin=54, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=54, varin=81, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28867200.225043
  % 	x17 = 0,	Z0 = 29215573.6400069        
DEBUG EVAL: First branch cutoff check: z=29215573.640007, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=39, varin=27, theta=2.737218, up=999999999999999983222784.000000
ITER 2: row=50, varin=57, theta=30.844918, up=999999999999999983222784.000000
ITER 3: row=57, varin=17, theta=1.137324, up=999999999999999983222784.000000
ITER 4: row=10, varin=6, theta=0.989150, up=999999999999999983222784.000000
ITER 5: row=2, varin=42, theta=1.345577, up=999999999999999983222784.000000
ITER 6: row=40, varin=45, theta=2.621380, up=999999999999999983222784.000000
ITER 7: row=45, varin=47, theta=3.480709, up=999999999999999983222784.000000
ITER 8: row=1, varin=2, theta=1.342652, up=999999999999999983222784.000000
ITER 9: row=42, varin=83, theta=2.031202, up=1.000000
ITER 10: row=42, varin=22, theta=1.127865, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=81, theta=4.881102, up=1.000000
ITER 2: row=39, varin=39, theta=0.672954, up=999999999999999983222784.000000
ITER 3: row=44, varin=95, theta=1.500579, up=1.000000
ITER 4: row=44, varin=50, theta=130351.250000, up=999999999999999983222784.000000
ITER 5: row=49, varin=48, theta=0.142857, up=999999999999999983222784.000000
ITER 6: row=42, varin=44, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=1, varin=57, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=57, varin=54, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=54, varin=81, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28867200.225043
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 313 nonzeros, 2 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=99, theta=1.000000, up=1.000000
ITER 2: row=23, varin=83, theta=1.000000, up=1.000000
ITER 3: row=54, varin=49, theta=6.000000, up=999999999999999983222784.000000
ITER 4: row=50, varin=87, theta=0.329889, up=1.000000
ITER 5: row=61, varin=50, theta=118905.500000, up=999999999999999983222784.000000
ITER 6: row=57, varin=112, theta=0.312500, up=1.000000
ITER 7: row=61, varin=84, theta=0.231784, up=1.000000
ITER 8: row=11, varin=90, theta=3.047955, up=1.000000
ITER 9: row=11, varin=89, theta=2.133619, up=1.000000
ITER 10: row=11, varin=120, theta=0.243948, up=1.000000
LP PHASE: Switching to primal (iter=19)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28932578.788939
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 61 rows, 60 cols, 327 nonzeros, 4 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=62, varin=94, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=65)
DEBUG SOLUTION: LP solution array indices: FST[66-105], not_covered[106-125]
DEBUG SOLUTION: lp->best_solution[0] = 28933973.985724
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 65 rows, 60 cols, 346 nonzeros, 4 slack, 61 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=66, varin=121, theta=0.250000, up=1.000000
ITER 2: row=50, varin=95, theta=0.059140, up=1.000000
ITER 3: row=65, varin=50, theta=109886.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=67)
DEBUG SOLUTION: LP solution array indices: FST[68-107], not_covered[108-127]
DEBUG SOLUTION: lp->best_solution[0] = 28953114.994813
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 67 rows, 60 cols, 354 nonzeros, 4 slack, 63 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=68, varin=128, theta=0.100000, up=1.000000
ITER 2: row=54, varin=56, theta=0.100000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=69)
DEBUG SOLUTION: LP solution array indices: FST[70-109], not_covered[110-129]
DEBUG SOLUTION: lp->best_solution[0] = 28977665.204043
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 69 rows, 60 cols, 360 nonzeros, 6 slack, 63 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=70, varin=104, theta=0.375000, up=1.000000
ITER 2: row=50, varin=41, theta=0.039369, up=999999999999999983222784.000000
ITER 3: row=44, varin=102, theta=0.176263, up=1.000000
ITER 4: row=4, varin=100, theta=0.230411, up=1.000000
ITER 5: row=13, varin=50, theta=71543.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=70)
DEBUG SOLUTION: LP solution array indices: FST[71-110], not_covered[111-130]
DEBUG SOLUTION: lp->best_solution[0] = 28991457.710291
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 70 rows, 60 cols, 362 nonzeros, 4 slack, 66 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=71, varin=103, theta=0.125000, up=1.000000
ITER 2: row=50, varin=105, theta=0.085555, up=1.000000
ITER 3: row=69, varin=61, theta=0.064030, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=72)
DEBUG SOLUTION: LP solution array indices: FST[73-112], not_covered[113-132]
DEBUG SOLUTION: lp->best_solution[0] = 28997928.270329
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.866996
DEBUG SOLUTION: lp->best_solution[10] = 3.866996
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 72 rows, 60 cols, 374 nonzeros, 8 slack, 64 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=73, varin=43, theta=0.141983, up=999999999999999983222784.000000
ITER 2: row=61, varin=23, theta=0.047569, up=999999999999999983222784.000000
ITER 3: row=24, varin=46, theta=0.192136, up=999999999999999983222784.000000
ITER 4: row=9, varin=61, theta=0.020451, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=73)
DEBUG SOLUTION: LP solution array indices: FST[74-113], not_covered[114-133]
DEBUG SOLUTION: lp->best_solution[0] = 29017283.184043
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 73 rows, 60 cols, 376 nonzeros, 10 slack, 63 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 47 at  29.01728318404302342515
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6050790
% @LO 0.08  28.70659309653909474491 99.9000000000
% @LN 0.08  28.70753794529606750530 99.9000000000
% Resuming node 24 at  28.70753794529606750530
DEBUG CONSTRNT: LP rows=73, pool->nlprows=73, pool->npend=0
DEBUG CONSTRNT: Checking 73 LP rows (pool tracks 73, total LP rows 73)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=64, expected 64
DEBUG CONSTRNT: Checking LP row 65 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=65, expected 65
DEBUG CONSTRNT: Checking LP row 66 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=66, expected 66
DEBUG CONSTRNT: Checking LP row 67 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=67, expected 67
DEBUG CONSTRNT: Checking LP row 68 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=68, expected 68
DEBUG CONSTRNT: Checking LP row 69 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=69, expected 69
DEBUG CONSTRNT: Checking LP row 70 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=70, expected 70
DEBUG CONSTRNT: Checking LP row 71 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=71, expected 71
DEBUG CONSTRNT: Checking LP row 72 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=72, expected 72
 % @PAP adding 61 rows, 255 nz to LP
DEBUG BB: Processing node 24, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 24 LP 3 Solution, length = 28707537.945296, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.116869 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.116869 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.116869 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.116869 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.116869 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.116869 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.065049 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.116869 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.883131 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.883131 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.883131 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.883131 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.883131 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.883131 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.883131 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28707537.945296, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28707537.945296, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 24 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 24
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.116869
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.116869)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.116869
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.116869)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.116869
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.116869)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.116869
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.116869)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.116869
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.116869)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.116869
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.116869)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.065049
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.065049)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.116869
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.116869)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[6] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[7] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
  % Initial guess is x4, Z0 = 28707537.9452961        , Z1 = 29046665.4381256        

DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=56, varin=59, theta=1.469240, up=999999999999999983222784.000000
ITER 2: row=21, varin=32, theta=0.834262, up=999999999999999983222784.000000
ITER 3: row=32, varin=56, theta=1.026492, up=999999999999999983222784.000000
ITER 4: row=27, varin=49, theta=1.622501, up=999999999999999983222784.000000
ITER 5: row=49, varin=47, theta=1.501072, up=999999999999999983222784.000000
ITER 6: row=45, varin=12, theta=0.931586, up=999999999999999983222784.000000
ITER 7: row=2, varin=13, theta=1.156156, up=999999999999999983222784.000000
ITER 8: row=11, varin=55, theta=1.141505, up=999999999999999983222784.000000
ITER 9: row=1, varin=78, theta=0.984332, up=1.000000
ITER 10: row=6, varin=52, theta=0.608665, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=28944496.323688
  % 	x22 = 1,	Z1 = 28944496.3236883        
DEBUG EVAL: First branch cutoff check: z=28944496.323688, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=56, varin=90, theta=0.072917, up=1.000000
ITER 2: row=45, varin=89, theta=0.072565, up=1.000000
  % 	x22 = 0,	Z0 = 28712943.6387953        
DEBUG EVAL: Second branch cutoff check: z=28712943.638795, best_z=INF, threshold=INF
  %   New best:  x22, Z = 28712943.6387953        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=50, theta=0.231510, up=999999999999999983222784.000000
ITER 2: row=58, varin=56, theta=0.341573, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28748091.311024
  % 	x17 = 0,	Z0 = 28748091.3110235        
DEBUG EVAL: First branch cutoff check: z=28748091.311024, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=42, varin=59, theta=5.180984, up=999999999999999983222784.000000
ITER 2: row=21, varin=56, theta=4.381326, up=999999999999999983222784.000000
ITER 3: row=27, varin=47, theta=6.189413, up=999999999999999983222784.000000
ITER 4: row=45, varin=78, theta=7.769819, up=1.000000
ITER 5: row=45, varin=12, theta=3.845203, up=999999999999999983222784.000000
ITER 6: row=2, varin=28, theta=3.717500, up=999999999999999983222784.000000
ITER 7: row=22, varin=39, theta=1.341120, up=999999999999999983222784.000000
ITER 8: row=51, varin=13, theta=5.337185, up=999999999999999983222784.000000
ITER 9: row=11, varin=55, theta=5.444812, up=999999999999999983222784.000000
ITER 10: row=1, varin=48, theta=5.325993, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=50, theta=0.231510, up=999999999999999983222784.000000
ITER 2: row=58, varin=56, theta=0.341573, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28748091.311024
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 61 rows, 60 cols, 315 nonzeros, 5 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 6 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=91, theta=8.664595, up=1.000000
ITER 2: row=59, varin=43, theta=0.158969, up=999999999999999983222784.000000
ITER 3: row=45, varin=91, theta=1.000000, up=1.000000
ITER 4: row=57, varin=90, theta=0.305489, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 28815016.803542
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 62 rows, 60 cols, 334 nonzeros, 4 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=89, theta=0.135150, up=1.000000
ITER 2: row=14, varin=102, theta=0.114082, up=1.000000
ITER 3: row=23, varin=97, theta=0.312129, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28823090.040183
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 59 rows, 60 cols, 316 nonzeros, 0 slack, 59 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=60, varin=43, theta=0.017818, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28827490.097512
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 61 rows, 60 cols, 320 nonzeros, 2 slack, 59 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=60, varin=94, theta=0.109925, up=1.000000
ITER 2: row=4, varin=106, theta=0.039735, up=1.000000
ITER 3: row=20, varin=91, theta=0.082923, up=1.000000
ITER 4: row=17, varin=92, theta=0.084451, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28830061.890243
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 60 rows, 60 cols, 318 nonzeros, 0 slack, 60 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 24 at  28.83006189024348486782
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60410f0
% @LO 0.08  28.70753794529606750530 99.9000000000
% @LN 0.08  28.71339904688793254195 99.9000000000
% Resuming node 65 at  28.71339904688793254195
DEBUG CONSTRNT: LP rows=60, pool->nlprows=60, pool->npend=0
DEBUG CONSTRNT: Checking 60 LP rows (pool tracks 60, total LP rows 60)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=59, expected 59
 % @PAP adding 34 rows, 189 nz to LP
DEBUG BB: Processing node 65, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=12, theta=0.125000, up=999999999999999983222784.000000
ITER 2: row=11, varin=13, theta=0.200000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28713399.046888
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.800000
DEBUG SOLUTION: lp->best_solution[13] = 1.800000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 34 rows, 60 cols, 249 nonzeros, 2 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=15, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28715333.799234
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 36 rows, 60 cols, 255 nonzeros, 3 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 65 LP 1 Solution, length = 28715333.799234, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28715333.799234, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.08  28.71339904688793254195 99.9000000000
 % @LN 0.08  28.71533379923420170599 99.9000000000
DEBUG CG: Second cutoff check: z=28715333.799234, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 65 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 65
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.500000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
  % Initial guess is x2, Z0 = 28715333.7992342        , Z1 = 28715333.7992342        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=32, theta=0.200000, up=999999999999999983222784.000000
ITER 2: row=23, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=28, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=18, varin=60, theta=1.000000, up=1.000000
ITER 5: row=4, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=22, varin=19, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28756773.056953
  % 	x2 = 1,	Z1 = 28756773.056953         
DEBUG EVAL: First branch cutoff check: z=28756773.056953, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=60, theta=0.250000, up=1.000000
  % 	x2 = 0,	Z0 = 28718704.3587676        
DEBUG EVAL: Second branch cutoff check: z=28718704.358768, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28718704.3587676        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=32, theta=0.200000, up=999999999999999983222784.000000
ITER 2: row=23, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=28, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=18, varin=60, theta=1.000000, up=1.000000
ITER 5: row=4, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=22, varin=25, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28930667.598468
  % 	x17 = 1,	Z1 = 28930667.5984684        
DEBUG EVAL: First branch cutoff check: z=28930667.598468, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=9, varin=60, theta=0.250000, up=1.000000
  % 	x17 = 0,	Z0 = 28718704.3587676        
DEBUG EVAL: Second branch cutoff check: z=28718704.358768, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28718704.3587676        
  % Best branch is x17, Z0 = 28718704.3587676        , Z1 = 28930667.5984684        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC   67   65	x17 = 0	28718704.358768
 % @NC   68   65	x17 = 1	28930667.598468
 %      65    27 28715333.7992               28716981.3421   x24 D    52    14
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6040360
% @LO 0.08  28.71533379923420170599 99.9000000000
% @LN 0.08  28.71698134212973840818 99.9000000000
% Resuming node 56 at  28.71698134212973840818
DEBUG CONSTRNT: LP rows=33, pool->nlprows=33, pool->npend=0
DEBUG CONSTRNT: Checking 33 LP rows (pool tracks 33, total LP rows 33)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=32, expected 32
 % @PAP adding 51 rows, 189 nz to LP
DEBUG BB: Processing node 56, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=102, theta=0.789474, up=1.000000
ITER 2: row=2, varin=75, theta=2.000000, up=1.000000
ITER 3: row=2, varin=36, theta=0.250000, up=999999999999999983222784.000000
ITER 4: row=23, varin=76, theta=1.000000, up=1.000000
ITER 5: row=3, varin=75, theta=1.000000, up=1.000000
ITER 6: row=49, varin=89, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28716981.342130
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 249 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=45, varin=74, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28760777.493665
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 253 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=5, theta=0.625000, up=999999999999999983222784.000000
ITER 2: row=11, varin=82, theta=1.000000, up=1.000000
ITER 3: row=44, varin=42, theta=0.416667, up=999999999999999983222784.000000
ITER 4: row=56, varin=79, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28806580.428904
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 269 nonzeros, 0 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=89, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28809370.822475
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 60 rows, 60 cols, 288 nonzeros, 0 slack, 60 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=61, varin=44, theta=5.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=64)
DEBUG SOLUTION: LP solution array indices: FST[65-104], not_covered[105-124]
DEBUG SOLUTION: lp->best_solution[0] = 28813838.175624
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 64 rows, 60 cols, 309 nonzeros, 6 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=87, theta=0.165034, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28819418.749497
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 305 nonzeros, 0 slack, 59 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=60, varin=33, theta=0.138988, up=999999999999999983222784.000000
ITER 2: row=47, varin=29, theta=0.032855, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28827459.213181
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 61 rows, 60 cols, 311 nonzeros, 2 slack, 59 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=60, varin=92, theta=0.187941, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28834605.631251
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 60 rows, 60 cols, 309 nonzeros, 0 slack, 60 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=61, varin=92, theta=0.174495, up=1.000000
ITER 2: row=13, varin=96, theta=0.136426, up=1.000000
ITER 3: row=4, varin=95, theta=0.190929, up=1.000000
ITER 4: row=9, varin=93, theta=0.048630, up=1.000000
ITER 5: row=59, varin=9, theta=0.065250, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 28840631.028318
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.934750
DEBUG SOLUTION: lp->best_solution[10] = 3.934750
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 62 rows, 60 cols, 321 nonzeros, 2 slack, 60 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 56 LP 1 Solution, length = 28840631.028318, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.065250 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.065250 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.369501 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.369501 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.065250 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.065250 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.369501 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.065250 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.065250 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.065250 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.369501 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.369501 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.934750 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.630499 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.934750 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.934750 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.630499 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.630499 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.630499 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.934750 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.630499 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.934750 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 12 fractional variables
DEBUG CG: LP optimal, z=28840631.028318, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 56 at  28.84063102831775537993
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60758b0
% @LO 0.08  28.71698134212973840818 99.9000000000
% @LN 0.08  28.71870435876755323079 99.9000000000
% Resuming node 67 at  28.71870435876755323079
DEBUG CONSTRNT: LP rows=60, pool->nlprows=60, pool->npend=0
DEBUG CONSTRNT: Checking 60 LP rows (pool tracks 60, total LP rows 60)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=59, expected 59
 % @PAP adding 33 rows, 173 nz to LP
DEBUG BB: Processing node 67, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=9, varin=60, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28718704.358768
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.750000
DEBUG SOLUTION: lp->best_solution[13] = 1.750000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 33 rows, 60 cols, 233 nonzeros, 2 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=2, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28747940.406237
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.500000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 37 rows, 60 cols, 250 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 67 LP 1 Solution, length = 28747940.406237, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28747940.406237, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 67 at  28.74794040623654112210
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f6043950
% @LO 0.08  28.71870435876755323079 99.9000000000
% @LN 0.08  28.72111405841651787796 99.9000000000
% Resuming node 38 at  28.72111405841651787796
DEBUG CONSTRNT: LP rows=35, pool->nlprows=35, pool->npend=0
DEBUG CONSTRNT: Checking 35 LP rows (pool tracks 35, total LP rows 35)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=34, expected 34
 % @PAP adding 54 rows, 229 nz to LP
DEBUG BB: Processing node 38, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 38 LP 4 Solution, length = 28721114.058417, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.281151 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.281151 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.281151 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.281151 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.156547 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.281151 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.718849 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.718849 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.718849 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.718849 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.718849 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.718849 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.718849 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28721114.058417, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28721114.058417, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 38 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 38
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.281151
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.281151)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.281151
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.281151)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.281151
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.281151)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.281151
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.281151)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.156547
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.156547)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.281151
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.281151)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x22, Z0 = 28721114.0584165        , Z1 = 28944110.6414666        

DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=54, theta=0.881255, up=999999999999999983222784.000000
ITER 2: row=54, varin=40, theta=2.125559, up=999999999999999983222784.000000
ITER 3: row=36, varin=51, theta=0.834435, up=999999999999999983222784.000000
ITER 4: row=51, varin=23, theta=0.973832, up=999999999999999983222784.000000
ITER 5: row=23, varin=48, theta=0.889927, up=999999999999999983222784.000000
ITER 6: row=47, varin=47, theta=452890.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=30000492.288325
  % 	x22 = 1,	Z1 = 30000492.2883253        
DEBUG EVAL: First branch cutoff check: z=30000492.288325, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=39, varin=79, theta=0.329097, up=1.000000
ITER 2: row=3, varin=83, theta=0.170103, up=1.000000
  % 	x22 = 0,	Z0 = 28725172.6428478        
DEBUG EVAL: Second branch cutoff check: z=28725172.642848, best_z=INF, threshold=INF
  %   New best:  x22, Z = 28725172.6428478        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=79, theta=4.416457, up=1.000000
ITER 2: row=37, varin=37, theta=0.603363, up=999999999999999983222784.000000
ITER 3: row=3, varin=105, theta=2.000000, up=1.000000
ITER 4: row=3, varin=7, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=11, varin=79, theta=0.875000, up=1.000000
ITER 6: row=12, varin=105, theta=1.000000, up=1.000000
ITER 7: row=41, varin=92, theta=1.739202, up=1.000000
ITER 8: row=41, varin=47, theta=192489.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28854511.554692
  % 	x17 = 0,	Z0 = 28854511.5546919        
DEBUG EVAL: First branch cutoff check: z=28854511.554692, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=37, varin=40, theta=3.575264, up=999999999999999983222784.000000
ITER 2: row=36, varin=54, theta=50.273651, up=999999999999999983222784.000000
ITER 3: row=54, varin=44, theta=4.107484, up=999999999999999983222784.000000
ITER 4: row=31, varin=27, theta=2.831465, up=999999999999999983222784.000000
ITER 5: row=47, varin=17, theta=1.385710, up=999999999999999983222784.000000
ITER 6: row=10, varin=45, theta=3.669543, up=999999999999999983222784.000000
ITER 7: row=1, varin=6, theta=0.920395, up=999999999999999983222784.000000
ITER 8: row=39, varin=80, theta=1.549800, up=1.000000
ITER 9: row=39, varin=83, theta=0.608546, up=1.000000
ITER 10: row=6, varin=42, theta=3.434488, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=79, theta=4.416457, up=1.000000
ITER 2: row=37, varin=37, theta=0.603363, up=999999999999999983222784.000000
ITER 3: row=3, varin=105, theta=2.000000, up=1.000000
ITER 4: row=3, varin=7, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=11, varin=79, theta=0.875000, up=1.000000
ITER 6: row=12, varin=105, theta=1.000000, up=1.000000
ITER 7: row=41, varin=92, theta=1.739202, up=1.000000
ITER 8: row=41, varin=47, theta=192489.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
ITER 9: row=21, varin=41, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28854511.554692
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 289 nonzeros, 1 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=46, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28912132.812118
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 269 nonzeros, 3 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 3 rows, 46 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=95, theta=0.372748, up=1.000000
ITER 2: row=55, varin=57, theta=91879.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28928121.726792
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 297 nonzeros, 1 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=89, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28929516.923577
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 60 rows, 60 cols, 276 nonzeros, 0 slack, 60 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=61, varin=118, theta=0.250000, up=1.000000
ITER 2: row=60, varin=92, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=64)
DEBUG SOLUTION: LP solution array indices: FST[65-104], not_covered[105-124]
DEBUG SOLUTION: lp->best_solution[0] = 28948657.932665
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 64 rows, 60 cols, 297 nonzeros, 0 slack, 64 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=65, varin=96, theta=0.375000, up=1.000000
ITER 2: row=13, varin=16, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=2, varin=32, theta=0.100000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=66)
DEBUG SOLUTION: LP solution array indices: FST[67-106], not_covered[107-126]
DEBUG SOLUTION: lp->best_solution[0] = 28973208.141896
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 66 rows, 60 cols, 303 nonzeros, 2 slack, 64 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=65, varin=37, theta=0.052632, up=999999999999999983222784.000000
ITER 2: row=40, varin=96, theta=0.500000, up=1.000000
ITER 3: row=8, varin=99, theta=0.125000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=65)
DEBUG SOLUTION: LP solution array indices: FST[66-105], not_covered[106-125]
DEBUG SOLUTION: lp->best_solution[0] = 28983078.173560
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.875000
DEBUG SOLUTION: lp->best_solution[10] = 3.875000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 65 rows, 60 cols, 301 nonzeros, 2 slack, 63 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=64, varin=96, theta=0.286620, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=64)
DEBUG SOLUTION: LP solution array indices: FST[65-104], not_covered[105-124]
DEBUG SOLUTION: lp->best_solution[0] = 28985326.696467
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
   % @PL 64 rows, 60 cols, 334 nonzeros, 0 slack, 64 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=65, varin=99, theta=0.303599, up=1.000000
ITER 2: row=62, varin=51, theta=0.197180, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=66)
DEBUG SOLUTION: LP solution array indices: FST[67-106], not_covered[107-126]
DEBUG SOLUTION: lp->best_solution[0] = 28997067.164181
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
   % @PL 66 rows, 60 cols, 346 nonzeros, 2 slack, 64 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 38 at  28.99706716418131335899
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5587f60478a0
% @LO 0.08  28.72111405841651787796 99.9000000000
% @LN 0.08  28.72232736216820470077 99.9000000000
% Resuming node 46 at  28.72232736216820470077
DEBUG CONSTRNT: LP rows=64, pool->nlprows=64, pool->npend=0
DEBUG CONSTRNT: Checking 64 LP rows (pool tracks 64, total LP rows 64)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=63, expected 63
 % @PAP adding 50 rows, 225 nz to LP
DEBUG BB: Processing node 46, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=50, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=1, varin=49, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=17, theta=0.441176, up=999999999999999983222784.000000
ITER 4: row=10, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=46, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=40, varin=6, theta=0.384615, up=999999999999999983222784.000000
ITER 7: row=6, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=44, varin=7, theta=0.483871, up=999999999999999983222784.000000
ITER 9: row=17, varin=38, theta=0.500000, up=999999999999999983222784.000000
ITER 10: row=38, varin=36, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28722327.362168
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 285 nonzeros, 6 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 54 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=37, theta=0.425751, up=999999999999999983222784.000000
ITER 2: row=42, varin=34, theta=0.329443, up=999999999999999983222784.000000
ITER 3: row=51, varin=61, theta=0.989385, up=1.000000
ITER 4: row=38, varin=56, theta=1.276323, up=1.000000
ITER 5: row=38, varin=65, theta=0.490420, up=1.000000
ITER 6: row=17, varin=56, theta=1.000000, up=1.000000
ITER 7: row=42, varin=91, theta=1.522077, up=1.000000
ITER 8: row=42, varin=55, theta=0.399452, up=1.000000
ITER 9: row=40, varin=91, theta=1.000000, up=1.000000
ITER 10: row=11, varin=29, theta=1.403755, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=15)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 29133314.613513
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 339 nonzeros, 5 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 46 LP 1 Solution, length = 29133314.613513, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 0 fractional variables
DEBUG CG: LP optimal, z=29133314.613513, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG IFS: Budget mode - accepting integer solution with 2 edges covering 5 vertices
DEBUG CG: integer_feasible_solution returned: TRUE
DEBUG CG: Solution is integer feasible, returning LB_INTEGRAL
DEBUG BB: compute_good_lower_bound returned status=3
DEBUG BB: Node 46 is INTEGRAL (integer solution found)
 %  	=== 26 nodes cut off ===
 % @UO 0.08   6.63331461351344398025 -333.0011319477
 % @UN 0.08   6.63331461351344398025 -333.0011319477
DEBUG BB: Calling heuristic UB for integer solution, current best_z=6633314.613513
DEBUG BB: Heuristic did not improve integer solution
 % *    46     0  6633314.6135  6633314.6135                  x3 U    33    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=(nil)
DEBUG BB: No more nodes to process, exiting

 % Certificate of solution:
 % @C	.4767008182741058	.2081993675729823
 % @C	.9403396951594272	.1625324412900069
%%Page: 1 1
BeginPlot
	Plot_Terminals
 % fs2: 13 0 6
	13 T	.4767008182741058	.2081993675729823	S
	.4767008182741058	.2081993675729823	0 T	S
	.4767008182741058	.2081993675729823	6 T	S
 % fs3: 15 3 6
	15 T	.9403396951594272	.1625324412900069	S
	.9403396951594272	.1625324412900069	3 T	S
	.9403396951594272	.1625324412900069	6 T	S
  (Euclidean SMT:  20 points,  length = 6.633314613513443,  0.09 seconds)
EndPlot

% @0 Euclidean SMT
% N M Nodes LPs P1CPU P2CPU TotCPU
% @1 20 40 55 120 0.00 0.09 0.09
% Z RootZ %Gap RootLPs RootCPU RedMST
% @2 6.633314613513443 27585120.458537 -315.85726 1 0.00 -112.1455
% InitPRows InitPNZ InitLPRows InitLPNZ
% @3 163 594 135 555
% RootPRows RootPNZ RootLPRows RootLPNZ
% @4 163 594 72 346
% FinalPRows FinalPNZ FinalLPRows FinalLPNZ
% @5 164 606 49 253
% SMTFSTs SMTAvgFSTSz SMTMaxFSTSz #2FSTs #3FSTs ... #10FSTS #>10FSTs
% @6 2 3.000000 3 0 2 0 0 0 0 0 0 0 0
