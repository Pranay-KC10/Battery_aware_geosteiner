 % ./bb
 % Args:
DEBUG P1READ: Terminal 0 battery=38.30
DEBUG P1READ: Terminal 1 battery=88.60
DEBUG P1READ: Terminal 2 battery=77.70
DEBUG P1READ: Terminal 3 battery=91.50
DEBUG P1READ: Terminal 4 battery=79.30
DEBUG P1READ: Terminal 5 battery=33.50
DEBUG P1READ: Terminal 6 battery=38.60
DEBUG P1READ: Terminal 7 battery=49.20
DEBUG P1READ: Terminal 8 battery=64.90
DEBUG P1READ: Terminal 9 battery=42.10
DEBUG HG: num_verts=10, num_edges=14
 % Phase 1: 0.00 seconds

%%BeginSetup

0 1 0 1 SetAxes

10 DefineTerminals
	.4588350000000000	.2373240000000000	DT
	.1270640000000000	.3509960000000000	DT
	.1544540000000000	.4808220000000000	DT
	.9474030000000000	.1441120000000000	DT
	.2867390000000000	.0565890000000000	DT
	.1326890000000000	.1166050000000000	DT
	.6273950000000000	.2122140000000000	DT
	.0794880000000000	.7970990000000000	DT
	.0327480000000000	.8803250000000000	DT
	.3110550000000000	.8689670000000000	DT

%%EndSetup

DEBUG ALGO: num_verts=10 <= 8? NO, num_edges=14 <= 12? NO
DEBUG ALGO: Forcing BRANCH-AND-CUT for multi-objective optimization (vertices=10 > 1)
DEBUG SPANNING: Adding modified spanning constraint for budget mode
DEBUG SPANNING: Added modified spanning constraint: Σ(|FST|-1)*x + Σnot_covered = 9
DEBUG CONSTRAINT: Adding soft cutset constraints with not_covered variables
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 4·not_covered[0] ≤ 4 for terminal 0
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 4·not_covered[1] ≤ 4 for terminal 1
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[2] ≤ 3 for terminal 2
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 1·not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[4] ≤ 5 for terminal 4
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[5] ≤ 5 for terminal 5
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[6] ≤ 2 for terminal 6
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[7] ≤ 5 for terminal 7
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[8] ≤ 2 for terminal 8
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[9] ≤ 3 for terminal 9
DEBUG CONSTRAINT: Added source terminal constraint: not_covered[0] = 0
DEBUG BUDGET: Adding budget constraint ≤ 1500000.000 to constraint pool
DEBUG BUDGET: Using raw tree costs directly
DEBUG BUDGET: Budget limit: 1500000.000
DEBUG BUDGET: Building raw cost constraint coefficients:
DEBUG BUDGET:   x[0] coefficient = 413997 (raw=413997.047)
DEBUG BUDGET:   x[1] coefficient = 398991 (raw=398991.100)
DEBUG BUDGET:   x[2] coefficient = 553168 (raw=553168.855)
DEBUG BUDGET:   x[3] coefficient = 334575 (raw=334575.182)
DEBUG BUDGET:   x[4] coefficient = 645195 (raw=645195.047)
DEBUG BUDGET:   x[5] coefficient = 95452 (raw=95452.578)
DEBUG BUDGET:   x[6] coefficient = 132683 (raw=132683.844)
DEBUG BUDGET:   x[7] coefficient = 165327 (raw=165327.925)
DEBUG BUDGET:   x[8] coefficient = 170420 (raw=170420.027)
DEBUG BUDGET:   x[9] coefficient = 234458 (raw=234458.486)
DEBUG BUDGET:   x[10] coefficient = 242462 (raw=242462.956)
DEBUG BUDGET:   x[11] coefficient = 249563 (raw=249563.967)
DEBUG BUDGET:   x[12] coefficient = 325040 (raw=325040.062)
DEBUG BUDGET:   x[13] coefficient = 327174 (raw=327174.269)
DEBUG BUDGET: Constraint: Σ tree_cost[i] * x[i] ≤ 1500000
DEBUG BUDGET: Budget constraint added to pool with 14 FSTs
 % _gst_initialize_constraint_pool: 0.00 seconds.
 % Constraint pool initialized with:
 % 	1	Total degree rows	14	coeffs.
 % 	10	Cutset rows		34	coeffs.
 % 	0	Incompatibility rows	0	coeffs.
 % 	8	2-terminal SEC rows	21	coeffs.
 % 	54	Total rows in pool	46	in LP
 % @PMEM 54 rows, 1 blocks, 52 nzfree, 0 nzwasted, 276 nztotal
 % cpx allocation: 108 rows, 24 cols, 680 nz
 % _gst_build_initial_formulation: 0.00 seconds.
DEBUG BB: Expected nlprows=46, total rows=54
DEBUG BB: Row 0 (uid=0) has lprow=0 (included, j=0)
DEBUG BB: Row 1 (uid=1) has lprow=1 (included, j=1)
DEBUG BB: Row 2 (uid=2) has lprow=2 (included, j=2)
DEBUG BB: Row 3 (uid=3) has lprow=3 (included, j=3)
DEBUG BB: Row 4 (uid=4) has lprow=4 (included, j=4)
DEBUG BB: Row 5 (uid=5) has lprow=5 (included, j=5)
DEBUG BB: Row 6 (uid=6) has lprow=6 (included, j=6)
DEBUG BB: Row 7 (uid=7) has lprow=7 (included, j=7)
DEBUG BB: Row 8 (uid=8) has lprow=8 (included, j=8)
DEBUG BB: Row 9 (uid=9) has lprow=9 (included, j=9)
DEBUG BB: Row 10 (uid=10) has lprow=10 (included, j=10)
DEBUG BB: Row 11 (uid=11) has lprow=11 (included, j=11)
DEBUG BB: Row 12 (uid=12) has lprow=12 (included, j=12)
DEBUG BB: Row 13 (uid=13) has lprow=13 (included, j=13)
DEBUG BB: Row 14 (uid=14) has lprow=14 (included, j=14)
DEBUG BB: Row 15 (uid=15) has lprow=15 (included, j=15)
DEBUG BB: Row 16 (uid=16) has lprow=16 (included, j=16)
DEBUG BB: Row 17 (uid=17) has lprow=17 (included, j=17)
DEBUG BB: Row 18 (uid=18) has lprow=18 (included, j=18)
DEBUG BB: Row 19 (uid=19) has lprow=19 (included, j=19)
DEBUG BB: Row 20 (uid=20) has lprow=20 (included, j=20)
DEBUG BB: Row 21 (uid=21) has lprow=21 (included, j=21)
DEBUG BB: Row 22 (uid=22) has lprow=22 (included, j=22)
DEBUG BB: Row 23 (uid=23) has lprow=23 (included, j=23)
DEBUG BB: Row 24 (uid=24) has lprow=24 (included, j=24)
DEBUG BB: Row 25 (uid=25) has lprow=25 (included, j=25)
DEBUG BB: Row 26 (uid=26) has lprow=26 (included, j=26)
DEBUG BB: Row 27 (uid=27) has lprow=27 (included, j=27)
DEBUG BB: Row 28 (uid=28) has lprow=28 (included, j=28)
DEBUG BB: Row 29 (uid=29) has lprow=29 (included, j=29)
DEBUG BB: Row 30 (uid=30) has lprow=30 (included, j=30)
DEBUG BB: Row 31 (uid=31) has lprow=31 (included, j=31)
DEBUG BB: Row 32 (uid=32) has lprow=32 (included, j=32)
DEBUG BB: Row 33 (uid=33) has lprow=33 (included, j=33)
DEBUG BB: Row 34 (uid=34) has lprow=34 (included, j=34)
DEBUG BB: Row 35 (uid=35) has lprow=35 (included, j=35)
DEBUG BB: Row 36 (uid=36) has lprow=36 (included, j=36)
DEBUG BB: Row 37 (uid=37) has lprow=37 (included, j=37)
DEBUG BB: Row 38 (uid=38) has lprow=38 (included, j=38)
DEBUG BB: Row 39 (uid=39) has lprow=39 (included, j=39)
DEBUG BB: Row 40 (uid=40) has lprow=40 (included, j=40)
DEBUG BB: Row 41 (uid=41) has lprow=41 (included, j=41)
DEBUG BB: Row 42 (uid=42) has lprow=42 (included, j=42)
DEBUG BB: Row 43 (uid=43) has lprow=43 (included, j=43)
DEBUG BB: Row 44 (uid=44) has lprow=44 (included, j=44)
DEBUG BB: Row 45 (uid=45) has lprow=-1 (skipped)
DEBUG BB: Row 46 (uid=46) has lprow=-1 (skipped)
DEBUG BB: Row 47 (uid=47) has lprow=-1 (skipped)
DEBUG BB: Row 48 (uid=48) has lprow=-1 (skipped)
DEBUG BB: Row 49 (uid=49) has lprow=-1 (skipped)
DEBUG BB: Row 50 (uid=50) has lprow=-1 (skipped)
DEBUG BB: Row 51 (uid=51) has lprow=-1 (skipped)
DEBUG BB: Row 52 (uid=52) has lprow=-1 (skipped)
DEBUG BB: Row 53 (uid=53) has lprow=45 (included, j=45)
DEBUG BB: Found 46 actual LP rows, expected 46
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee40300
% Resuming node 0
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 1
DEBUG CONSTRNT: Pool row 1 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 2
DEBUG CONSTRNT: Pool row 2 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 4
DEBUG CONSTRNT: Pool row 4 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=45, expected 45
 % @PAP adding 46 rows, 149 nz to LP
DEBUG BB: Processing node 0, calling compute_good_lower_bound
  % @PL 46 rows, 24 cols, 149 nonzeros, 28 slack, 18 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 28 slack rows
  % @PAP adding 2 rows, 6 nz to LP
  % @PL 20 rows, 24 cols, 76 nonzeros, 6 slack, 14 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 3 rows, 8 nz to LP
  % @PL 17 rows, 24 cols, 71 nonzeros, 3 slack, 14 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 5 nz to LP
  % @PL 16 rows, 24 cols, 70 nonzeros, 3 slack, 13 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 0 LP 1 Solution, length = 2881297.503793, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.691388 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.308612 (FST 3)
  % DEBUG LP_VARS: x[4] = 1.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.691388 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.308612 (terminal 9)
 % 3 fractional variables
DEBUG CG: LP optimal, z=2881297.503793, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00   2.88129750379339188981 99.9000000000
 % @LN 0.00   2.88129750379339188981 99.9000000000
DEBUG CG: Second cutoff check: z=2881297.503793, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 0 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 0
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.691388
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.691388)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.308612
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.308612)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=1.000000
DEBUG CAREFUL: Skipping var 4: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.691388
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.691388)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
  % Initial guess is x2, Z0 = 2881297.50379339        , Z1 = 2942242.42208523        

DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 6, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=6, dir=1
DEBUG TRY_BRANCH: After decrement, var=5
DEBUG EVAL: try_branch returned z=2886107.017334
DEBUG EVAL: Branch var 5 = 1 gives z=2886107.017334
  % 	x5 = 1,	Z1 = 2886107.01733417        
DEBUG EVAL: First branch cutoff check: z=2886107.017334, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
DEBUG EVAL: Calling try_branch(lp, 6, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=6, dir=0
DEBUG TRY_BRANCH: After decrement, var=5
DEBUG EVAL: Second branch returned z=2904387.210653
  % 	x5 = 0,	Z0 = 2904387.21065291        
DEBUG EVAL: Second branch cutoff check: z=2904387.210653, best_z=INF, threshold=INF
  %   New best:  x5, Z = 2886107.01733417        
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 3, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=3, dir=1
DEBUG TRY_BRANCH: After decrement, var=2
DEBUG EVAL: try_branch returned z=2968743.864470
DEBUG EVAL: Branch var 2 = 1 gives z=2968743.864470
  % 	x2 = 1,	Z1 = 2968743.86446961        
DEBUG EVAL: First branch cutoff check: z=2968743.864470, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
DEBUG EVAL: Calling try_branch(lp, 3, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=3, dir=0
DEBUG TRY_BRANCH: After decrement, var=2
DEBUG EVAL: Second branch returned z=2904387.210653
  % 	x2 = 0,	Z0 = 2904387.21065291        
DEBUG EVAL: Second branch cutoff check: z=2904387.210653, best_z=INF, threshold=INF
  %   New best:  x2, Z = 2904387.21065291        
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 4, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=0
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: try_branch returned z=2886107.017334
DEBUG EVAL: Branch var 3 = 0 gives z=2886107.017334
  % 	x3 = 0,	Z0 = 2886107.01733417        
DEBUG EVAL: First branch cutoff check: z=2886107.017334, best_z=INF, threshold=INF
  % Best branch is x2, Z0 = 2904387.21065291        , Z1 = 2968743.86446961        

DEBUG CAREFUL: Final result - returning best.var = 2
DEBUG BB: Branching variable chosen: j=2
 % @NC    1    0	x2 = 0	2904387.210653
 % @NC    2    0	x2 = 1	2968743.864470
 %       0     2  2881297.5038                2904387.2107
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee407f0
% @LO 0.00   2.88129750379339188981 99.9000000000
% @LN 0.00   2.90438721065290605949 99.9000000000
% Resuming node 1 at   2.90438721065290605949
DEBUG CONSTRNT: LP rows=13, pool->nlprows=13, pool->npend=0
DEBUG CONSTRNT: Checking 13 LP rows (pool tracks 13, total LP rows 13)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
 % @PAP adding 13 rows, 64 nz to LP
DEBUG BB: Processing node 1, calling compute_good_lower_bound
  % @PL 13 rows, 24 cols, 64 nonzeros, 0 slack, 13 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 14 rows, 24 cols, 66 nonzeros, 0 slack, 14 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 15 rows, 24 cols, 68 nonzeros, 0 slack, 15 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 16 rows, 24 cols, 70 nonzeros, 0 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 17 rows, 24 cols, 72 nonzeros, 0 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 1 LP 1 Solution, length = 2906059.969722, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.888953 (FST 3)
  % DEBUG LP_VARS: x[4] = 1.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.111047 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.111047 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.666860 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.111047 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.111047 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.111047 (terminal 9)
 % 4 fractional variables
DEBUG CG: LP optimal, z=2906059.969722, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00   2.90438721065290605949 99.9000000000
 % @LN 0.00   2.90605996972247337951 99.9000000000
DEBUG CG: Second cutoff check: z=2906059.969722, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 1 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 1
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.888953
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.888953)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=1.000000
DEBUG CAREFUL: Skipping var 4: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.111047
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.111047)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.111047
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.111047)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.666860
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.666860)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[3] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
  % Initial guess is x12, Z0 = 2906059.96972247        , Z1 = 3003923.47636495        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 4, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=1
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: try_branch returned z=2906598.248451
DEBUG EVAL: Branch var 3 = 1 gives z=2906598.248451
  % 	x3 = 1,	Z1 = 2906598.24845081        
DEBUG EVAL: First branch cutoff check: z=2906598.248451, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
DEBUG EVAL: Calling try_branch(lp, 4, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=0
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: Second branch returned z=2919450.784841
  % 	x3 = 0,	Z0 = 2919450.78484121        
DEBUG EVAL: Second branch cutoff check: z=2919450.784841, best_z=INF, threshold=INF
  %   New best:  x3, Z = 2906598.24845081        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 11, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=11, dir=1
DEBUG TRY_BRANCH: After decrement, var=10
DEBUG EVAL: try_branch returned z=2919450.784841
DEBUG EVAL: Branch var 10 = 1 gives z=2919450.784841
  % 	x10 = 1,	Z1 = 2919450.78484121        
DEBUG EVAL: First branch cutoff check: z=2919450.784841, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
DEBUG EVAL: Calling try_branch(lp, 11, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=11, dir=0
DEBUG TRY_BRANCH: After decrement, var=10
DEBUG EVAL: Second branch returned z=2906598.248451
  % 	x10 = 0,	Z0 = 2906598.24845081        
DEBUG EVAL: Second branch cutoff check: z=2906598.248451, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 13, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=13, dir=1
DEBUG TRY_BRANCH: After decrement, var=12
DEBUG EVAL: try_branch returned z=3013229.725766
DEBUG EVAL: Branch var 12 = 1 gives z=3013229.725766
  % 	x12 = 1,	Z1 = 3013229.7257658         
DEBUG EVAL: First branch cutoff check: z=3013229.725766, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
DEBUG EVAL: Calling try_branch(lp, 13, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=13, dir=0
DEBUG TRY_BRANCH: After decrement, var=12
DEBUG EVAL: Second branch returned z=2910588.338008
  % 	x12 = 0,	Z0 = 2910588.33800839        
DEBUG EVAL: Second branch cutoff check: z=2910588.338008, best_z=INF, threshold=INF
  %   New best:  x12, Z = 2910588.33800839        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 6, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=6, dir=0
DEBUG TRY_BRANCH: After decrement, var=5
DEBUG EVAL: try_branch returned z=2906598.248451
DEBUG EVAL: Branch var 5 = 0 gives z=2906598.248451
  % 	x5 = 0,	Z0 = 2906598.24845081        
DEBUG EVAL: First branch cutoff check: z=2906598.248451, best_z=INF, threshold=INF
  % Best branch is x12, Z0 = 2910588.33800839        , Z1 = 3013229.7257658         

DEBUG CAREFUL: Final result - returning best.var = 12
DEBUG BB: Branching variable chosen: j=12
 % @NC    3    1	x12 = 0	2910588.338008
 % @NC    4    1	x12 = 1	3013229.725766
 %       1     3  2906059.9697                2910588.3380    x2 D     0     1
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee40300
% @LO 0.00   2.90605996972247337951 99.9000000000
% @LN 0.00   2.91058833800838723249 99.9000000000
% Resuming node 3 at   2.91058833800838723249
DEBUG CONSTRNT: LP rows=17, pool->nlprows=17, pool->npend=0
DEBUG CONSTRNT: Checking 17 LP rows (pool tracks 17, total LP rows 17)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
 % @PAP adding 17 rows, 72 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % @PL 17 rows, 24 cols, 72 nonzeros, 0 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 18 rows, 24 cols, 74 nonzeros, 0 slack, 18 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 3 LP 1 Solution, length = 2913899.525234, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.666667 (FST 3)
  % DEBUG LP_VARS: x[4] = 1.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.333333 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.660242 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.339758 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.333333 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
 % 4 fractional variables
DEBUG CG: LP optimal, z=2913899.525234, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00   2.91058833800838723249 99.9000000000
 % @LN 0.00   2.91389952523449258237 99.9000000000
DEBUG CG: Second cutoff check: z=2913899.525234, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.666667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=1.000000
DEBUG CAREFUL: Skipping var 4: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.333333
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.660242
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.660242)
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[2] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[3] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
  % Initial guess is x13, Z0 = 2913899.52523449        , Z1 = 3012694.06331147        

DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 11, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=11, dir=1
DEBUG TRY_BRANCH: After decrement, var=10
DEBUG EVAL: try_branch returned z=2923895.627507
DEBUG EVAL: Branch var 10 = 1 gives z=2923895.627507
  % 	x10 = 1,	Z1 = 2923895.62750686        
DEBUG EVAL: First branch cutoff check: z=2923895.627507, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
DEBUG EVAL: Calling try_branch(lp, 11, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=11, dir=0
DEBUG TRY_BRANCH: After decrement, var=10
DEBUG EVAL: Second branch returned z=2915493.957436
  % 	x10 = 0,	Z0 = 2915493.95743586        
DEBUG EVAL: Second branch cutoff check: z=2915493.957436, best_z=INF, threshold=INF
  %   New best:  x10, Z = 2915493.95743586        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 4, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=1
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: try_branch returned z=2915493.957436
DEBUG EVAL: Branch var 3 = 1 gives z=2915493.957436
  % 	x3 = 1,	Z1 = 2915493.95743586        
DEBUG EVAL: First branch cutoff check: z=2915493.957436, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
DEBUG EVAL: Calling try_branch(lp, 4, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=0
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: Second branch returned z=2923895.627507
  % 	x3 = 0,	Z0 = 2923895.62750686        
DEBUG EVAL: Second branch cutoff check: z=2923895.627507, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 6, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=6, dir=0
DEBUG TRY_BRANCH: After decrement, var=5
DEBUG EVAL: try_branch returned z=2915493.957436
DEBUG EVAL: Branch var 5 = 0 gives z=2915493.957436
  % 	x5 = 0,	Z0 = 2915493.95743585        
DEBUG EVAL: First branch cutoff check: z=2915493.957436, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
DEBUG EVAL: Calling try_branch(lp, 6, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=6, dir=1
DEBUG TRY_BRANCH: After decrement, var=5
DEBUG EVAL: Second branch returned z=2923895.627507
  % 	x5 = 1,	Z1 = 2923895.62750686        
DEBUG EVAL: Second branch cutoff check: z=2923895.627507, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 14, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=14, dir=1
DEBUG TRY_BRANCH: After decrement, var=13
DEBUG EVAL: try_branch returned z=3025566.718868
DEBUG EVAL: Branch var 13 = 1 gives z=3025566.718868
  % 	x13 = 1,	Z1 = 3025566.71886773        
DEBUG EVAL: First branch cutoff check: z=3025566.718868, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
DEBUG EVAL: Calling try_branch(lp, 14, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=14, dir=0
DEBUG TRY_BRANCH: After decrement, var=13
DEBUG EVAL: Second branch returned z=3349537.550442
  % 	x13 = 0,	Z0 = 3349537.55044233        
DEBUG EVAL: Second branch cutoff check: z=3349537.550442, best_z=INF, threshold=INF
  %   New best:  x13, Z = 3025566.71886773        
  % Best branch is x13, Z0 = 3349537.55044233        , Z1 = 3025566.71886773        

DEBUG CAREFUL: Final result - returning best.var = 13
DEBUG BB: Branching variable chosen: j=13
 % @NC    5    3	x13 = 1	3025566.718868
 % @NC    6    3	x13 = 0	3349537.550442
 %       3     4  2913899.5252                2968743.8645   x12 D     1     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee62420
% @LO 0.00   2.91389952523449258237 99.9000000000
% @LN 0.00   2.96874386446961313624 99.9000000000
% Resuming node 2 at   2.96874386446961313624
DEBUG CONSTRNT: LP rows=18, pool->nlprows=18, pool->npend=0
DEBUG CONSTRNT: Checking 18 LP rows (pool tracks 18, total LP rows 18)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=17, expected 17
 % @PAP adding 13 rows, 64 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
  % @PL 13 rows, 24 cols, 64 nonzeros, 2 slack, 11 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 14 rows, 24 cols, 66 nonzeros, 2 slack, 12 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 2 LP 1 Solution, length = 2968743.864470, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.393649 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.606351 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.393649 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 2 fractional variables
DEBUG CG: LP optimal, z=2968743.864470, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=2968743.864470, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.393649
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.393649)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.606351
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.606351)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x4, Z0 = 2968743.86446961        , Z1 = 2968743.86446961        

DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 5, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=5, dir=1
DEBUG TRY_BRANCH: After decrement, var=4
DEBUG EVAL: try_branch returned z=3140929.882357
DEBUG EVAL: Branch var 4 = 1 gives z=3140929.882357
  % 	x4 = 1,	Z1 = 3140929.8823568         
DEBUG EVAL: First branch cutoff check: z=3140929.882357, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
DEBUG EVAL: Calling try_branch(lp, 5, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=5, dir=0
DEBUG TRY_BRANCH: After decrement, var=4
DEBUG EVAL: Second branch returned z=2978642.341316
  % 	x4 = 0,	Z0 = 2978642.34131559        
DEBUG EVAL: Second branch cutoff check: z=2978642.341316, best_z=INF, threshold=INF
  %   New best:  x4, Z = 2978642.34131559        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 2, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=0
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: try_branch returned z=2971336.108643
DEBUG EVAL: Branch var 1 = 0 gives z=2971336.108643
  % 	x1 = 0,	Z0 = 2971336.108643          
DEBUG EVAL: First branch cutoff check: z=2971336.108643, best_z=INF, threshold=INF
  % Best branch is x4, Z0 = 2978642.34131559        , Z1 = 3140929.8823568         

DEBUG CAREFUL: Final result - returning best.var = 4
DEBUG BB: Branching variable chosen: j=4
 % @NC    7    2	x4 = 0	2978642.341316
 % @NC    8    2	x4 = 1	3140929.882357
 %       2     5  2968743.8645                2978642.3413    x2 U     0     1
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee40300
% @LO 0.00   2.96874386446961313624 99.9000000000
% @LN 0.00   2.97864234131559157959 99.9000000000
% Resuming node 7 at   2.97864234131559157959
DEBUG CONSTRNT: LP rows=14, pool->nlprows=14, pool->npend=0
DEBUG CONSTRNT: Checking 14 LP rows (pool tracks 14, total LP rows 14)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=13, expected 13
 % @PAP adding 14 rows, 66 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
  % @PL 14 rows, 24 cols, 66 nonzeros, 2 slack, 12 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 7 LP 1 Solution, length = 2978642.341316, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.598427 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.401573 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.598427 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.401573 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 3 fractional variables
DEBUG CG: LP optimal, z=2978642.341316, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=2978642.341316, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.598427
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.598427)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.401573
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.401573)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.598427
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.598427)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
  % Initial guess is x0, Z0 = 2978642.34131559        , Z1 = 2985284.68965017        

DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 2, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=0
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: try_branch returned z=2981265.444299
DEBUG EVAL: Branch var 1 = 0 gives z=2981265.444299
  % 	x1 = 0,	Z0 = 2981265.44429897        
DEBUG EVAL: First branch cutoff check: z=2981265.444299, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
DEBUG EVAL: Calling try_branch(lp, 2, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=1
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: Second branch returned z=2981618.057088
  % 	x1 = 1,	Z1 = 2981618.05708824        
DEBUG EVAL: Second branch cutoff check: z=2981618.057088, best_z=INF, threshold=INF
  %   New best:  x1, Z = 2981265.44429897        
DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 1, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=1, dir=1
DEBUG TRY_BRANCH: After decrement, var=0
DEBUG EVAL: try_branch returned z=3002010.424316
DEBUG EVAL: Branch var 0 = 1 gives z=3002010.424316
  % 	x0 = 1,	Z1 = 3002010.42431554        
DEBUG EVAL: First branch cutoff check: z=3002010.424316, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 0
DEBUG EVAL: Calling try_branch(lp, 1, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=1, dir=0
DEBUG TRY_BRANCH: After decrement, var=0
DEBUG EVAL: Second branch returned z=2981618.057088
  % 	x0 = 0,	Z0 = 2981618.05708824        
DEBUG EVAL: Second branch cutoff check: z=2981618.057088, best_z=INF, threshold=INF
  %   New best:  x0, Z = 2981618.05708824        
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 10, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=10, dir=1
DEBUG TRY_BRANCH: After decrement, var=9
DEBUG EVAL: try_branch returned z=2981265.444299
DEBUG EVAL: Branch var 9 = 1 gives z=2981265.444299
  % 	x9 = 1,	Z1 = 2981265.44429897        
DEBUG EVAL: First branch cutoff check: z=2981265.444299, best_z=INF, threshold=INF
  % Best branch is x0, Z0 = 2981618.05708824        , Z1 = 3002010.42431554        

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC    9    7	x0 = 0	2981618.057088
 % @NC   10    7	x0 = 1	3002010.424316
 %       7     6  2978642.3413                2981618.0571    x4 D     2     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee62420
% @LO 0.00   2.97864234131559157959 99.9000000000
% @LN 0.00   2.98161805708824090289 99.9000000000
% Resuming node 9 at   2.98161805708824090289
DEBUG CONSTRNT: LP rows=14, pool->nlprows=14, pool->npend=0
DEBUG CONSTRNT: Checking 14 LP rows (pool tracks 14, total LP rows 14)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=13, expected 13
 % @PAP adding 14 rows, 66 nz to LP
DEBUG BB: Processing node 9, calling compute_good_lower_bound
  % @PL 14 rows, 24 cols, 66 nonzeros, 2 slack, 12 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 15 rows, 24 cols, 68 nonzeros, 2 slack, 13 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
  % @PL 17 rows, 24 cols, 72 nonzeros, 2 slack, 15 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 18 rows, 24 cols, 74 nonzeros, 2 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 19 rows, 24 cols, 76 nonzeros, 2 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 9 LP 1 Solution, length = 2982925.106550, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.798775 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.201225 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.201225 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.597549 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.201225 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.201225 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 4 fractional variables
DEBUG CG: LP optimal, z=2982925.106550, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00   2.98161805708824090289 99.9000000000
 % @LN 0.00   2.98292510655021647636 99.9000000000
DEBUG CG: Second cutoff check: z=2982925.106550, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 9 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 9
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.798775
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.798775)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.201225
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.201225)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.201225
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.201225)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.597549
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.597549)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[2] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
  % Initial guess is x11, Z0 = 2982925.10655022        , Z1 = 2990265.78971701        

DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 12, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=12, dir=1
DEBUG TRY_BRANCH: After decrement, var=11
DEBUG EVAL: try_branch returned z=3009881.856119
DEBUG EVAL: Branch var 11 = 1 gives z=3009881.856119
  % 	x11 = 1,	Z1 = 3009881.85611869        
DEBUG EVAL: First branch cutoff check: z=3009881.856119, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
DEBUG EVAL: Calling try_branch(lp, 12, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=12, dir=0
DEBUG TRY_BRANCH: After decrement, var=11
DEBUG EVAL: Second branch returned z=3120875.747661
  % 	x11 = 0,	Z0 = 3120875.74766082        
DEBUG EVAL: Second branch cutoff check: z=3120875.747661, best_z=INF, threshold=INF
  %   New best:  x11, Z = 3009881.85611869        
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 8, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=8, dir=1
DEBUG TRY_BRANCH: After decrement, var=7
DEBUG EVAL: try_branch returned z=2988113.510407
DEBUG EVAL: Branch var 7 = 1 gives z=2988113.510407
  % 	x7 = 1,	Z1 = 2988113.5104074         
DEBUG EVAL: First branch cutoff check: z=2988113.510407, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 2, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=1
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: try_branch returned z=3101757.761532
DEBUG EVAL: Branch var 1 = 1 gives z=3101757.761532
  % 	x1 = 1,	Z1 = 3101757.76153164        
DEBUG EVAL: First branch cutoff check: z=3101757.761532, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
DEBUG EVAL: Calling try_branch(lp, 2, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=0
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: Second branch returned z=2988113.510407
  % 	x1 = 0,	Z0 = 2988113.5104074         
DEBUG EVAL: Second branch cutoff check: z=2988113.510407, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 10, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=10, dir=0
DEBUG TRY_BRANCH: After decrement, var=9
DEBUG EVAL: try_branch returned z=2995284.992786
DEBUG EVAL: Branch var 9 = 0 gives z=2995284.992786
  % 	x9 = 0,	Z0 = 2995284.99278648        
DEBUG EVAL: First branch cutoff check: z=2995284.992786, best_z=INF, threshold=INF
  % Best branch is x11, Z0 = 3120875.74766082        , Z1 = 3009881.85611869        

DEBUG CAREFUL: Final result - returning best.var = 11
DEBUG BB: Branching variable chosen: j=11
 % @NC   11    9	x11 = 1	3009881.856119
 % @NC   12    9	x11 = 0	3120875.747661
 %       9     7  2982925.1066                3002010.4243    x0 D     7     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee4a040
% @LO 0.00   2.98292510655021647636 99.9000000000
% @LN 0.00   3.00201042431553677403 99.9000000000
% Resuming node 10 at   3.00201042431553677403
DEBUG CONSTRNT: LP rows=17, pool->nlprows=17, pool->npend=0
DEBUG CONSTRNT: Checking 17 LP rows (pool tracks 17, total LP rows 17)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=16, expected 16
 % @PAP adding 14 rows, 66 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % @PL 14 rows, 24 cols, 66 nonzeros, 2 slack, 12 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 15 rows, 24 cols, 68 nonzeros, 2 slack, 13 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
  % @PL 17 rows, 24 cols, 72 nonzeros, 2 slack, 15 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 18 rows, 24 cols, 74 nonzeros, 2 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 19 rows, 24 cols, 76 nonzeros, 2 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 18 rows, 24 cols, 73 nonzeros, 1 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 10 LP 1 Solution, length = 3163262.473962, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.412170 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.587830 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3163262.473962, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 10 at   3.16326247396167747894
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee40300
% @LO 0.00   3.00201042431553677403 99.9000000000
% @LN 0.00   3.00988185611868930280 99.9000000000
% Resuming node 11 at   3.00988185611868930280
DEBUG CONSTRNT: LP rows=17, pool->nlprows=17, pool->npend=0
DEBUG CONSTRNT: Checking 17 LP rows (pool tracks 17, total LP rows 17)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=16, expected 16
 % @PAP adding 17 rows, 71 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
  % @PL 17 rows, 24 cols, 71 nonzeros, 1 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 18 rows, 24 cols, 73 nonzeros, 2 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 11 LP 1 Solution, length = 3009881.856119, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.570850 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.429150 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.429150 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 2 fractional variables
DEBUG CG: LP optimal, z=3009881.856119, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3009881.856119, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 11 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 11
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.570850
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.570850)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.429150
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.429150)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=1.000000
DEBUG CAREFUL: Skipping var 11: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
  % Initial guess is x1, Z0 = 3009881.85611869        , Z1 = 3101757.76153164        

DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 8, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=8, dir=0
DEBUG TRY_BRANCH: After decrement, var=7
DEBUG EVAL: try_branch returned z=3143416.671604
DEBUG EVAL: Branch var 7 = 0 gives z=3143416.671604
  % 	x7 = 0,	Z0 = 3143416.67160363        
DEBUG EVAL: First branch cutoff check: z=3143416.671604, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
DEBUG EVAL: Calling try_branch(lp, 8, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=8, dir=1
DEBUG TRY_BRANCH: After decrement, var=7
DEBUG EVAL: Second branch returned z=3013704.546448
  % 	x7 = 1,	Z1 = 3013704.54644821        
DEBUG EVAL: Second branch cutoff check: z=3013704.546448, best_z=INF, threshold=INF
  %   New best:  x7, Z = 3013704.54644821        
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 2, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=1
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: try_branch returned z=3168419.458960
DEBUG EVAL: Branch var 1 = 1 gives z=3168419.458960
  % 	x1 = 1,	Z1 = 3168419.4589598         
DEBUG EVAL: First branch cutoff check: z=3168419.458960, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
DEBUG EVAL: Calling try_branch(lp, 2, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=0
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: Second branch returned z=3013704.546448
  % 	x1 = 0,	Z0 = 3013704.54644821        
DEBUG EVAL: Second branch cutoff check: z=3013704.546448, best_z=INF, threshold=INF
  %   New best:  x1, Z = 3013704.54644821        
  % Best branch is x1, Z0 = 3013704.54644821        , Z1 = 3168419.4589598         

DEBUG CAREFUL: Final result - returning best.var = 1
DEBUG BB: Branching variable chosen: j=1
 % @NC   13   11	x1 = 0	3013704.546448
 % @NC   14   11	x1 = 1	3168419.458960
 %      11     8  3009881.8561                3013229.7258   x11 U     9     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee76ea0
% @LO 0.00   3.00988185611868930280 99.9000000000
% @LN 0.00   3.01322972576579584114 99.9000000000
% Resuming node 4 at   3.01322972576579584114
DEBUG CONSTRNT: LP rows=18, pool->nlprows=18, pool->npend=0
DEBUG CONSTRNT: Checking 18 LP rows (pool tracks 18, total LP rows 18)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=17, expected 17
 % @PAP adding 17 rows, 72 nz to LP
DEBUG BB: Processing node 4, calling compute_good_lower_bound
  % @PL 17 rows, 24 cols, 72 nonzeros, 1 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 4 LP 1 Solution, length = 3013229.725766, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.438307 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.561693 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.561693 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.438307 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.438307 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 2 fractional variables
DEBUG CG: LP optimal, z=3013229.725766, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3013229.725766, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 4 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 4
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.438307
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.438307)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=1.000000
DEBUG CAREFUL: Skipping var 3: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.561693
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.561693)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x4, Z0 = 3013229.7257658         , Z1 = 3013229.7257658         

DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 5, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=5, dir=1
DEBUG TRY_BRANCH: After decrement, var=4
DEBUG EVAL: try_branch returned z=3025988.000450
DEBUG EVAL: Branch var 4 = 1 gives z=3025988.000450
  % 	x4 = 1,	Z1 = 3025988.00044956        
DEBUG EVAL: First branch cutoff check: z=3025988.000450, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
DEBUG EVAL: Calling try_branch(lp, 5, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=5, dir=0
DEBUG TRY_BRANCH: After decrement, var=4
DEBUG EVAL: Second branch returned z=3022399.174083
  % 	x4 = 0,	Z0 = 3022399.17408317        
DEBUG EVAL: Second branch cutoff check: z=3022399.174083, best_z=INF, threshold=INF
  %   New best:  x4, Z = 3022399.17408317        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 2, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=0
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: try_branch returned z=3016116.050757
DEBUG EVAL: Branch var 1 = 0 gives z=3016116.050757
  % 	x1 = 0,	Z0 = 3016116.05075685        
DEBUG EVAL: First branch cutoff check: z=3016116.050757, best_z=INF, threshold=INF
  % Best branch is x4, Z0 = 3022399.17408317        , Z1 = 3025988.00044956        

DEBUG CAREFUL: Final result - returning best.var = 4
DEBUG BB: Branching variable chosen: j=4
 % @NC   15    4	x4 = 0	3022399.174083
 % @NC   16    4	x4 = 1	3025988.000450
 %       4     9  3013229.7258                3013704.5464   x12 U     1     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee62420
% @LO 0.00   3.01322972576579584114 99.9000000000
% @LN 0.00   3.01370454644820640056 99.9000000000
% Resuming node 13 at   3.01370454644820640056
DEBUG CONSTRNT: LP rows=17, pool->nlprows=17, pool->npend=0
DEBUG CONSTRNT: Checking 17 LP rows (pool tracks 17, total LP rows 17)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
 % @PAP adding 18 rows, 73 nz to LP
DEBUG BB: Processing node 13, calling compute_good_lower_bound
  % @PL 18 rows, 24 cols, 73 nonzeros, 2 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 3 rows, 10 nz to LP
  % @PL 21 rows, 24 cols, 83 nonzeros, 5 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 17 rows, 24 cols, 70 nonzeros, 1 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 13 LP 1 Solution, length = 3176394.018286, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.406930 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.593070 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3176394.018286, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 13 at   3.17639401828618339607
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee40300
% @LO 0.00   3.01370454644820640056 99.9000000000
% @LN 0.00   3.02239917408316749459 99.9000000000
% Resuming node 15 at   3.02239917408316749459
DEBUG CONSTRNT: LP rows=16, pool->nlprows=16, pool->npend=0
DEBUG CONSTRNT: Checking 16 LP rows (pool tracks 16, total LP rows 16)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=15, expected 15
 % @PAP adding 17 rows, 72 nz to LP
DEBUG BB: Processing node 15, calling compute_good_lower_bound
  % @PL 17 rows, 24 cols, 72 nonzeros, 2 slack, 15 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 3 rows, 10 nz to LP
  % @PL 20 rows, 24 cols, 82 nonzeros, 4 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 4 rows, 12 nz to LP
  % @PL 24 rows, 24 cols, 94 nonzeros, 7 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 15 LP 1 Solution, length = 3022399.174083, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.554353 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.445647 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.554353 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.554353 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.445647 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.445647 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 3 fractional variables
DEBUG CG: LP optimal, z=3022399.174083, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3022399.174083, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 15 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 15
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.554353
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.554353)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.445647
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.445647)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=1.000000
DEBUG CAREFUL: Skipping var 3: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.554353
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.554353)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
  % Initial guess is x0, Z0 = 3022399.17408317        , Z1 = 3029770.55094636        

DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 2, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=0
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: try_branch returned z=3025310.174782
DEBUG EVAL: Branch var 1 = 0 gives z=3025310.174782
  % 	x1 = 0,	Z0 = 3025310.17478164        
DEBUG EVAL: First branch cutoff check: z=3025310.174782, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
DEBUG EVAL: Calling try_branch(lp, 2, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=1
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: Second branch returned z=3027864.320893
  % 	x1 = 1,	Z1 = 3027864.32089281        
DEBUG EVAL: Second branch cutoff check: z=3027864.320893, best_z=INF, threshold=INF
  %   New best:  x1, Z = 3025310.17478164        
DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 1, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=1, dir=1
DEBUG TRY_BRANCH: After decrement, var=0
DEBUG EVAL: try_branch returned z=3042914.246992
DEBUG EVAL: Branch var 0 = 1 gives z=3042914.246992
  % 	x0 = 1,	Z1 = 3042914.24699242        
DEBUG EVAL: First branch cutoff check: z=3042914.246992, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 0
DEBUG EVAL: Calling try_branch(lp, 1, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=1, dir=0
DEBUG TRY_BRANCH: After decrement, var=0
DEBUG EVAL: Second branch returned z=3026606.089246
  % 	x0 = 0,	Z0 = 3026606.08924593        
DEBUG EVAL: Second branch cutoff check: z=3026606.089246, best_z=INF, threshold=INF
  %   New best:  x0, Z = 3026606.08924593        
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 10, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=10, dir=1
DEBUG TRY_BRANCH: After decrement, var=9
DEBUG EVAL: try_branch returned z=3025310.174782
DEBUG EVAL: Branch var 9 = 1 gives z=3025310.174782
  % 	x9 = 1,	Z1 = 3025310.17478164        
DEBUG EVAL: First branch cutoff check: z=3025310.174782, best_z=INF, threshold=INF
  % Best branch is x0, Z0 = 3026606.08924593        , Z1 = 3042914.24699242        

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC   17   15	x0 = 0	3026606.089246
 % @NC   18   15	x0 = 1	3042914.246992
 %      15    10  3022399.1741                3025566.7189    x4 D     4     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee407f0
% @LO 0.00   3.02239917408316749459 99.9000000000
% @LN 0.00   3.02556671886773065339 99.9000000000
% Resuming node 5 at   3.02556671886773065339
DEBUG CONSTRNT: LP rows=24, pool->nlprows=24, pool->npend=0
DEBUG CONSTRNT: Checking 24 LP rows (pool tracks 24, total LP rows 24)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
 % @PAP adding 18 rows, 74 nz to LP
DEBUG BB: Processing node 5, calling compute_good_lower_bound
  % @PL 18 rows, 24 cols, 74 nonzeros, 1 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 5 LP 1 Solution, length = 3025566.718868, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.449464 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.816488 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.550536 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.183512 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.183512 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.449464 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.449464 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.183512 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.183512 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.183512 (terminal 9)
 % 5 fractional variables
DEBUG CG: LP optimal, z=3025566.718868, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3025566.718868, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 5 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 5
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.449464
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.449464)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.816488
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.816488)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.550536
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.550536)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.183512
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.183512)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.183512
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.183512)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
  % Initial guess is x3, Z0 = 3025566.71886773        , Z1 = 3025566.71886773        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 4, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=1
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: try_branch returned z=3026728.010134
DEBUG EVAL: Branch var 3 = 1 gives z=3026728.010134
  % 	x3 = 1,	Z1 = 3026728.01013375        
DEBUG EVAL: First branch cutoff check: z=3026728.010134, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
DEBUG EVAL: Calling try_branch(lp, 4, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=0
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: Second branch returned z=3040615.680421
  % 	x3 = 0,	Z0 = 3040615.68042116        
DEBUG EVAL: Second branch cutoff check: z=3040615.680421, best_z=INF, threshold=INF
  %   New best:  x3, Z = 3026728.01013375        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 2, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=0
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: try_branch returned z=3028517.573475
DEBUG EVAL: Branch var 1 = 0 gives z=3028517.573475
  % 	x1 = 0,	Z0 = 3028517.57347489        
DEBUG EVAL: First branch cutoff check: z=3028517.573475, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
DEBUG EVAL: Calling try_branch(lp, 2, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=1
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: Second branch returned z=3033926.313619
  % 	x1 = 1,	Z1 = 3033926.31361944        
DEBUG EVAL: Second branch cutoff check: z=3033926.313619, best_z=INF, threshold=INF
  %   New best:  x1, Z = 3028517.57347489        
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 5, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=5, dir=1
DEBUG TRY_BRANCH: After decrement, var=4
DEBUG EVAL: try_branch returned z=3035689.694511
DEBUG EVAL: Branch var 4 = 1 gives z=3035689.694511
  % 	x4 = 1,	Z1 = 3035689.69451113        
DEBUG EVAL: First branch cutoff check: z=3035689.694511, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
DEBUG EVAL: Calling try_branch(lp, 5, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=5, dir=0
DEBUG TRY_BRANCH: After decrement, var=4
DEBUG EVAL: Second branch returned z=3031212.298022
  % 	x4 = 0,	Z0 = 3031212.29802216        
DEBUG EVAL: Second branch cutoff check: z=3031212.298022, best_z=INF, threshold=INF
  %   New best:  x4, Z = 3031212.29802216        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 11, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=11, dir=0
DEBUG TRY_BRANCH: After decrement, var=10
DEBUG EVAL: try_branch returned z=3026728.010134
DEBUG EVAL: Branch var 10 = 0 gives z=3026728.010134
  % 	x10 = 0,	Z0 = 3026728.01013375        
DEBUG EVAL: First branch cutoff check: z=3026728.010134, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 6, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=6, dir=0
DEBUG TRY_BRANCH: After decrement, var=5
DEBUG EVAL: try_branch returned z=3026728.010134
DEBUG EVAL: Branch var 5 = 0 gives z=3026728.010134
  % 	x5 = 0,	Z0 = 3026728.01013375        
DEBUG EVAL: First branch cutoff check: z=3026728.010134, best_z=INF, threshold=INF
  % Best branch is x4, Z0 = 3031212.29802216        , Z1 = 3035689.69451113        

DEBUG CAREFUL: Final result - returning best.var = 4
DEBUG BB: Branching variable chosen: j=4
 % @NC   19    5	x4 = 0	3031212.298022
 % @NC   20    5	x4 = 1	3035689.694511
 %       5    11  3025566.7189                3025988.0004   x13 U     3     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee78a70
% @LO 0.00   3.02556671886773065339 99.9000000000
% @LN 0.00   3.02598800044956339761 99.9000000000
% Resuming node 16 at   3.02598800044956339761
DEBUG CONSTRNT: LP rows=18, pool->nlprows=18, pool->npend=0
DEBUG CONSTRNT: Checking 18 LP rows (pool tracks 18, total LP rows 18)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=17, expected 17
 % @PAP adding 17 rows, 72 nz to LP
DEBUG BB: Processing node 16, calling compute_good_lower_bound
  % @PL 17 rows, 24 cols, 72 nonzeros, 1 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 18 rows, 24 cols, 74 nonzeros, 2 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 16 LP 1 Solution, length = 3025988.000450, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.548713 (FST 3)
  % DEBUG LP_VARS: x[4] = 1.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.451287 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.548713 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.451287 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.451287 (terminal 9)
 % 2 fractional variables
DEBUG CG: LP optimal, z=3025988.000450, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3025988.000450, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 16 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 16
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.548713
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.548713)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=1.000000
DEBUG CAREFUL: Skipping var 4: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.451287
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.451287)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
  % Initial guess is x3, Z0 = 3025988.00044956        , Z1 = 3025988.00044956        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 4, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=1
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: try_branch returned z=3204949.630719
DEBUG EVAL: Branch var 3 = 1 gives z=3204949.630719
  % 	x3 = 1,	Z1 = 3204949.63071905        
DEBUG EVAL: First branch cutoff check: z=3204949.630719, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
DEBUG EVAL: Calling try_branch(lp, 4, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=0
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: Second branch returned z=3036175.873525
  % 	x3 = 0,	Z0 = 3036175.87352464        
DEBUG EVAL: Second branch cutoff check: z=3036175.873525, best_z=INF, threshold=INF
  %   New best:  x3, Z = 3036175.87352464        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 6, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=6, dir=0
DEBUG TRY_BRANCH: After decrement, var=5
DEBUG EVAL: try_branch returned z=3204949.630719
DEBUG EVAL: Branch var 5 = 0 gives z=3204949.630719
  % 	x5 = 0,	Z0 = 3204949.63071905        
DEBUG EVAL: First branch cutoff check: z=3204949.630719, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
DEBUG EVAL: Calling try_branch(lp, 6, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=6, dir=1
DEBUG TRY_BRANCH: After decrement, var=5
DEBUG EVAL: Second branch returned z=3036175.873525
  % 	x5 = 1,	Z1 = 3036175.87352464        
DEBUG EVAL: Second branch cutoff check: z=3036175.873525, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 3036175.87352464        , Z1 = 3204949.63071905        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   21   16	x3 = 0	3036175.873525
 % @NC   22   16	x3 = 1	3204949.630719
 %      16    12  3025988.0004                3026606.0892    x4 U     4     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee76ea0
% @LO 0.00   3.02598800044956339761 99.9000000000
% @LN 0.00   3.02660608924593432789 99.9000000000
% Resuming node 17 at   3.02660608924593432789
DEBUG CONSTRNT: LP rows=18, pool->nlprows=18, pool->npend=0
DEBUG CONSTRNT: Checking 18 LP rows (pool tracks 18, total LP rows 18)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=17, expected 17
 % @PAP adding 24 rows, 94 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
  % @PL 24 rows, 24 cols, 94 nonzeros, 8 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 17 LP 1 Solution, length = 3026606.089246, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.776711 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.223289 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.223289 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.553422 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.223289 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.223289 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 4 fractional variables
DEBUG CG: LP optimal, z=3026606.089246, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3026606.089246, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 17 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 17
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.776711
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.776711)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=1.000000
DEBUG CAREFUL: Skipping var 3: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.223289
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.223289)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.223289
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.223289)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.553422
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.553422)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[1] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[2] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
  % Initial guess is x11, Z0 = 3026606.08924593        , Z1 = 3034751.65101319        

DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 8, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=8, dir=1
DEBUG TRY_BRANCH: After decrement, var=7
DEBUG EVAL: try_branch returned z=3031651.179992
DEBUG EVAL: Branch var 7 = 1 gives z=3031651.179992
  % 	x7 = 1,	Z1 = 3031651.17999209        
DEBUG EVAL: First branch cutoff check: z=3031651.179992, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
DEBUG EVAL: Calling try_branch(lp, 8, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=8, dir=0
DEBUG TRY_BRANCH: After decrement, var=7
DEBUG EVAL: Second branch returned z=3027864.320893
  % 	x7 = 0,	Z0 = 3027864.32089281        
DEBUG EVAL: Second branch cutoff check: z=3027864.320893, best_z=INF, threshold=INF
  %   New best:  x7, Z = 3027864.32089281        
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 12, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=12, dir=1
DEBUG TRY_BRANCH: After decrement, var=11
DEBUG EVAL: try_branch returned z=3047907.051573
DEBUG EVAL: Branch var 11 = 1 gives z=3047907.051573
  % 	x11 = 1,	Z1 = 3047907.05157301        
DEBUG EVAL: First branch cutoff check: z=3047907.051573, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
DEBUG EVAL: Calling try_branch(lp, 12, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=12, dir=0
DEBUG TRY_BRANCH: After decrement, var=11
DEBUG EVAL: Second branch returned z=3157247.909799
  % 	x11 = 0,	Z0 = 3157247.90979949        
DEBUG EVAL: Second branch cutoff check: z=3157247.909799, best_z=INF, threshold=INF
  %   New best:  x11, Z = 3047907.05157301        
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 2, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=1
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: try_branch returned z=3027864.320893
DEBUG EVAL: Branch var 1 = 1 gives z=3027864.320893
  % 	x1 = 1,	Z1 = 3027864.32089281        
DEBUG EVAL: First branch cutoff check: z=3027864.320893, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 10, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=10, dir=0
DEBUG TRY_BRANCH: After decrement, var=9
DEBUG EVAL: try_branch returned z=3027864.320893
DEBUG EVAL: Branch var 9 = 0 gives z=3027864.320893
  % 	x9 = 0,	Z0 = 3027864.32089281        
DEBUG EVAL: First branch cutoff check: z=3027864.320893, best_z=INF, threshold=INF
  % Best branch is x11, Z0 = 3157247.90979949        , Z1 = 3047907.05157301        

DEBUG CAREFUL: Final result - returning best.var = 11
DEBUG BB: Branching variable chosen: j=11
 % @NC   23   17	x11 = 1	3047907.051573
 % @NC   24   17	x11 = 0	3157247.909799
 %      17    13  3026606.0892                3031212.2980    x0 D    15     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee40300
% @LO 0.00   3.02660608924593432789 99.9000000000
% @LN 0.00   3.03121229802215674809 99.9000000000
% Resuming node 19 at   3.03121229802215674809
DEBUG CONSTRNT: LP rows=24, pool->nlprows=24, pool->npend=0
DEBUG CONSTRNT: Checking 24 LP rows (pool tracks 24, total LP rows 24)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
 % @PAP adding 18 rows, 74 nz to LP
DEBUG BB: Processing node 19, calling compute_good_lower_bound
  % @PL 18 rows, 24 cols, 74 nonzeros, 2 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 3 rows, 10 nz to LP
  % @PL 21 rows, 24 cols, 84 nonzeros, 4 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 4 rows, 12 nz to LP
  % @PL 25 rows, 24 cols, 96 nonzeros, 5 slack, 20 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 19 LP 1 Solution, length = 3034199.367718, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.847915 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.152085 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.152085 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.043745 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.152085 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.152085 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.152085 (terminal 9)
 % 7 fractional variables
DEBUG CG: LP optimal, z=3034199.367718, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00   3.03121229802215674809 99.9000000000
 % @LN 0.00   3.03419936771770704098 99.9000000000
DEBUG CG: Second cutoff check: z=3034199.367718, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 19 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 19
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.847915
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.847915)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.152085
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.152085)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.152085
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.152085)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.043745
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.043745)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[6] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
  % Initial guess is x3, Z0 = 3049422.23895799        , Z1 = 3034199.36771771        

DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 2, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=0
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: try_branch returned z=3040278.299849
DEBUG EVAL: Branch var 1 = 0 gives z=3040278.299849
  % 	x1 = 0,	Z0 = 3040278.29984939        
DEBUG EVAL: First branch cutoff check: z=3040278.299849, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
DEBUG EVAL: Calling try_branch(lp, 2, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=1
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: Second branch returned z=3042761.741538
  % 	x1 = 1,	Z1 = 3042761.74153837        
DEBUG EVAL: Second branch cutoff check: z=3042761.741538, best_z=INF, threshold=INF
  %   New best:  x1, Z = 3040278.29984939        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 1, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=1, dir=0
DEBUG TRY_BRANCH: After decrement, var=0
DEBUG EVAL: try_branch returned z=3039944.244356
DEBUG EVAL: Branch var 0 = 0 gives z=3039944.244356
  % 	x0 = 0,	Z0 = 3039944.24435556        
DEBUG EVAL: First branch cutoff check: z=3039944.244356, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 10, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=10, dir=0
DEBUG TRY_BRANCH: After decrement, var=9
DEBUG EVAL: try_branch returned z=3042761.741538
DEBUG EVAL: Branch var 9 = 0 gives z=3042761.741538
  % 	x9 = 0,	Z0 = 3042761.74153837        
DEBUG EVAL: First branch cutoff check: z=3042761.741538, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
DEBUG EVAL: Calling try_branch(lp, 10, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=10, dir=1
DEBUG TRY_BRANCH: After decrement, var=9
DEBUG EVAL: Second branch returned z=3040278.299849
  % 	x9 = 1,	Z1 = 3040278.29984939        
DEBUG EVAL: Second branch cutoff check: z=3040278.299849, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 12, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=12, dir=1
DEBUG TRY_BRANCH: After decrement, var=11
DEBUG EVAL: try_branch returned z=3057284.786413
DEBUG EVAL: Branch var 11 = 1 gives z=3057284.786413
  % 	x11 = 1,	Z1 = 3057284.78641331        
DEBUG EVAL: First branch cutoff check: z=3057284.786413, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
DEBUG EVAL: Calling try_branch(lp, 12, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=12, dir=0
DEBUG TRY_BRANCH: After decrement, var=11
DEBUG EVAL: Second branch returned z=3034510.566855
  % 	x11 = 0,	Z0 = 3034510.56685503        
DEBUG EVAL: Second branch cutoff check: z=3034510.566855, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 11, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=11, dir=0
DEBUG TRY_BRANCH: After decrement, var=10
DEBUG EVAL: try_branch returned z=3038947.365901
DEBUG EVAL: Branch var 10 = 0 gives z=3038947.365901
  % 	x10 = 0,	Z0 = 3038947.36590113        
DEBUG EVAL: First branch cutoff check: z=3038947.365901, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 4, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=1
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: try_branch returned z=3064603.568580
DEBUG EVAL: Branch var 3 = 1 gives z=3064603.568580
  % 	x3 = 1,	Z1 = 3064603.56857963        
DEBUG EVAL: First branch cutoff check: z=3064603.568580, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
DEBUG EVAL: Calling try_branch(lp, 4, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=0
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: Second branch returned z=3049422.238958
  % 	x3 = 0,	Z0 = 3049422.23895799        
DEBUG EVAL: Second branch cutoff check: z=3049422.238958, best_z=INF, threshold=INF
  %   New best:  x3, Z = 3049422.23895799        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 6, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=6, dir=0
DEBUG TRY_BRANCH: After decrement, var=5
DEBUG EVAL: try_branch returned z=3064603.568580
DEBUG EVAL: Branch var 5 = 0 gives z=3064603.568580
  % 	x5 = 0,	Z0 = 3064603.56857963        
DEBUG EVAL: First branch cutoff check: z=3064603.568580, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
DEBUG EVAL: Calling try_branch(lp, 6, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=6, dir=1
DEBUG TRY_BRANCH: After decrement, var=5
DEBUG EVAL: Second branch returned z=3049422.238958
  % 	x5 = 1,	Z1 = 3049422.23895799        
DEBUG EVAL: Second branch cutoff check: z=3049422.238958, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 3049422.23895799        , Z1 = 3064603.56857963        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   25   19	x3 = 0	3049422.238958
 % @NC   26   19	x3 = 1	3064603.568580
 %      19    14  3034199.3677                3035689.6945    x4 D     5     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee422e0
% @LO 0.00   3.03419936771770704098 99.9000000000
% @LN 0.00   3.03568969451112780078 99.9000000000
% Resuming node 20 at   3.03568969451112780078
DEBUG CONSTRNT: LP rows=20, pool->nlprows=20, pool->npend=0
DEBUG CONSTRNT: Checking 20 LP rows (pool tracks 20, total LP rows 20)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=19, expected 19
 % @PAP adding 18 rows, 74 nz to LP
DEBUG BB: Processing node 20, calling compute_good_lower_bound
  % @PL 18 rows, 24 cols, 74 nonzeros, 1 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 20 LP 1 Solution, length = 3035689.694511, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.513141 (FST 3)
  % DEBUG LP_VARS: x[4] = 1.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.486859 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.026281 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.486859 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.486859 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.486859 (terminal 9)
 % 3 fractional variables
DEBUG CG: LP optimal, z=3035689.694511, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3035689.694511, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 20 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 20
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.513141
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.513141)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=1.000000
DEBUG CAREFUL: Skipping var 4: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.486859
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.486859)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.026281
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.026281)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x3, Z0 = 3040615.68042116        , Z1 = 3035689.69451113        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 4, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=1
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: try_branch returned z=3537654.525333
DEBUG EVAL: Branch var 3 = 1 gives z=3537654.525333
  % 	x3 = 1,	Z1 = 3537654.5253329         
DEBUG EVAL: First branch cutoff check: z=3537654.525333, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
DEBUG EVAL: Calling try_branch(lp, 4, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=0
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: Second branch returned z=3045217.095000
  % 	x3 = 0,	Z0 = 3045217.09499997        
DEBUG EVAL: Second branch cutoff check: z=3045217.095000, best_z=INF, threshold=INF
  %   New best:  x3, Z = 3045217.09499997        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 6, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=6, dir=0
DEBUG TRY_BRANCH: After decrement, var=5
DEBUG EVAL: try_branch returned z=3403616.885164
DEBUG EVAL: Branch var 5 = 0 gives z=3403616.885164
  % 	x5 = 0,	Z0 = 3403616.88516388        
DEBUG EVAL: First branch cutoff check: z=3403616.885164, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
DEBUG EVAL: Calling try_branch(lp, 6, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=6, dir=1
DEBUG TRY_BRANCH: After decrement, var=5
DEBUG EVAL: Second branch returned z=3045217.095000
  % 	x5 = 1,	Z1 = 3045217.09499997        
DEBUG EVAL: Second branch cutoff check: z=3045217.095000, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 11, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=11, dir=0
DEBUG TRY_BRANCH: After decrement, var=10
DEBUG EVAL: try_branch returned z=3065302.067171
DEBUG EVAL: Branch var 10 = 0 gives z=3065302.067171
  % 	x10 = 0,	Z0 = 3065302.06717069        
DEBUG EVAL: First branch cutoff check: z=3065302.067171, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
DEBUG EVAL: Calling try_branch(lp, 11, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=11, dir=1
DEBUG TRY_BRANCH: After decrement, var=10
DEBUG EVAL: Second branch returned z=3242059.001829
  % 	x10 = 1,	Z1 = 3242059.0018285         
DEBUG EVAL: Second branch cutoff check: z=3242059.001829, best_z=INF, threshold=INF
  %   New best:  x10, Z = 3065302.06717069        
  % Best branch is x10, Z0 = 3065302.06717069        , Z1 = 3242059.0018285         

DEBUG CAREFUL: Final result - returning best.var = 10
DEBUG BB: Branching variable chosen: j=10
 % @NC   27   20	x10 = 0	3065302.067171
 % @NC   28   20	x10 = 1	3242059.001829
 %      20    15  3035689.6945                3036175.8735    x4 U     5     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee407f0
% @LO 0.00   3.03568969451112780078 99.9000000000
% @LN 0.00   3.03617587352464379791 99.9000000000
% Resuming node 21 at   3.03617587352464379791
DEBUG CONSTRNT: LP rows=18, pool->nlprows=18, pool->npend=0
DEBUG CONSTRNT: Checking 18 LP rows (pool tracks 18, total LP rows 18)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=17, expected 17
 % @PAP adding 18 rows, 74 nz to LP
DEBUG BB: Processing node 21, calling compute_good_lower_bound
  % @PL 18 rows, 24 cols, 74 nonzeros, 3 slack, 15 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
  % @PL 20 rows, 24 cols, 79 nonzeros, 4 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
  % @PL 22 rows, 24 cols, 85 nonzeros, 6 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 21 LP 1 Solution, length = 3036175.873525, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 1.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.541157 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.458843 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3036175.873525, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3036175.873525, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 21 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 21
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=1.000000
DEBUG CAREFUL: Skipping var 4: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.541157
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.541157)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 1 fractional variables

  %  Carefully choosing branching variable, nfrac = 1
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
  % Initial guess is x10, Z0 = 3036175.87352464        , Z1 = 3044814.09664292        

DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 11, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=11, dir=1
DEBUG TRY_BRANCH: After decrement, var=10
DEBUG EVAL: try_branch returned z=3229313.084631
DEBUG EVAL: Branch var 10 = 1 gives z=3229313.084631
  % 	x10 = 1,	Z1 = 3229313.08463084        
DEBUG EVAL: First branch cutoff check: z=3229313.084631, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
DEBUG EVAL: Calling try_branch(lp, 11, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=11, dir=0
DEBUG TRY_BRANCH: After decrement, var=10
DEBUG EVAL: Second branch returned z=3176568.776967
  % 	x10 = 0,	Z0 = 3176568.77696749        
DEBUG EVAL: Second branch cutoff check: z=3176568.776967, best_z=INF, threshold=INF
  %   New best:  x10, Z = 3176568.77696749        
  % Best branch is x10, Z0 = 3176568.77696749        , Z1 = 3229313.08463084        

DEBUG CAREFUL: Final result - returning best.var = 10
DEBUG BB: Branching variable chosen: j=10
 % @NC   29   21	x10 = 0	3176568.776967
 % @NC   30   21	x10 = 1	3229313.084631
 %      21    16  3036175.8735                3042914.2470    x3 D    16     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee411d0
% @LO 0.00   3.03617587352464379791 99.9000000000
% @LN 0.00   3.04291424699241774832 99.9000000000
% Resuming node 18 at   3.04291424699241774832
DEBUG CONSTRNT: LP rows=22, pool->nlprows=22, pool->npend=0
DEBUG CONSTRNT: Checking 22 LP rows (pool tracks 22, total LP rows 22)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=21, expected 21
 % @PAP adding 24 rows, 94 nz to LP
DEBUG BB: Processing node 18, calling compute_good_lower_bound
  % @PL 24 rows, 24 cols, 94 nonzeros, 7 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 25 rows, 24 cols, 96 nonzeros, 8 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 18 LP 1 Solution, length = 3042914.246992, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.535080 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.464920 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.535080 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.464920 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.464920 (terminal 9)
 % 2 fractional variables
DEBUG CG: LP optimal, z=3042914.246992, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3042914.246992, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 18 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 18
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=1.000000
DEBUG CAREFUL: Skipping var 0: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.535080
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.535080)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.464920
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.464920)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
  % Initial guess is x3, Z0 = 3042914.24699242        , Z1 = 3042914.24699242        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 4, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=1
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: try_branch returned z=3176833.016824
DEBUG EVAL: Branch var 3 = 1 gives z=3176833.016824
  % 	x3 = 1,	Z1 = 3176833.01682356        
DEBUG EVAL: First branch cutoff check: z=3176833.016824, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
DEBUG EVAL: Calling try_branch(lp, 4, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=0
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: Second branch returned z=3052848.995563
  % 	x3 = 0,	Z0 = 3052848.99556308        
DEBUG EVAL: Second branch cutoff check: z=3052848.995563, best_z=INF, threshold=INF
  %   New best:  x3, Z = 3052848.99556308        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 6, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=6, dir=0
DEBUG TRY_BRANCH: After decrement, var=5
DEBUG EVAL: try_branch returned z=3176833.016824
DEBUG EVAL: Branch var 5 = 0 gives z=3176833.016824
  % 	x5 = 0,	Z0 = 3176833.01682356        
DEBUG EVAL: First branch cutoff check: z=3176833.016824, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
DEBUG EVAL: Calling try_branch(lp, 6, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=6, dir=1
DEBUG TRY_BRANCH: After decrement, var=5
DEBUG EVAL: Second branch returned z=3052848.995563
  % 	x5 = 1,	Z1 = 3052848.99556308        
DEBUG EVAL: Second branch cutoff check: z=3052848.995563, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 3052848.99556308        , Z1 = 3176833.01682356        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   31   18	x3 = 0	3052848.995563
 % @NC   32   18	x3 = 1	3176833.016824
 %      18    17  3042914.2470                3047907.0516    x0 U    15     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee78a70
% @LO 0.00   3.04291424699241774832 99.9000000000
% @LN 0.00   3.04790705157301466954 99.9000000000
% Resuming node 23 at   3.04790705157301466954
DEBUG CONSTRNT: LP rows=25, pool->nlprows=25, pool->npend=0
DEBUG CONSTRNT: Checking 25 LP rows (pool tracks 25, total LP rows 25)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=24, expected 24
 % @PAP adding 24 rows, 94 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
  % @PL 24 rows, 24 cols, 94 nonzeros, 8 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 25 rows, 24 cols, 96 nonzeros, 9 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 23 LP 1 Solution, length = 3047907.051573, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.534666 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.465334 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.534666 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.465334 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.465334 (terminal 9)
 % 2 fractional variables
DEBUG CG: LP optimal, z=3047907.051573, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3047907.051573, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 23 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 23
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=1.000000
DEBUG CAREFUL: Skipping var 1: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.534666
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.534666)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.465334
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.465334)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=1.000000
DEBUG CAREFUL: Skipping var 11: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
  % Initial guess is x3, Z0 = 3047907.05157301        , Z1 = 3047907.05157301        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 4, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=1
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: try_branch returned z=3056518.546120
DEBUG EVAL: Branch var 3 = 1 gives z=3056518.546120
  % 	x3 = 1,	Z1 = 3056518.54612022        
DEBUG EVAL: First branch cutoff check: z=3056518.546120, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
DEBUG EVAL: Calling try_branch(lp, 4, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=0
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: Second branch returned z=3057834.113234
  % 	x3 = 0,	Z0 = 3057834.11323388        
DEBUG EVAL: Second branch cutoff check: z=3057834.113234, best_z=INF, threshold=INF
  %   New best:  x3, Z = 3056518.54612022        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 6, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=6, dir=0
DEBUG TRY_BRANCH: After decrement, var=5
DEBUG EVAL: try_branch returned z=3056518.546120
DEBUG EVAL: Branch var 5 = 0 gives z=3056518.546120
  % 	x5 = 0,	Z0 = 3056518.54612022        
DEBUG EVAL: First branch cutoff check: z=3056518.546120, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
DEBUG EVAL: Calling try_branch(lp, 6, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=6, dir=1
DEBUG TRY_BRANCH: After decrement, var=5
DEBUG EVAL: Second branch returned z=3057834.113234
  % 	x5 = 1,	Z1 = 3057834.11323388        
DEBUG EVAL: Second branch cutoff check: z=3057834.113234, best_z=INF, threshold=INF
  %   New best:  x5, Z = 3056518.54612022        
  % Best branch is x5, Z0 = 3056518.54612022        , Z1 = 3057834.11323388        

DEBUG CAREFUL: Final result - returning best.var = 5
DEBUG BB: Branching variable chosen: j=5
 % @NC   33   23	x5 = 0	3056518.546120
 % @NC   34   23	x5 = 1	3057834.113234
 %      23    18  3047907.0516                3049422.2390   x11 U    17     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee76ea0
% @LO 0.00   3.04790705157301466954 99.9000000000
% @LN 0.00   3.04942223895799369160 99.9000000000
% Resuming node 25 at   3.04942223895799369160
DEBUG CONSTRNT: LP rows=25, pool->nlprows=25, pool->npend=0
DEBUG CONSTRNT: Checking 25 LP rows (pool tracks 25, total LP rows 25)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=24, expected 24
 % @PAP adding 20 rows, 77 nz to LP
DEBUG BB: Processing node 25, calling compute_good_lower_bound
  % @PL 20 rows, 24 cols, 77 nonzeros, 5 slack, 15 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
  % @PL 22 rows, 24 cols, 82 nonzeros, 6 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
  % @PL 24 rows, 24 cols, 86 nonzeros, 6 slack, 18 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 25 rows, 24 cols, 88 nonzeros, 6 slack, 19 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 25 LP 1 Solution, length = 3064382.775874, 0.01 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.518706 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.500000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.481294 (terminal 9)
 % 5 fractional variables
DEBUG CG: LP optimal, z=3064382.775874, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 25 at   3.06438277587380447642
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee407f0
% @LO 0.01   3.04942223895799369160 99.9000000000
% @LN 0.01   3.05284899556307953716 99.9000000000
% Resuming node 31 at   3.05284899556307953716
DEBUG CONSTRNT: LP rows=19, pool->nlprows=19, pool->npend=0
DEBUG CONSTRNT: Checking 19 LP rows (pool tracks 19, total LP rows 19)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=18, expected 18
 % @PAP adding 25 rows, 96 nz to LP
DEBUG BB: Processing node 31, calling compute_good_lower_bound
  % @PL 25 rows, 24 cols, 96 nonzeros, 9 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
  % @PL 27 rows, 24 cols, 101 nonzeros, 10 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 10 slack rows
  % @PAP adding 2 rows, 6 nz to LP
  % @PL 19 rows, 24 cols, 77 nonzeros, 2 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 31 LP 1 Solution, length = 3052848.995563, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.527712 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.472288 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3052848.995563, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.01   3.05284899556307953716 99.9000000000
 % @LN 0.01   3.05284899556307998125 99.9000000000
DEBUG CG: Second cutoff check: z=3052848.995563, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 31 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 31
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=1.000000
DEBUG CAREFUL: Skipping var 0: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.527712
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.527712)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 1 fractional variables

  %  Carefully choosing branching variable, nfrac = 1
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
  % Initial guess is x10, Z0 = 3052848.99556308        , Z1 = 3061740.34318577        

DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 11, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=11, dir=1
DEBUG TRY_BRANCH: After decrement, var=10
DEBUG EVAL: try_branch returned z=3199681.265630
DEBUG EVAL: Branch var 10 = 1 gives z=3199681.265630
  % 	x10 = 1,	Z1 = 3199681.2656301         
DEBUG EVAL: First branch cutoff check: z=3199681.265630, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
DEBUG EVAL: Calling try_branch(lp, 11, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=11, dir=0
DEBUG TRY_BRANCH: After decrement, var=10
DEBUG EVAL: Second branch returned z=3189753.743643
  % 	x10 = 0,	Z0 = 3189753.74364259        
DEBUG EVAL: Second branch cutoff check: z=3189753.743643, best_z=INF, threshold=INF
  %   New best:  x10, Z = 3189753.74364259        
  % Best branch is x10, Z0 = 3189753.74364259        , Z1 = 3199681.2656301         

DEBUG CAREFUL: Final result - returning best.var = 10
DEBUG BB: Branching variable chosen: j=10
 % @NC   35   31	x10 = 0	3189753.743643
 % @NC   36   31	x10 = 1	3199681.265630
 %      31    19  3052848.9956                3056518.5461    x3 D    18     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee411d0
% @LO 0.01   3.05284899556307998125 99.9000000000
% @LN 0.01   3.05651854612022244595 99.9000000000
% Resuming node 33 at   3.05651854612022244595
DEBUG CONSTRNT: LP rows=19, pool->nlprows=19, pool->npend=0
DEBUG CONSTRNT: Checking 19 LP rows (pool tracks 19, total LP rows 19)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=18, expected 18
 % @PAP adding 25 rows, 96 nz to LP
DEBUG BB: Processing node 33, calling compute_good_lower_bound
  % @PL 25 rows, 24 cols, 96 nonzeros, 8 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 26 rows, 24 cols, 98 nonzeros, 9 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 33 LP 1 Solution, length = 3056518.546120, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.523795 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.476205 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.476205 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 2 fractional variables
DEBUG CG: LP optimal, z=3056518.546120, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3056518.546120, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 33 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 33
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.523795
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.523795)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=1.000000
DEBUG CAREFUL: Skipping var 3: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.476205
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.476205)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=1.000000
DEBUG CAREFUL: Skipping var 11: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x7, Z0 = 3056518.54612022        , Z1 = 3056518.54612022        

DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 8, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=8, dir=0
DEBUG TRY_BRANCH: After decrement, var=7
DEBUG EVAL: try_branch returned z=3204694.957348
DEBUG EVAL: Branch var 7 = 0 gives z=3204694.957348
  % 	x7 = 0,	Z0 = 3204694.95734752        
DEBUG EVAL: First branch cutoff check: z=3204694.957348, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
DEBUG EVAL: Calling try_branch(lp, 8, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=8, dir=1
DEBUG TRY_BRANCH: After decrement, var=7
DEBUG EVAL: Second branch returned z=3060026.134677
  % 	x7 = 1,	Z1 = 3060026.13467691        
DEBUG EVAL: Second branch cutoff check: z=3060026.134677, best_z=INF, threshold=INF
  %   New best:  x7, Z = 3060026.13467691        
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 2, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=1
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: try_branch returned z=3232439.207322
DEBUG EVAL: Branch var 1 = 1 gives z=3232439.207322
  % 	x1 = 1,	Z1 = 3232439.20732206        
DEBUG EVAL: First branch cutoff check: z=3232439.207322, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
DEBUG EVAL: Calling try_branch(lp, 2, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=0
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: Second branch returned z=3060026.134677
  % 	x1 = 0,	Z0 = 3060026.13467691        
DEBUG EVAL: Second branch cutoff check: z=3060026.134677, best_z=INF, threshold=INF
  %   New best:  x1, Z = 3060026.13467691        
  % Best branch is x1, Z0 = 3060026.13467691        , Z1 = 3232439.20732206        

DEBUG CAREFUL: Final result - returning best.var = 1
DEBUG BB: Branching variable chosen: j=1
 % @NC   37   33	x1 = 0	3060026.134677
 % @NC   38   33	x1 = 1	3232439.207322
 %      33    20  3056518.5461                3057834.1132    x5 D    23     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee78b30
% @LO 0.01   3.05651854612022244595 99.9000000000
% @LN 0.01   3.05783411323388065739 99.9000000000
% Resuming node 34 at   3.05783411323388065739
DEBUG CONSTRNT: LP rows=26, pool->nlprows=26, pool->npend=0
DEBUG CONSTRNT: Checking 26 LP rows (pool tracks 26, total LP rows 26)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=25, expected 25
 % @PAP adding 25 rows, 96 nz to LP
DEBUG BB: Processing node 34, calling compute_good_lower_bound
  % @PL 25 rows, 24 cols, 96 nonzeros, 10 slack, 15 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
  % @PL 27 rows, 24 cols, 101 nonzeros, 11 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
  % @PL 29 rows, 24 cols, 107 nonzeros, 13 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 34 LP 1 Solution, length = 3057834.113234, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.527303 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.472697 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3057834.113234, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3057834.113234, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 34 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 34
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=1.000000
DEBUG CAREFUL: Skipping var 1: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.527303
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.527303)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=1.000000
DEBUG CAREFUL: Skipping var 11: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 1 fractional variables

  %  Carefully choosing branching variable, nfrac = 1
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
  % Initial guess is x10, Z0 = 3057834.11323388        , Z1 = 3066733.14776637        

DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 11, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=11, dir=1
DEBUG TRY_BRANCH: After decrement, var=10
DEBUG EVAL: try_branch returned z=3075603.052159
DEBUG EVAL: Branch var 10 = 1 gives z=3075603.052159
  % 	x10 = 1,	Z1 = 3075603.05215876        
DEBUG EVAL: First branch cutoff check: z=3075603.052159, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
DEBUG EVAL: Calling try_branch(lp, 11, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=11, dir=0
DEBUG TRY_BRANCH: After decrement, var=10
DEBUG EVAL: Second branch returned z=3194632.932669
  % 	x10 = 0,	Z0 = 3194632.93266892        
DEBUG EVAL: Second branch cutoff check: z=3194632.932669, best_z=INF, threshold=INF
  %   New best:  x10, Z = 3075603.05215876        
  % Best branch is x10, Z0 = 3194632.93266892        , Z1 = 3075603.05215876        

DEBUG CAREFUL: Final result - returning best.var = 10
DEBUG BB: Branching variable chosen: j=10
 % @NC   39   34	x10 = 1	3075603.052159
 % @NC   40   34	x10 = 0	3194632.932669
 %      34    21  3057834.1132                3060026.1347    x5 U    23     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee407f0
% @LO 0.01   3.05783411323388065739 99.9000000000
% @LN 0.01   3.06002613467690576243 99.9000000000
% Resuming node 37 at   3.06002613467690576243
DEBUG CONSTRNT: LP rows=29, pool->nlprows=29, pool->npend=0
DEBUG CONSTRNT: Checking 29 LP rows (pool tracks 29, total LP rows 29)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=28, expected 28
 % @PAP adding 26 rows, 98 nz to LP
DEBUG BB: Processing node 37, calling compute_good_lower_bound
  % @PL 26 rows, 24 cols, 98 nonzeros, 9 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 27 rows, 24 cols, 100 nonzeros, 10 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 10 slack rows
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 18 rows, 24 cols, 73 nonzeros, 1 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 37 LP 1 Solution, length = 3240413.766648, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.342413 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.657587 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3240413.766648, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 37 at   3.24041376664843916444
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee76ea0
% @LO 0.01   3.06002613467690576243 99.9000000000
% @LN 0.01   3.06438277587380447642 99.9000000000
% Resuming node 25 at   3.06438277587380447642
DEBUG CONSTRNT: LP rows=17, pool->nlprows=17, pool->npend=0
DEBUG CONSTRNT: Checking 17 LP rows (pool tracks 17, total LP rows 17)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=16, expected 16
 % @PAP adding 19 rows, 74 nz to LP
DEBUG BB: Processing node 25, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 25 LP 2 Solution, length = 3064382.775874, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.518706 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.500000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.481294 (terminal 9)
 % 5 fractional variables
DEBUG CG: LP optimal, z=3064382.775874, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3064382.775874, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 25 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 25
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.518706
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.518706)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.500000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x1, Z0 = 3064382.7758738         , Z1 = 3064382.7758738         

DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 2, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=0
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: try_branch returned z=3073471.483350
DEBUG EVAL: Branch var 1 = 0 gives z=3073471.483350
  % 	x1 = 0,	Z0 = 3073471.48334977        
DEBUG EVAL: First branch cutoff check: z=3073471.483350, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
DEBUG EVAL: Calling try_branch(lp, 2, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=1
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: Second branch returned z=3557204.897490
  % 	x1 = 1,	Z1 = 3557204.89749045        
DEBUG EVAL: Second branch cutoff check: z=3557204.897490, best_z=INF, threshold=INF
  %   New best:  x1, Z = 3073471.48334977        
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 10, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=10, dir=0
DEBUG TRY_BRANCH: After decrement, var=9
DEBUG EVAL: try_branch returned z=3095022.805294
DEBUG EVAL: Branch var 9 = 0 gives z=3095022.805294
  % 	x9 = 0,	Z0 = 3095022.80529403        
DEBUG EVAL: First branch cutoff check: z=3095022.805294, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
DEBUG EVAL: Calling try_branch(lp, 10, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=10, dir=1
DEBUG TRY_BRANCH: After decrement, var=9
DEBUG EVAL: Second branch returned z=3073471.483350
  % 	x9 = 1,	Z1 = 3073471.48334977        
DEBUG EVAL: Second branch cutoff check: z=3073471.483350, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 1, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=1, dir=0
DEBUG TRY_BRANCH: After decrement, var=0
DEBUG EVAL: try_branch returned z=3070173.409029
DEBUG EVAL: Branch var 0 = 0 gives z=3070173.409029
  % 	x0 = 0,	Z0 = 3070173.40902949        
DEBUG EVAL: First branch cutoff check: z=3070173.409029, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 12, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=12, dir=0
DEBUG TRY_BRANCH: After decrement, var=11
DEBUG EVAL: try_branch returned z=3498860.068750
DEBUG EVAL: Branch var 11 = 0 gives z=3498860.068750
  % 	x11 = 0,	Z0 = 3498860.06874955        
DEBUG EVAL: First branch cutoff check: z=3498860.068750, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 1
DEBUG EVAL: Calling try_branch(lp, 12, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=12, dir=1
DEBUG TRY_BRANCH: After decrement, var=11
DEBUG EVAL: Second branch returned z=3070173.409029
  % 	x11 = 1,	Z1 = 3070173.40902949        
DEBUG EVAL: Second branch cutoff check: z=3070173.409029, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 11, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=11, dir=1
DEBUG TRY_BRANCH: After decrement, var=10
DEBUG EVAL: try_branch returned z=3083723.809894
DEBUG EVAL: Branch var 10 = 1 gives z=3083723.809894
  % 	x10 = 1,	Z1 = 3083723.80989373        
DEBUG EVAL: First branch cutoff check: z=3083723.809894, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
DEBUG EVAL: Calling try_branch(lp, 11, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=11, dir=0
DEBUG TRY_BRANCH: After decrement, var=10
DEBUG EVAL: Second branch returned z=3079079.319356
  % 	x10 = 0,	Z0 = 3079079.31935633        
DEBUG EVAL: Second branch cutoff check: z=3079079.319356, best_z=INF, threshold=INF
  %   New best:  x10, Z = 3079079.31935633        
  % Best branch is x10, Z0 = 3079079.31935633        , Z1 = 3083723.80989373        

DEBUG CAREFUL: Final result - returning best.var = 10
DEBUG BB: Branching variable chosen: j=10
 % @NC   41   25	x10 = 0	3079079.319356
 % @NC   42   25	x10 = 1	3083723.809894
 %      25    22  3064382.7759                3064603.5686    x3 D    19     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee6c2a0
% @LO 0.01   3.06438277587380447642 99.9000000000
% @LN 0.01   3.06460356857962912258 99.9000000000
% Resuming node 26 at   3.06460356857962912258
DEBUG CONSTRNT: LP rows=19, pool->nlprows=19, pool->npend=0
DEBUG CONSTRNT: Checking 19 LP rows (pool tracks 19, total LP rows 19)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=18, expected 18
 % @PAP adding 20 rows, 77 nz to LP
DEBUG BB: Processing node 26, calling compute_good_lower_bound
  % @PL 20 rows, 24 cols, 77 nonzeros, 1 slack, 19 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 4 rows, 12 nz to LP
  % @PL 24 rows, 24 cols, 89 nonzeros, 4 slack, 20 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 26 LP 1 Solution, length = 3128313.108174, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.407969 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.407969 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.815938 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.184062 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.407969 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.407969 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.184062 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.184062 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.592031 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.592031 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 6 fractional variables
DEBUG CG: LP optimal, z=3128313.108174, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 26 at   3.12831310817447283412
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee40300
% @LO 0.01   3.06460356857962912258 99.9000000000
% @LN 0.01   3.06530206717068542943 99.9000000000
% Resuming node 27 at   3.06530206717068542943
DEBUG CONSTRNT: LP rows=20, pool->nlprows=20, pool->npend=0
DEBUG CONSTRNT: Checking 20 LP rows (pool tracks 20, total LP rows 20)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=19, expected 19
 % @PAP adding 18 rows, 74 nz to LP
DEBUG BB: Processing node 27, calling compute_good_lower_bound
  % @PL 18 rows, 24 cols, 74 nonzeros, 2 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 27 LP 1 Solution, length = 3065302.067171, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.500000 (FST 3)
  % DEBUG LP_VARS: x[4] = 1.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
 % 2 fractional variables
DEBUG CG: LP optimal, z=3065302.067171, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3065302.067171, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 27 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 27
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.500000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=1.000000
DEBUG CAREFUL: Skipping var 4: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
  % Initial guess is x3, Z0 = 3065302.06717069        , Z1 = 3537654.5253329         

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 4, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=1
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: try_branch returned z=3537654.525333
DEBUG EVAL: Branch var 3 = 1 gives z=3537654.525333
  % 	x3 = 1,	Z1 = 3537654.5253329         
DEBUG EVAL: First branch cutoff check: z=3537654.525333, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
DEBUG EVAL: Calling try_branch(lp, 4, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=0
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: Second branch returned z=3443635.765320
  % 	x3 = 0,	Z0 = 3443635.7653198         
DEBUG EVAL: Second branch cutoff check: z=3443635.765320, best_z=INF, threshold=INF
  %   New best:  x3, Z = 3443635.7653198         
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 6, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=6, dir=1
DEBUG TRY_BRANCH: After decrement, var=5
DEBUG EVAL: try_branch returned z=3443635.765320
DEBUG EVAL: Branch var 5 = 1 gives z=3443635.765320
  % 	x5 = 1,	Z1 = 3443635.7653198         
DEBUG EVAL: First branch cutoff check: z=3443635.765320, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
DEBUG EVAL: Calling try_branch(lp, 6, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=6, dir=0
DEBUG TRY_BRANCH: After decrement, var=5
DEBUG EVAL: Second branch returned z=3537654.525333
  % 	x5 = 0,	Z0 = 3537654.5253329         
DEBUG EVAL: Second branch cutoff check: z=3537654.525333, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 3443635.7653198         , Z1 = 3537654.5253329         

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   43   27	x3 = 0	3443635.765320
 % @NC   44   27	x3 = 1	3537654.525333
 %      27    23  3065302.0672                3075603.0522   x10 D    20     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee411d0
% @LO 0.01   3.06530206717068542943 99.9000000000
% @LN 0.01   3.07560305215876006457 99.9000000000
% Resuming node 39 at   3.07560305215876006457
DEBUG CONSTRNT: LP rows=18, pool->nlprows=18, pool->npend=0
DEBUG CONSTRNT: Checking 18 LP rows (pool tracks 18, total LP rows 18)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=17, expected 17
 % @PAP adding 29 rows, 107 nz to LP
DEBUG BB: Processing node 39, calling compute_good_lower_bound
  % @PL 29 rows, 24 cols, 107 nonzeros, 13 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 30 rows, 24 cols, 109 nonzeros, 14 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 39 LP 1 Solution, length = 3075603.052159, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.509505 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.490495 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.490495 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 2 fractional variables
DEBUG CG: LP optimal, z=3075603.052159, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3075603.052159, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 39 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 39
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.509505
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.509505)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.490495
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.490495)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=1.000000
DEBUG CAREFUL: Skipping var 11: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x7, Z0 = 3075603.05215876        , Z1 = 3075603.05215876        

DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 8, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=8, dir=0
DEBUG TRY_BRANCH: After decrement, var=7
DEBUG EVAL: try_branch returned z=3228225.874317
DEBUG EVAL: Branch var 7 = 0 gives z=3228225.874317
  % 	x7 = 0,	Z0 = 3228225.87431682        
DEBUG EVAL: First branch cutoff check: z=3228225.874317, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
DEBUG EVAL: Calling try_branch(lp, 8, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=8, dir=1
DEBUG TRY_BRANCH: After decrement, var=7
DEBUG EVAL: Second branch returned z=3079014.949509
  % 	x7 = 1,	Z1 = 3079014.94950858        
DEBUG EVAL: Second branch cutoff check: z=3079014.949509, best_z=INF, threshold=INF
  %   New best:  x7, Z = 3079014.94950858        
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 2, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=1
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: try_branch returned z=3256802.661234
DEBUG EVAL: Branch var 1 = 1 gives z=3256802.661234
  % 	x1 = 1,	Z1 = 3256802.66123385        
DEBUG EVAL: First branch cutoff check: z=3256802.661234, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
DEBUG EVAL: Calling try_branch(lp, 2, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=0
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: Second branch returned z=3079014.949509
  % 	x1 = 0,	Z0 = 3079014.94950858        
DEBUG EVAL: Second branch cutoff check: z=3079014.949509, best_z=INF, threshold=INF
  %   New best:  x1, Z = 3079014.94950858        
  % Best branch is x1, Z0 = 3079014.94950858        , Z1 = 3256802.66123385        

DEBUG CAREFUL: Final result - returning best.var = 1
DEBUG BB: Branching variable chosen: j=1
 % @NC   45   39	x1 = 0	3079014.949509
 % @NC   46   39	x1 = 1	3256802.661234
 %      39    24  3075603.0522                3079014.9495   x10 U    34     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee40300
% @LO 0.01   3.07560305215876006457 99.9000000000
% @LN 0.01   3.07901494950857657074 99.9000000000
% Resuming node 45 at   3.07901494950857657074
DEBUG CONSTRNT: LP rows=30, pool->nlprows=30, pool->npend=0
DEBUG CONSTRNT: Checking 30 LP rows (pool tracks 30, total LP rows 30)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=29, expected 29
 % @PAP adding 30 rows, 109 nz to LP
DEBUG BB: Processing node 45, calling compute_good_lower_bound
  % @PL 30 rows, 24 cols, 109 nonzeros, 14 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 31 rows, 24 cols, 111 nonzeros, 15 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 15 slack rows
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 17 rows, 24 cols, 71 nonzeros, 1 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 45 LP 1 Solution, length = 3264777.220560, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.322820 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.677180 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3264777.220560, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 45 at   3.26477722056023234032
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee78b30
% @LO 0.01   3.07901494950857657074 99.9000000000
% @LN 0.01   3.07907931935632683818 99.9000000000
% Resuming node 41 at   3.07907931935632683818
DEBUG CONSTRNT: LP rows=16, pool->nlprows=16, pool->npend=0
DEBUG CONSTRNT: Checking 16 LP rows (pool tracks 16, total LP rows 16)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=15, expected 15
 % @PAP adding 19 rows, 74 nz to LP
DEBUG BB: Processing node 41, calling compute_good_lower_bound
  % @PL 19 rows, 24 cols, 74 nonzeros, 2 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 3 nz to LP
  % @PL 20 rows, 24 cols, 77 nonzeros, 1 slack, 19 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 41 LP 1 Solution, length = 3452586.018156, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.500000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
 % 4 fractional variables
DEBUG CG: LP optimal, z=3452586.018156, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 41 at   3.45258601815571442017
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee45210
% @LO 0.01   3.07907931935632683818 99.9000000000
% @LN 0.01   3.08372380989373384708 99.9000000000
% Resuming node 42 at   3.08372380989373384708
DEBUG CONSTRNT: LP rows=19, pool->nlprows=19, pool->npend=0
DEBUG CONSTRNT: Checking 19 LP rows (pool tracks 19, total LP rows 19)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=18, expected 18
 % @PAP adding 19 rows, 74 nz to LP
DEBUG BB: Processing node 42, calling compute_good_lower_bound
  % @PL 19 rows, 24 cols, 74 nonzeros, 1 slack, 18 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 4 rows, 12 nz to LP
  % @PL 23 rows, 24 cols, 86 nonzeros, 4 slack, 19 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 42 LP 1 Solution, length = 3149309.961352, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.405258 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.405258 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.810516 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.189484 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.405258 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.405258 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.189484 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.189484 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.594742 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.594742 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 6 fractional variables
DEBUG CG: LP optimal, z=3149309.961352, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 42 at   3.14930996135209984033
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee46a20
% @LO 0.01   3.08372380989373384708 99.9000000000
% @LN 0.01   3.12087574766082420652 99.9000000000
% Resuming node 12 at   3.12087574766082420652
DEBUG CONSTRNT: LP rows=19, pool->nlprows=19, pool->npend=0
DEBUG CONSTRNT: Checking 19 LP rows (pool tracks 19, total LP rows 19)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=18, expected 18
 % @PAP adding 17 rows, 71 nz to LP
DEBUG BB: Processing node 12, calling compute_good_lower_bound
  % @PL 17 rows, 24 cols, 71 nonzeros, 0 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 18 rows, 24 cols, 73 nonzeros, 0 slack, 18 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 19 rows, 24 cols, 75 nonzeros, 0 slack, 19 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 12 LP 1 Solution, length = 3125292.826878, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.455076 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.544924 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 4 fractional variables
DEBUG CG: LP optimal, z=3125292.826878, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.01   3.12087574766082420652 99.9000000000
 % @LN 0.01   3.12529282687810150421 99.9000000000
DEBUG CG: Second cutoff check: z=3125292.826878, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 12 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 12
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.455076
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.455076)
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
  % Initial guess is x13, Z0 = 3125292.8268781         , Z1 = 3305538.23583983        

DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 8, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=8, dir=0
DEBUG TRY_BRANCH: After decrement, var=7
DEBUG EVAL: try_branch returned z=3618141.247479
DEBUG EVAL: Branch var 7 = 0 gives z=3618141.247479
  % 	x7 = 0,	Z0 = 3618141.24747911        
DEBUG EVAL: First branch cutoff check: z=3618141.247479, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
DEBUG EVAL: Calling try_branch(lp, 8, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=8, dir=1
DEBUG TRY_BRANCH: After decrement, var=7
DEBUG EVAL: Second branch returned z=3128166.116634
  % 	x7 = 1,	Z1 = 3128166.1166342         
DEBUG EVAL: Second branch cutoff check: z=3128166.116634, best_z=INF, threshold=INF
  %   New best:  x7, Z = 3128166.1166342         
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 2, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=0
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: try_branch returned z=3128166.116634
DEBUG EVAL: Branch var 1 = 0 gives z=3128166.116634
  % 	x1 = 0,	Z0 = 3128166.1166342         
DEBUG EVAL: First branch cutoff check: z=3128166.116634, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
DEBUG EVAL: Calling try_branch(lp, 2, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=1
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: Second branch returned z=3705522.295604
  % 	x1 = 1,	Z1 = 3705522.29560425        
DEBUG EVAL: Second branch cutoff check: z=3705522.295604, best_z=INF, threshold=INF
  %   New best:  x1, Z = 3128166.1166342         
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 10, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=10, dir=0
DEBUG TRY_BRANCH: After decrement, var=9
DEBUG EVAL: try_branch returned z=3521147.498002
DEBUG EVAL: Branch var 9 = 0 gives z=3521147.498002
  % 	x9 = 0,	Z0 = 3521147.49800189        
DEBUG EVAL: First branch cutoff check: z=3521147.498002, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
DEBUG EVAL: Calling try_branch(lp, 10, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=10, dir=1
DEBUG TRY_BRANCH: After decrement, var=9
DEBUG EVAL: Second branch returned z=3128166.116634
  % 	x9 = 1,	Z1 = 3128166.1166342         
DEBUG EVAL: Second branch cutoff check: z=3128166.116634, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 14, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=14, dir=1
DEBUG TRY_BRANCH: After decrement, var=13
DEBUG EVAL: try_branch returned z=3341137.060751
DEBUG EVAL: Branch var 13 = 1 gives z=3341137.060751
  % 	x13 = 1,	Z1 = 3341137.06075105        
DEBUG EVAL: First branch cutoff check: z=3341137.060751, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
DEBUG EVAL: Calling try_branch(lp, 14, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=14, dir=0
DEBUG TRY_BRANCH: After decrement, var=13
DEBUG EVAL: Second branch returned z=3425559.059322
  % 	x13 = 0,	Z0 = 3425559.05932216        
DEBUG EVAL: Second branch cutoff check: z=3425559.059322, best_z=INF, threshold=INF
  %   New best:  x13, Z = 3341137.06075105        
  % Best branch is x13, Z0 = 3425559.05932216        , Z1 = 3341137.06075105        

DEBUG CAREFUL: Final result - returning best.var = 13
DEBUG BB: Branching variable chosen: j=13
 % @NC   47   12	x13 = 1	3341137.060751
 % @NC   48   12	x13 = 0	3425559.059322
 %      12    25  3125292.8269                3128313.1082   x11 D     9     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee6c2a0
% @LO 0.01   3.12529282687810150421 99.9000000000
% @LN 0.01   3.12831310817447283412 99.9000000000
% Resuming node 26 at   3.12831310817447283412
DEBUG CONSTRNT: LP rows=19, pool->nlprows=19, pool->npend=0
DEBUG CONSTRNT: Checking 19 LP rows (pool tracks 19, total LP rows 19)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=18, expected 18
 % @PAP adding 20 rows, 76 nz to LP
DEBUG BB: Processing node 26, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 26 LP 2 Solution, length = 3128313.108174, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.407969 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.407969 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.815938 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.184062 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.407969 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.407969 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.184062 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.184062 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.592031 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.592031 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 6 fractional variables
DEBUG CG: LP optimal, z=3128313.108174, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3128313.108174, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 26 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 26
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.407969
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.407969)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.407969
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.407969)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=1.000000
DEBUG CAREFUL: Skipping var 3: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.815938
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.815938)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.184062
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.184062)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.407969
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.407969)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.407969
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.407969)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 6
DEBUG CAREFUL: New best var: 6
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[4] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[5] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x6, Z0 = 3492004.23258055        , Z1 = 3128313.10817447        

DEBUG EVAL: Testing var 6 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 7, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=7, dir=1
DEBUG TRY_BRANCH: After decrement, var=6
DEBUG EVAL: try_branch returned z=3242606.632021
DEBUG EVAL: Branch var 6 = 1 gives z=3242606.632021
  % 	x6 = 1,	Z1 = 3242606.63202065        
DEBUG EVAL: First branch cutoff check: z=3242606.632021, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 6 = 0
DEBUG EVAL: Calling try_branch(lp, 7, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=7, dir=0
DEBUG TRY_BRANCH: After decrement, var=6
DEBUG EVAL: Second branch returned z=3432522.539080
  % 	x6 = 0,	Z0 = 3492004.23258055        
DEBUG EVAL: Second branch cutoff check: z=3492004.232581, best_z=INF, threshold=INF
  %   New best:  x6, Z = 3242606.63202065        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 2, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=0
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: try_branch returned z=3250688.120992
DEBUG EVAL: Branch var 1 = 0 gives z=3250688.120992
  % 	x1 = 0,	Z0 = 3250688.12099238        
DEBUG EVAL: First branch cutoff check: z=3250688.120992, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
DEBUG EVAL: Calling try_branch(lp, 2, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=1
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: Second branch returned z=3391330.208654
  % 	x1 = 1,	Z1 = 3391330.20865353        
DEBUG EVAL: Second branch cutoff check: z=3391330.208654, best_z=INF, threshold=INF
  %   New best:  x1, Z = 3250688.12099238        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 1, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=1, dir=0
DEBUG TRY_BRANCH: After decrement, var=0
DEBUG EVAL: try_branch returned z=3213128.077966
DEBUG EVAL: Branch var 0 = 0 gives z=3213128.077966
  % 	x0 = 0,	Z0 = 3213128.07796585        
DEBUG EVAL: First branch cutoff check: z=3213128.077966, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 10, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=10, dir=0
DEBUG TRY_BRANCH: After decrement, var=9
DEBUG EVAL: try_branch returned z=3290102.583267
DEBUG EVAL: Branch var 9 = 0 gives z=3290102.583267
  % 	x9 = 0,	Z0 = 3290102.58326734        
DEBUG EVAL: First branch cutoff check: z=3290102.583267, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
DEBUG EVAL: Calling try_branch(lp, 10, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=10, dir=1
DEBUG TRY_BRANCH: After decrement, var=9
DEBUG EVAL: Second branch returned z=3231415.257092
  % 	x9 = 1,	Z1 = 3231415.25709223        
DEBUG EVAL: Second branch cutoff check: z=3231415.257092, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 12, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=12, dir=0
DEBUG TRY_BRANCH: After decrement, var=11
DEBUG EVAL: try_branch returned z=3240729.995005
DEBUG EVAL: Branch var 11 = 0 gives z=3240729.995005
  % 	x11 = 0,	Z0 = 3240729.99500469        
DEBUG EVAL: First branch cutoff check: z=3240729.995005, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 8, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=8, dir=0
DEBUG TRY_BRANCH: After decrement, var=7
DEBUG EVAL: try_branch returned z=3167250.002838
DEBUG EVAL: Branch var 7 = 0 gives z=3167250.002838
  % 	x7 = 0,	Z0 = 3167250.00283833        
DEBUG EVAL: First branch cutoff check: z=3167250.002838, best_z=INF, threshold=INF
  % Best branch is x1, Z0 = 3250688.12099238        , Z1 = 3391330.20865353        

DEBUG CAREFUL: Final result - returning best.var = 1
DEBUG BB: Branching variable chosen: j=1
 % @NC   49   26	x1 = 0	3250688.120992
 % @NC   50   26	x1 = 1	3391330.208654
 %      26    26  3128313.1082                3140929.8824    x3 U    19     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee42f40
% @LO 0.01   3.12831310817447283412 99.9000000000
% @LN 0.01   3.14092988235679637654 99.9000000000
% Resuming node 8 at   3.14092988235679637654
DEBUG CONSTRNT: LP rows=20, pool->nlprows=20, pool->npend=0
DEBUG CONSTRNT: Checking 20 LP rows (pool tracks 20, total LP rows 20)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=19, expected 19
 % @PAP adding 14 rows, 66 nz to LP
DEBUG BB: Processing node 8, calling compute_good_lower_bound
  % @PL 14 rows, 24 cols, 66 nonzeros, 2 slack, 12 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 15 rows, 24 cols, 68 nonzeros, 2 slack, 13 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
  % @PL 17 rows, 24 cols, 72 nonzeros, 2 slack, 15 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
  % @PL 19 rows, 24 cols, 77 nonzeros, 2 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 8 LP 1 Solution, length = 3140929.882357, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 1.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.431299 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.568701 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3140929.882357, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3140929.882357, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 8 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 8
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=1.000000
DEBUG CAREFUL: Skipping var 4: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.431299
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.431299)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 1 fractional variables

  %  Carefully choosing branching variable, nfrac = 1
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
  % Initial guess is x8, Z0 = 3337833.44092349        , Z1 = 3140929.8823568         

DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 9, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=1
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: try_branch returned z=3294902.147198
DEBUG EVAL: Branch var 8 = 1 gives z=3294902.147198
  % 	x8 = 1,	Z1 = 3294902.14719772        
DEBUG EVAL: First branch cutoff check: z=3294902.147198, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
DEBUG EVAL: Calling try_branch(lp, 9, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=0
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: Second branch returned z=3345649.786351
  % 	x8 = 0,	Z0 = 3345649.78635077        
DEBUG EVAL: Second branch cutoff check: z=3345649.786351, best_z=INF, threshold=INF
  %   New best:  x8, Z = 3294902.14719772        
  % Best branch is x8, Z0 = 3345649.78635077        , Z1 = 3294902.14719772        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   51    8	x8 = 1	3294902.147198
 % @NC   52    8	x8 = 0	3345649.786351
 %       8    27  3140929.8824                3149309.9614    x4 U     2     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee45210
% @LO 0.01   3.14092988235679637654 99.9000000000
% @LN 0.01   3.14930996135209984033 99.9000000000
% Resuming node 42 at   3.14930996135209984033
DEBUG CONSTRNT: LP rows=19, pool->nlprows=19, pool->npend=0
DEBUG CONSTRNT: Checking 19 LP rows (pool tracks 19, total LP rows 19)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
 % @PAP adding 19 rows, 73 nz to LP
DEBUG BB: Processing node 42, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 42 LP 2 Solution, length = 3149309.961352, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.405258 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.405258 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.810516 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.189484 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.405258 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.405258 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.189484 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.189484 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.594742 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.594742 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 6 fractional variables
DEBUG CG: LP optimal, z=3149309.961352, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3149309.961352, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 42 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 42
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.405258
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.405258)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.405258
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.405258)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.810516
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.810516)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.189484
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.189484)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.405258
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.405258)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.405258
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.405258)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 6
DEBUG CAREFUL: New best var: 6
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[4] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[5] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x1, Z0 = 3149309.9613521         , Z1 = 3557204.89749045        

DEBUG EVAL: Testing var 6 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 7, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=7, dir=1
DEBUG TRY_BRANCH: After decrement, var=6
DEBUG EVAL: try_branch returned z=3186512.598706
DEBUG EVAL: Branch var 6 = 1 gives z=3186512.598706
  % 	x6 = 1,	Z1 = 3186512.59870608        
DEBUG EVAL: First branch cutoff check: z=3186512.598706, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 6 = 0
DEBUG EVAL: Calling try_branch(lp, 7, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=7, dir=0
DEBUG TRY_BRANCH: After decrement, var=6
DEBUG EVAL: Second branch returned z=3450665.923775
  % 	x6 = 0,	Z0 = 3504738.13416316        
DEBUG EVAL: Second branch cutoff check: z=3504738.134163, best_z=INF, threshold=INF
  %   New best:  x6, Z = 3186512.59870608        
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 2, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=1
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: try_branch returned z=3413473.977017
DEBUG EVAL: Branch var 1 = 1 gives z=3413473.977017
  % 	x1 = 1,	Z1 = 3557204.89749045        
DEBUG EVAL: First branch cutoff check: z=3557204.897490, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
DEBUG EVAL: Calling try_branch(lp, 2, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=0
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: Second branch returned z=3270871.826080
  % 	x1 = 0,	Z0 = 3270871.82608005        
DEBUG EVAL: Second branch cutoff check: z=3270871.826080, best_z=INF, threshold=INF
  %   New best:  x1, Z = 3270871.82608005        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 1, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=1, dir=0
DEBUG TRY_BRANCH: After decrement, var=0
DEBUG EVAL: try_branch returned z=3233561.359144
DEBUG EVAL: Branch var 0 = 0 gives z=3233561.359144
  % 	x0 = 0,	Z0 = 3233561.35914379        
DEBUG EVAL: First branch cutoff check: z=3233561.359144, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 10, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=10, dir=0
DEBUG TRY_BRANCH: After decrement, var=9
DEBUG EVAL: try_branch returned z=3308245.967962
DEBUG EVAL: Branch var 9 = 0 gives z=3308245.967962
  % 	x9 = 0,	Z0 = 3308245.96796237        
DEBUG EVAL: First branch cutoff check: z=3308245.967962, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
DEBUG EVAL: Calling try_branch(lp, 10, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=10, dir=1
DEBUG TRY_BRANCH: After decrement, var=9
DEBUG EVAL: Second branch returned z=3252884.203042
  % 	x9 = 1,	Z1 = 3252884.20304229        
DEBUG EVAL: Second branch cutoff check: z=3252884.203042, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 12, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=12, dir=1
DEBUG TRY_BRANCH: After decrement, var=11
DEBUG EVAL: try_branch returned z=3308382.909448
DEBUG EVAL: Branch var 11 = 1 gives z=3308382.909448
  % 	x11 = 1,	Z1 = 3308382.90944822        
DEBUG EVAL: First branch cutoff check: z=3308382.909448, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
DEBUG EVAL: Calling try_branch(lp, 12, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=12, dir=0
DEBUG TRY_BRANCH: After decrement, var=11
DEBUG EVAL: Second branch returned z=3259718.809836
  % 	x11 = 0,	Z0 = 3498860.06874955        
DEBUG EVAL: Second branch cutoff check: z=3498860.068750, best_z=INF, threshold=INF
  %   New best:  x11, Z = 3308382.90944822        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 8, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=8, dir=0
DEBUG TRY_BRANCH: After decrement, var=7
DEBUG EVAL: try_branch returned z=3189393.771202
DEBUG EVAL: Branch var 7 = 0 gives z=3189393.771202
  % 	x7 = 0,	Z0 = 3189393.77120196        
DEBUG EVAL: First branch cutoff check: z=3189393.771202, best_z=INF, threshold=INF
  % Best branch is x11, Z0 = 3498860.06874955        , Z1 = 3308382.90944822        

DEBUG CAREFUL: Final result - returning best.var = 11
DEBUG BB: Branching variable chosen: j=11
 % @NC   53   42	x11 = 1	3308382.909448
 % @NC   54   42	x11 = 0	3498860.068750
 %      42    28  3149309.9614                3157247.9098   x10 U    25     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee43090
% @LO 0.01   3.14930996135209984033 99.9000000000
% @LN 0.01   3.15724790979949343495 99.9000000000
% Resuming node 24 at   3.15724790979949343495
DEBUG CONSTRNT: LP rows=19, pool->nlprows=19, pool->npend=0
DEBUG CONSTRNT: Checking 19 LP rows (pool tracks 19, total LP rows 19)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=18, expected 18
 % @PAP adding 24 rows, 94 nz to LP
DEBUG BB: Processing node 24, calling compute_good_lower_bound
  % @PL 24 rows, 24 cols, 94 nonzeros, 8 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 25 rows, 24 cols, 96 nonzeros, 7 slack, 18 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % Node 24 LP 1 Solution, length = 3158460.386252, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.421470 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.578530 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 4 fractional variables
DEBUG CG: LP optimal, z=3158460.386252, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.01   3.15724790979949343495 99.9000000000
 % @LN 0.01   3.15846038625171265934 99.9000000000
DEBUG CG: Second cutoff check: z=3158460.386252, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 24 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 24
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=1.000000
DEBUG CAREFUL: Skipping var 3: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.421470
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.421470)
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
  % Initial guess is x13, Z0 = 3158460.38625171        , Z1 = 3350024.09713601        

DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 8, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=8, dir=0
DEBUG TRY_BRANCH: After decrement, var=7
DEBUG EVAL: try_branch returned z=3160585.147632
DEBUG EVAL: Branch var 7 = 0 gives z=3160585.147632
  % 	x7 = 0,	Z0 = 3160585.1476318         
DEBUG EVAL: First branch cutoff check: z=3160585.147632, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
DEBUG EVAL: Calling try_branch(lp, 8, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=8, dir=1
DEBUG TRY_BRANCH: After decrement, var=7
DEBUG EVAL: Second branch returned z=3161333.676008
  % 	x7 = 1,	Z1 = 3161333.67600781        
DEBUG EVAL: Second branch cutoff check: z=3161333.676008, best_z=INF, threshold=INF
  %   New best:  x7, Z = 3160585.1476318         
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 2, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=0
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: try_branch returned z=3161333.676008
DEBUG EVAL: Branch var 1 = 0 gives z=3161333.676008
  % 	x1 = 0,	Z0 = 3161333.67600781        
DEBUG EVAL: First branch cutoff check: z=3161333.676008, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
DEBUG EVAL: Calling try_branch(lp, 2, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=2, dir=1
DEBUG TRY_BRANCH: After decrement, var=1
DEBUG EVAL: Second branch returned z=3160585.147632
  % 	x1 = 1,	Z1 = 3160585.1476318         
DEBUG EVAL: Second branch cutoff check: z=3160585.147632, best_z=INF, threshold=INF
  %   New best:  x1, Z = 3160585.1476318         
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 10, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=10, dir=0
DEBUG TRY_BRANCH: After decrement, var=9
DEBUG EVAL: try_branch returned z=3160585.147632
DEBUG EVAL: Branch var 9 = 0 gives z=3160585.147632
  % 	x9 = 0,	Z0 = 3160585.1476318         
DEBUG EVAL: First branch cutoff check: z=3160585.147632, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
DEBUG EVAL: Calling try_branch(lp, 10, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=10, dir=1
DEBUG TRY_BRANCH: After decrement, var=9
DEBUG EVAL: Second branch returned z=3161333.676008
  % 	x9 = 1,	Z1 = 3161333.67600781        
DEBUG EVAL: Second branch cutoff check: z=3161333.676008, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 14, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=14, dir=1
DEBUG TRY_BRANCH: After decrement, var=13
DEBUG EVAL: try_branch returned z=3372355.245349
DEBUG EVAL: Branch var 13 = 1 gives z=3372355.245349
  % 	x13 = 1,	Z1 = 3372355.24534887        
DEBUG EVAL: First branch cutoff check: z=3372355.245349, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
DEBUG EVAL: Calling try_branch(lp, 14, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=14, dir=0
DEBUG TRY_BRANCH: After decrement, var=13
DEBUG EVAL: Second branch returned z=3436552.870294
  % 	x13 = 0,	Z0 = 3436552.87029446        
DEBUG EVAL: Second branch cutoff check: z=3436552.870294, best_z=INF, threshold=INF
  %   New best:  x13, Z = 3372355.24534887        
  % Best branch is x13, Z0 = 3436552.87029446        , Z1 = 3372355.24534887        

DEBUG CAREFUL: Final result - returning best.var = 13
DEBUG BB: Branching variable chosen: j=13
 % @NC   55   24	x13 = 1	3372355.245349
 % @NC   56   24	x13 = 0	3436552.870294
 %      24    29  3158460.3863                3163262.4740   x11 D    17     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee4a040
% @LO 0.01   3.15846038625171265934 99.9000000000
% @LN 0.01   3.16326247396167747894 99.9000000000
% Resuming node 10 at   3.16326247396167747894
DEBUG CONSTRNT: LP rows=18, pool->nlprows=18, pool->npend=0
DEBUG CONSTRNT: Checking 18 LP rows (pool tracks 18, total LP rows 18)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=17, expected 17
 % @PAP adding 17 rows, 71 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 10 LP 2 Solution, length = 3163262.473962, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.412170 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.587830 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3163262.473962, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3163262.473962, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=1.000000
DEBUG CAREFUL: Skipping var 0: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.412170
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.412170)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 1 fractional variables

  %  Carefully choosing branching variable, nfrac = 1
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
  % Initial guess is x8, Z0 = 3337833.44092349        , Z1 = 3163262.47396168        

DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 9, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=1
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: try_branch returned z=3322413.854998
DEBUG EVAL: Branch var 8 = 1 gives z=3322413.854998
  % 	x8 = 1,	Z1 = 3322413.85499755        
DEBUG EVAL: First branch cutoff check: z=3322413.854998, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
DEBUG EVAL: Calling try_branch(lp, 9, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=0
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: Second branch returned z=3358902.531325
  % 	x8 = 0,	Z0 = 3358902.53132535        
DEBUG EVAL: Second branch cutoff check: z=3358902.531325, best_z=INF, threshold=INF
  %   New best:  x8, Z = 3322413.85499755        
  % Best branch is x8, Z0 = 3358902.53132535        , Z1 = 3322413.85499755        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   57   10	x8 = 1	3322413.854998
 % @NC   58   10	x8 = 0	3358902.531325
 %      10    30  3163262.4740                3168419.4590    x0 U     7     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee73090
% @LO 0.01   3.16326247396167747894 99.9000000000
% @LN 0.01   3.16841945895980225956 99.9000000000
% Resuming node 14 at   3.16841945895980225956
DEBUG CONSTRNT: LP rows=17, pool->nlprows=17, pool->npend=0
DEBUG CONSTRNT: Checking 17 LP rows (pool tracks 17, total LP rows 17)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=16, expected 16
 % @PAP adding 18 rows, 73 nz to LP
DEBUG BB: Processing node 14, calling compute_good_lower_bound
  % @PL 18 rows, 24 cols, 73 nonzeros, 1 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 14 LP 1 Solution, length = 3168419.458960, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.411589 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.588411 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3168419.458960, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3168419.458960, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 14 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 14
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=1.000000
DEBUG CAREFUL: Skipping var 1: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.411589
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.411589)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=1.000000
DEBUG CAREFUL: Skipping var 11: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 1 fractional variables

  %  Carefully choosing branching variable, nfrac = 1
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
  % Initial guess is x8, Z0 = 3337833.44092349        , Z1 = 3168419.4589598         

DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 9, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=1
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: try_branch returned z=3327728.119905
DEBUG EVAL: Branch var 8 = 1 gives z=3327728.119905
  % 	x8 = 1,	Z1 = 3327728.11990466        
DEBUG EVAL: First branch cutoff check: z=3327728.119905, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
DEBUG EVAL: Calling try_branch(lp, 9, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=0
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: Second branch returned z=3363783.778650
  % 	x8 = 0,	Z0 = 3363783.77864973        
DEBUG EVAL: Second branch cutoff check: z=3363783.778650, best_z=INF, threshold=INF
  %   New best:  x8, Z = 3327728.11990466        
  % Best branch is x8, Z0 = 3363783.77864973        , Z1 = 3327728.11990466        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   59   14	x8 = 1	3327728.119905
 % @NC   60   14	x8 = 0	3363783.778650
 %      14    31  3168419.4590                3176394.0183    x1 U    11     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee62420
% @LO 0.01   3.16841945895980225956 99.9000000000
% @LN 0.01   3.17639401828618339607 99.9000000000
% Resuming node 13 at   3.17639401828618339607
DEBUG CONSTRNT: LP rows=18, pool->nlprows=18, pool->npend=0
DEBUG CONSTRNT: Checking 18 LP rows (pool tracks 18, total LP rows 18)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=17, expected 17
 % @PAP adding 16 rows, 68 nz to LP
DEBUG BB: Processing node 13, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 13 LP 2 Solution, length = 3176394.018286, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.406930 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.593070 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3176394.018286, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3176394.018286, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 13 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 13
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.406930
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.406930)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=1.000000
DEBUG CAREFUL: Skipping var 11: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 1 fractional variables

  %  Carefully choosing branching variable, nfrac = 1
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
  % Initial guess is x8, Z0 = 3337833.44092349        , Z1 = 3176394.01828618        

DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 9, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=1
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: try_branch returned z=3192328.151492
DEBUG EVAL: Branch var 8 = 1 gives z=3192328.151492
  % 	x8 = 1,	Z1 = 3192328.15149166        
DEBUG EVAL: First branch cutoff check: z=3192328.151492, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
DEBUG EVAL: Calling try_branch(lp, 9, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=0
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: Second branch returned z=3369546.866128
  % 	x8 = 0,	Z0 = 3369546.86612812        
DEBUG EVAL: Second branch cutoff check: z=3369546.866128, best_z=INF, threshold=INF
  %   New best:  x8, Z = 3192328.15149166        
  % Best branch is x8, Z0 = 3369546.86612812        , Z1 = 3192328.15149166        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   61   13	x8 = 1	3192328.151492
 % @NC   62   13	x8 = 0	3369546.866128
 %      13    32  3176394.0183                3176568.7770    x1 D    11     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee422e0
% @LO 0.01   3.17639401828618339607 99.9000000000
% @LN 0.01   3.17656877696748995987 99.9000000000
% Resuming node 29 at   3.17656877696748995987
DEBUG CONSTRNT: LP rows=16, pool->nlprows=16, pool->npend=0
DEBUG CONSTRNT: Checking 16 LP rows (pool tracks 16, total LP rows 16)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=15, expected 15
 % @PAP adding 22 rows, 85 nz to LP
DEBUG BB: Processing node 29, calling compute_good_lower_bound
  % @PL 22 rows, 24 cols, 85 nonzeros, 4 slack, 18 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 29 LP 1 Solution, length = 3176568.776967, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 1.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.401040 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.598960 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3176568.776967, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3176568.776967, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 29 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 29
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=1.000000
DEBUG CAREFUL: Skipping var 4: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.401040
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.401040)
DEBUG CAREFUL: Found 1 fractional variables

  %  Carefully choosing branching variable, nfrac = 1
DEBUG CAREFUL: Testing fvar[0] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
  % Initial guess is x13, Z0 = 3176568.77696749        , Z1 = 3401463.30703043        

DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 14, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=14, dir=1
DEBUG TRY_BRANCH: After decrement, var=13
DEBUG EVAL: try_branch returned z=3767029.057895
DEBUG EVAL: Branch var 13 = 1 gives z=3767029.057895
  % 	x13 = 1,	Z1 = 3767029.05789506        
DEBUG EVAL: First branch cutoff check: z=3767029.057895, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
DEBUG EVAL: Calling try_branch(lp, 14, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=14, dir=0
DEBUG TRY_BRANCH: After decrement, var=13
DEBUG EVAL: Second branch returned z=3441181.558026
  % 	x13 = 0,	Z0 = 3441181.55802576        
DEBUG EVAL: Second branch cutoff check: z=3441181.558026, best_z=INF, threshold=INF
  %   New best:  x13, Z = 3441181.55802576        
  % Best branch is x13, Z0 = 3441181.55802576        , Z1 = 3767029.05789506        

DEBUG CAREFUL: Final result - returning best.var = 13
DEBUG BB: Branching variable chosen: j=13
 % @NC   63   29	x13 = 0	3441181.558026
 % @NC   64   29	x13 = 1	3767029.057895
 %      29    33  3176568.7770                3176833.0168   x10 D    21     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee74720
% @LO 0.01   3.17656877696748995987 99.9000000000
% @LN 0.01   3.17683301682355700990 99.9000000000
% Resuming node 32 at   3.17683301682355700990
DEBUG CONSTRNT: LP rows=22, pool->nlprows=22, pool->npend=0
DEBUG CONSTRNT: Checking 22 LP rows (pool tracks 22, total LP rows 22)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=21, expected 21
 % @PAP adding 25 rows, 96 nz to LP
DEBUG BB: Processing node 32, calling compute_good_lower_bound
  % @PL 25 rows, 24 cols, 96 nonzeros, 8 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 26 rows, 24 cols, 98 nonzeros, 7 slack, 19 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % Node 32 LP 1 Solution, length = 3227282.222324, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.347653 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.652347 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3227282.222324, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 32 at   3.22728222232393191504
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee78a70
% @LO 0.01   3.17683301682355700990 99.9000000000
% @LN 0.01   3.18975374364258668081 99.9000000000
% Resuming node 35 at   3.18975374364258668081
DEBUG CONSTRNT: LP rows=19, pool->nlprows=19, pool->npend=0
DEBUG CONSTRNT: Checking 19 LP rows (pool tracks 19, total LP rows 19)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=18, expected 18
 % @PAP adding 19 rows, 77 nz to LP
DEBUG BB: Processing node 35, calling compute_good_lower_bound
  % @PL 19 rows, 24 cols, 77 nonzeros, 0 slack, 19 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 35 LP 1 Solution, length = 3189753.743643, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.391076 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.608924 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3189753.743643, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3189753.743643, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.01/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 35 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 35
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=1.000000
DEBUG CAREFUL: Skipping var 0: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.391076
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.391076)
DEBUG CAREFUL: Found 1 fractional variables

  %  Carefully choosing branching variable, nfrac = 1
DEBUG CAREFUL: Testing fvar[0] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
  % Initial guess is x13, Z0 = 3189753.74364259        , Z1 = 3418389.55357329        

DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 14, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=14, dir=1
DEBUG TRY_BRANCH: After decrement, var=13
DEBUG EVAL: try_branch returned z=3428098.286128
DEBUG EVAL: Branch var 13 = 1 gives z=3428098.286128
  % 	x13 = 1,	Z1 = 3428098.28612791        
DEBUG EVAL: First branch cutoff check: z=3428098.286128, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
DEBUG EVAL: Calling try_branch(lp, 14, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=14, dir=0
DEBUG TRY_BRANCH: After decrement, var=13
DEBUG EVAL: Second branch returned z=3447792.043592
  % 	x13 = 0,	Z0 = 3447792.04359232        
DEBUG EVAL: Second branch cutoff check: z=3447792.043592, best_z=INF, threshold=INF
  %   New best:  x13, Z = 3428098.28612791        
  % Best branch is x13, Z0 = 3447792.04359232        , Z1 = 3428098.28612791        

DEBUG CAREFUL: Final result - returning best.var = 13
DEBUG BB: Branching variable chosen: j=13
 % @NC   65   35	x13 = 1	3428098.286128
 % @NC   66   35	x13 = 0	3447792.043592
 %      35    34  3189753.7436                3192328.1515   x10 D    31     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee73090
% @LO 0.02   3.18975374364258668081 99.9000000000
% @LN 0.02   3.19232815149166482271 99.9000000000
% Resuming node 61 at   3.19232815149166482271
DEBUG CONSTRNT: LP rows=19, pool->nlprows=19, pool->npend=0
DEBUG CONSTRNT: Checking 19 LP rows (pool tracks 19, total LP rows 19)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=18, expected 18
 % @PAP adding 16 rows, 68 nz to LP
DEBUG BB: Processing node 61, calling compute_good_lower_bound
  % @PL 16 rows, 24 cols, 68 nonzeros, 1 slack, 15 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 17 rows, 24 cols, 70 nonzeros, 1 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 7 nz to LP
  % @PL 18 rows, 24 cols, 75 nonzeros, 2 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 17 rows, 24 cols, 68 nonzeros, 0 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 18 rows, 24 cols, 70 nonzeros, 2 slack, 16 tight.
  % Node 61 LP 1 Solution, length = 3634669.677229, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.507677 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.507677 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.507677 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.492323 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.492323 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.492323 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 61 is INFEASIBLE
 %      61    33    infeasible                3194632.9327    x8 U    13     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee71ba0
% @LO 0.02   3.19232815149166482271 99.9000000000
% @LN 0.02   3.19463293266891756872 99.9000000000
% Resuming node 40 at   3.19463293266891756872
DEBUG CONSTRNT: LP rows=18, pool->nlprows=18, pool->npend=0
DEBUG CONSTRNT: Checking 18 LP rows (pool tracks 18, total LP rows 18)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=17, expected 17
 % @PAP adding 29 rows, 107 nz to LP
DEBUG BB: Processing node 40, calling compute_good_lower_bound
  % @PL 29 rows, 24 cols, 107 nonzeros, 11 slack, 18 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 40 LP 1 Solution, length = 3194632.932669, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.390774 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.609226 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3194632.932669, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3194632.932669, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 40 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 40
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=1.000000
DEBUG CAREFUL: Skipping var 1: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=1.000000
DEBUG CAREFUL: Skipping var 11: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.390774
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.390774)
DEBUG CAREFUL: Found 1 fractional variables

  %  Carefully choosing branching variable, nfrac = 1
DEBUG CAREFUL: Testing fvar[0] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
  % Initial guess is x13, Z0 = 3194632.93266892        , Z1 = 3423382.35815388        

DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 14, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=14, dir=1
DEBUG TRY_BRANCH: After decrement, var=13
DEBUG EVAL: try_branch returned z=3438808.241823
DEBUG EVAL: Branch var 13 = 1 gives z=3438808.241823
  % 	x13 = 1,	Z1 = 3438808.24182303        
DEBUG EVAL: First branch cutoff check: z=3438808.241823, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
DEBUG EVAL: Calling try_branch(lp, 14, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=14, dir=0
DEBUG TRY_BRANCH: After decrement, var=13
DEBUG EVAL: Second branch returned z=3452471.578131
  % 	x13 = 0,	Z0 = 3452471.578131          
DEBUG EVAL: Second branch cutoff check: z=3452471.578131, best_z=INF, threshold=INF
  %   New best:  x13, Z = 3438808.24182303        
  % Best branch is x13, Z0 = 3452471.578131          , Z1 = 3438808.24182303        

DEBUG CAREFUL: Final result - returning best.var = 13
DEBUG BB: Branching variable chosen: j=13
 % @NC   67   40	x13 = 1	3438808.241823
 % @NC   68   40	x13 = 0	3452471.578131
 %      40    34  3194632.9327                3199681.2656   x10 D    34     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee45050
% @LO 0.02   3.19463293266891756872 99.9000000000
% @LN 0.02   3.19968126563010191177 99.9000000000
% Resuming node 36 at   3.19968126563010191177
DEBUG CONSTRNT: LP rows=29, pool->nlprows=29, pool->npend=0
DEBUG CONSTRNT: Checking 29 LP rows (pool tracks 29, total LP rows 29)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=28, expected 28
 % @PAP adding 19 rows, 77 nz to LP
DEBUG BB: Processing node 36, calling compute_good_lower_bound
  % @PL 19 rows, 24 cols, 77 nonzeros, 4 slack, 15 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 20 rows, 24 cols, 79 nonzeros, 3 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 36 LP 1 Solution, length = 3251645.676236, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.328060 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.671940 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3251645.676236, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 36 at   3.25164567623572509092
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee78780
% @LO 0.02   3.19968126563010191177 99.9000000000
% @LN 0.02   3.20494963071905081264 99.9000000000
% Resuming node 22 at   3.20494963071905081264
DEBUG CONSTRNT: LP rows=17, pool->nlprows=17, pool->npend=0
DEBUG CONSTRNT: Checking 17 LP rows (pool tracks 17, total LP rows 17)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=16, expected 16
 % @PAP adding 18 rows, 74 nz to LP
DEBUG BB: Processing node 22, calling compute_good_lower_bound
  % @PL 18 rows, 24 cols, 74 nonzeros, 1 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 22 LP 1 Solution, length = 3204949.630719, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 1.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.366782 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.633218 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3204949.630719, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3204949.630719, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 22 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 22
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=1.000000
DEBUG CAREFUL: Skipping var 3: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=1.000000
DEBUG CAREFUL: Skipping var 4: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.366782
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.366782)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 1 fractional variables

  %  Carefully choosing branching variable, nfrac = 1
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
  % Initial guess is x8, Z0 = 3379045.94155347        , Z1 = 3204949.63071905        

DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 9, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=1
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: try_branch returned z=3376389.497573
DEBUG EVAL: Branch var 8 = 1 gives z=3376389.497573
  % 	x8 = 1,	Z1 = 3376389.49757329        
DEBUG EVAL: First branch cutoff check: z=3376389.497573, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
DEBUG EVAL: Calling try_branch(lp, 9, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=0
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: Second branch returned z=3380345.517678
  % 	x8 = 0,	Z0 = 3380345.51767796        
DEBUG EVAL: Second branch cutoff check: z=3380345.517678, best_z=INF, threshold=INF
  %   New best:  x8, Z = 3376389.49757329        
  % Best branch is x8, Z0 = 3380345.51767796        , Z1 = 3376389.49757329        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   69   22	x8 = 1	3376389.497573
 % @NC   70   22	x8 = 0	3380345.517678
 %      22    35  3204949.6307                3227282.2223    x3 U    16     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee74720
% @LO 0.02   3.20494963071905081264 99.9000000000
% @LN 0.02   3.22728222232393191504 99.9000000000
% Resuming node 32 at   3.22728222232393191504
DEBUG CONSTRNT: LP rows=18, pool->nlprows=18, pool->npend=0
DEBUG CONSTRNT: Checking 18 LP rows (pool tracks 18, total LP rows 18)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=17, expected 17
 % @PAP adding 19 rows, 76 nz to LP
DEBUG BB: Processing node 32, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 32 LP 2 Solution, length = 3227282.222324, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.347653 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.652347 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3227282.222324, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3227282.222324, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 32 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 32
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=1.000000
DEBUG CAREFUL: Skipping var 0: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=1.000000
DEBUG CAREFUL: Skipping var 3: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.347653
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.347653)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 1 fractional variables

  %  Carefully choosing branching variable, nfrac = 1
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
  % Initial guess is x8, Z0 = 3379045.94155347        , Z1 = 3227282.22232393        

DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 9, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=1
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: try_branch returned z=3403901.205373
DEBUG EVAL: Branch var 8 = 1 gives z=3403901.205373
  % 	x8 = 1,	Z1 = 3403901.20537311        
DEBUG EVAL: First branch cutoff check: z=3403901.205373, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
DEBUG EVAL: Calling try_branch(lp, 9, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=0
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: Second branch returned z=3393530.484353
  % 	x8 = 0,	Z0 = 3393530.48435305        
DEBUG EVAL: Second branch cutoff check: z=3393530.484353, best_z=INF, threshold=INF
  %   New best:  x8, Z = 3393530.48435305        
  % Best branch is x8, Z0 = 3393530.48435305        , Z1 = 3403901.20537311        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   71   32	x8 = 0	3393530.484353
 % @NC   72   32	x8 = 1	3403901.205373
 %      32    36  3227282.2223                3229313.0846    x3 U    18     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee42ba0
% @LO 0.02   3.22728222232393191504 99.9000000000
% @LN 0.02   3.22931308463084354443 99.9000000000
% Resuming node 30 at   3.22931308463084354443
DEBUG CONSTRNT: LP rows=19, pool->nlprows=19, pool->npend=0
DEBUG CONSTRNT: Checking 19 LP rows (pool tracks 19, total LP rows 19)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=18, expected 18
 % @PAP adding 22 rows, 85 nz to LP
DEBUG BB: Processing node 30, calling compute_good_lower_bound
  % @PL 22 rows, 24 cols, 85 nonzeros, 6 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 30 LP 1 Solution, length = 3229313.084631, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 1.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.347189 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.652811 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3229313.084631, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3229313.084631, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 30 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 30
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=1.000000
DEBUG CAREFUL: Skipping var 4: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.347189
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.347189)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 1 fractional variables

  %  Carefully choosing branching variable, nfrac = 1
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
  % Initial guess is x8, Z0 = 3379045.94155347        , Z1 = 3229313.08463084        

DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 9, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=1
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: try_branch returned z=3406057.573870
DEBUG EVAL: Branch var 8 = 1 gives z=3406057.573870
  % 	x8 = 1,	Z1 = 3406057.57387002        
DEBUG EVAL: First branch cutoff check: z=3406057.573870, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
DEBUG EVAL: Calling try_branch(lp, 9, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=0
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: Second branch returned z=3395339.671087
  % 	x8 = 0,	Z0 = 3395339.67108651        
DEBUG EVAL: Second branch cutoff check: z=3395339.671087, best_z=INF, threshold=INF
  %   New best:  x8, Z = 3395339.67108651        
  % Best branch is x8, Z0 = 3395339.67108651        , Z1 = 3406057.57387002        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   73   30	x8 = 0	3395339.671087
 % @NC   74   30	x8 = 1	3406057.573870
 %      30    37  3229313.0846                3232439.2073   x10 U    21     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee41680
% @LO 0.02   3.22931308463084354443 99.9000000000
% @LN 0.02   3.23243920732205713975 99.9000000000
% Resuming node 38 at   3.23243920732205713975
DEBUG CONSTRNT: LP rows=22, pool->nlprows=22, pool->npend=0
DEBUG CONSTRNT: Checking 22 LP rows (pool tracks 22, total LP rows 22)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=21, expected 21
 % @PAP adding 26 rows, 98 nz to LP
DEBUG BB: Processing node 38, calling compute_good_lower_bound
  % @PL 26 rows, 24 cols, 98 nonzeros, 8 slack, 18 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 38 LP 1 Solution, length = 3232439.207322, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.347072 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.652928 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3232439.207322, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3232439.207322, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 38 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 38
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=1.000000
DEBUG CAREFUL: Skipping var 1: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=1.000000
DEBUG CAREFUL: Skipping var 3: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.347072
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.347072)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=1.000000
DEBUG CAREFUL: Skipping var 11: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 1 fractional variables

  %  Carefully choosing branching variable, nfrac = 1
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
  % Initial guess is x8, Z0 = 3379045.94155347        , Z1 = 3232439.20732206        

DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 9, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=1
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: try_branch returned z=3244491.566499
DEBUG EVAL: Branch var 8 = 1 gives z=3244491.566499
  % 	x8 = 1,	Z1 = 3244491.56649895        
DEBUG EVAL: First branch cutoff check: z=3244491.566499, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
DEBUG EVAL: Calling try_branch(lp, 9, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=0
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: Second branch returned z=3398409.673379
  % 	x8 = 0,	Z0 = 3398409.67337938        
DEBUG EVAL: Second branch cutoff check: z=3398409.673379, best_z=INF, threshold=INF
  %   New best:  x8, Z = 3244491.56649895        
  % Best branch is x8, Z0 = 3398409.67337938        , Z1 = 3244491.56649895        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   75   38	x8 = 1	3244491.566499
 % @NC   76   38	x8 = 0	3398409.673379
 %      38    38  3232439.2073                3240413.7666    x1 U    33     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee407f0
% @LO 0.02   3.23243920732205713975 99.9000000000
% @LN 0.02   3.24041376664843916444 99.9000000000
% Resuming node 37 at   3.24041376664843916444
DEBUG CONSTRNT: LP rows=26, pool->nlprows=26, pool->npend=0
DEBUG CONSTRNT: Checking 26 LP rows (pool tracks 26, total LP rows 26)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=25, expected 25
 % @PAP adding 17 rows, 71 nz to LP
DEBUG BB: Processing node 37, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 37 LP 2 Solution, length = 3240413.766648, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.342413 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.657587 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3240413.766648, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3240413.766648, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 37 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 37
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=1.000000
DEBUG CAREFUL: Skipping var 3: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.342413
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.342413)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=1.000000
DEBUG CAREFUL: Skipping var 11: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 1 fractional variables

  %  Carefully choosing branching variable, nfrac = 1
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
  % Initial guess is x8, Z0 = 3379045.94155347        , Z1 = 3240413.76664844        

DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 9, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=1
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: try_branch returned z=3252552.127454
DEBUG EVAL: Branch var 8 = 1 gives z=3252552.127454
  % 	x8 = 1,	Z1 = 3252552.12745365        
DEBUG EVAL: First branch cutoff check: z=3252552.127454, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
DEBUG EVAL: Calling try_branch(lp, 9, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=0
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: Second branch returned z=3404156.252892
  % 	x8 = 0,	Z0 = 3404156.25289158        
DEBUG EVAL: Second branch cutoff check: z=3404156.252892, best_z=INF, threshold=INF
  %   New best:  x8, Z = 3252552.12745365        
  % Best branch is x8, Z0 = 3404156.25289158        , Z1 = 3252552.12745365        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   77   37	x8 = 1	3252552.127454
 % @NC   78   37	x8 = 0	3404156.252892
 %      37    39  3240413.7666                3242059.0018    x1 D    33     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee44c90
% @LO 0.02   3.24041376664843916444 99.9000000000
% @LN 0.02   3.24205900182850026425 99.9000000000
% Resuming node 28 at   3.24205900182850026425
DEBUG CONSTRNT: LP rows=17, pool->nlprows=17, pool->npend=0
DEBUG CONSTRNT: Checking 17 LP rows (pool tracks 17, total LP rows 17)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=16, expected 16
 % @PAP adding 18 rows, 74 nz to LP
DEBUG BB: Processing node 28, calling compute_good_lower_bound
  % @PL 18 rows, 24 cols, 74 nonzeros, 4 slack, 14 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 5 rows, 15 nz to LP
  % @PL 23 rows, 24 cols, 89 nonzeros, 5 slack, 18 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 4 rows, 11 nz to LP
  % @PL 27 rows, 24 cols, 100 nonzeros, 7 slack, 20 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 2 rows, 7 nz to LP
  % @PL 22 rows, 24 cols, 74 nonzeros, 0 slack, 22 tight.
  % Node 28 LP 1 Solution, length = 3545914.877385, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 1.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 28 is INFEASIBLE
 %      28    38    infeasible                3244491.5665   x10 U    20     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee42ba0
% @LO 0.02   3.24205900182850026425 99.9000000000
% @LN 0.02   3.24449156649895087412 99.9000000000
% Resuming node 75 at   3.24449156649895087412
DEBUG CONSTRNT: LP rows=22, pool->nlprows=22, pool->npend=0
DEBUG CONSTRNT: Checking 22 LP rows (pool tracks 22, total LP rows 22)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=21, expected 21
 % @PAP adding 26 rows, 98 nz to LP
DEBUG BB: Processing node 75, calling compute_good_lower_bound
  % @PL 26 rows, 24 cols, 98 nonzeros, 10 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 75 LP 1 Solution, length = 3244491.566499, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.667423 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.332577 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.332577 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3244491.566499, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3244491.566499, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 75 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 75
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=1.000000
DEBUG CAREFUL: Skipping var 1: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.667423
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.667423)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=1.000000
DEBUG CAREFUL: Skipping var 11: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 1 fractional variables

  %  Carefully choosing branching variable, nfrac = 1
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
  % Initial guess is x3, Z0 = 3244491.56649895        , Z1 = 3244491.56649895        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 4, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=1
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: try_branch returned z=3409215.470280
DEBUG EVAL: Branch var 3 = 1 gives z=3409215.470280
  % 	x3 = 1,	Z1 = 3409215.47028023        
DEBUG EVAL: First branch cutoff check: z=3409215.470280, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
DEBUG EVAL: Calling try_branch(lp, 4, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=0
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: Second branch returned z=3656340.008544
  % 	x3 = 0,	Z0 = 3656340.00854355        
DEBUG EVAL: Second branch cutoff check: z=3656340.008544, best_z=INF, threshold=INF
  %   New best:  x3, Z = 3409215.47028023        
  % Best branch is x3, Z0 = 3656340.00854355        , Z1 = 3409215.47028023        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   79   75	x3 = 1	3409215.470280
 % @NC   80   75	x3 = 0	3656340.008544
 %      75    39  3244491.5665                3250688.1210    x8 U    38     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee46a20
% @LO 0.02   3.24449156649895087412 99.9000000000
% @LN 0.02   3.25068812099238479973 99.9000000000
% Resuming node 49 at   3.25068812099238479973
DEBUG CONSTRNT: LP rows=26, pool->nlprows=26, pool->npend=0
DEBUG CONSTRNT: Checking 26 LP rows (pool tracks 26, total LP rows 26)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=25, expected 25
 % @PAP adding 20 rows, 76 nz to LP
DEBUG BB: Processing node 49, calling compute_good_lower_bound
  % @PL 20 rows, 24 cols, 76 nonzeros, 2 slack, 18 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 3 nz to LP
  % @PL 21 rows, 24 cols, 79 nonzeros, 3 slack, 18 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 19 rows, 24 cols, 75 nonzeros, 1 slack, 18 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 49 LP 1 Solution, length = 3500000.112268, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.500000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.500000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 5 fractional variables
DEBUG CG: LP optimal, z=3500000.112268, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 49 at   3.50000011226808460663
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee45050
% @LO 0.02   3.25068812099238479973 99.9000000000
% @LN 0.02   3.25164567623572509092 99.9000000000
% Resuming node 36 at   3.25164567623572509092
DEBUG CONSTRNT: LP rows=18, pool->nlprows=18, pool->npend=0
DEBUG CONSTRNT: Checking 18 LP rows (pool tracks 18, total LP rows 18)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
 % @PAP adding 17 rows, 71 nz to LP
DEBUG BB: Processing node 36, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 36 LP 2 Solution, length = 3251645.676236, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.328060 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.671940 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3251645.676236, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3251645.676236, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 36 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 36
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=1.000000
DEBUG CAREFUL: Skipping var 0: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.328060
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.328060)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 1 fractional variables

  %  Carefully choosing branching variable, nfrac = 1
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
  % Initial guess is x8, Z0 = 3379045.94155347        , Z1 = 3251645.67623573        

DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 9, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=1
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: try_branch returned z=3433569.281670
DEBUG EVAL: Branch var 8 = 1 gives z=3433569.281670
  % 	x8 = 1,	Z1 = 3433569.28166985        
DEBUG EVAL: First branch cutoff check: z=3433569.281670, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
DEBUG EVAL: Calling try_branch(lp, 9, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=0
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: Second branch returned z=3408524.637762
  % 	x8 = 0,	Z0 = 3408524.63776161        
DEBUG EVAL: Second branch cutoff check: z=3408524.637762, best_z=INF, threshold=INF
  %   New best:  x8, Z = 3408524.63776161        
  % Best branch is x8, Z0 = 3408524.63776161        , Z1 = 3433569.28166985        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   81   36	x8 = 0	3408524.637762
 % @NC   82   36	x8 = 1	3433569.281670
 %      36    40  3251645.6762                3252552.1275   x10 U    31     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee41680
% @LO 0.02   3.25164567623572509092 99.9000000000
% @LN 0.02   3.25255212745365263061 99.9000000000
% Resuming node 77 at   3.25255212745365263061
DEBUG CONSTRNT: LP rows=17, pool->nlprows=17, pool->npend=0
DEBUG CONSTRNT: Checking 17 LP rows (pool tracks 17, total LP rows 17)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=16, expected 16
 % @PAP adding 17 rows, 71 nz to LP
DEBUG BB: Processing node 77, calling compute_good_lower_bound
  % @PL 17 rows, 24 cols, 71 nonzeros, 3 slack, 14 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 77 LP 1 Solution, length = 3252552.127454, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.665050 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.334950 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.334950 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3252552.127454, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3252552.127454, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 77 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 77
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.665050
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.665050)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=1.000000
DEBUG CAREFUL: Skipping var 11: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 1 fractional variables

  %  Carefully choosing branching variable, nfrac = 1
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
  % Initial guess is x3, Z0 = 3252552.12745365        , Z1 = 3252552.12745365        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 4, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=1
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: try_branch returned z=3258081.293158
DEBUG EVAL: Branch var 3 = 1 gives z=3258081.293158
  % 	x3 = 1,	Z1 = 3258081.29315758        
DEBUG EVAL: First branch cutoff check: z=3258081.293158, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
DEBUG EVAL: Calling try_branch(lp, 4, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=4, dir=0
DEBUG TRY_BRANCH: After decrement, var=3
DEBUG EVAL: Second branch returned z=3662936.157184
  % 	x3 = 0,	Z0 = 3662936.15718412        
DEBUG EVAL: Second branch cutoff check: z=3662936.157184, best_z=INF, threshold=INF
  %   New best:  x3, Z = 3258081.29315758        
  % Best branch is x3, Z0 = 3662936.15718412        , Z1 = 3258081.29315758        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   83   77	x3 = 1	3258081.293158
 % @NC   84   77	x3 = 0	3662936.157184
 %      77    41  3252552.1275                3256802.6612    x8 U    37     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee78240
% @LO 0.02   3.25255212745365263061 99.9000000000
% @LN 0.02   3.25680266123384987154 99.9000000000
% Resuming node 46 at   3.25680266123384987154
DEBUG CONSTRNT: LP rows=17, pool->nlprows=17, pool->npend=0
DEBUG CONSTRNT: Checking 17 LP rows (pool tracks 17, total LP rows 17)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=16, expected 16
 % @PAP adding 30 rows, 109 nz to LP
DEBUG BB: Processing node 46, calling compute_good_lower_bound
  % @PL 30 rows, 24 cols, 109 nonzeros, 13 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % Node 46 LP 1 Solution, length = 3256802.661234, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.327479 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.672521 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3256802.661234, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3256802.661234, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 46 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 46
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=1.000000
DEBUG CAREFUL: Skipping var 1: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.327479
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.327479)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=1.000000
DEBUG CAREFUL: Skipping var 11: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 1 fractional variables

  %  Carefully choosing branching variable, nfrac = 1
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
  % Initial guess is x8, Z0 = 3379045.94155347        , Z1 = 3256802.66123385        

DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 9, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=1
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: try_branch returned z=3438883.546577
DEBUG EVAL: Branch var 8 = 1 gives z=3438883.546577
  % 	x8 = 1,	Z1 = 3438883.54657696        
DEBUG EVAL: First branch cutoff check: z=3438883.546577, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
DEBUG EVAL: Calling try_branch(lp, 9, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=0
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: Second branch returned z=3413403.826788
  % 	x8 = 0,	Z0 = 3413403.82678794        
DEBUG EVAL: Second branch cutoff check: z=3413403.826788, best_z=INF, threshold=INF
  %   New best:  x8, Z = 3413403.82678794        
  % Best branch is x8, Z0 = 3413403.82678794        , Z1 = 3438883.54657696        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   85   46	x8 = 0	3413403.826788
 % @NC   86   46	x8 = 1	3438883.546577
 %      46    42  3256802.6612                3258081.2932    x1 U    39     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee45050
% @LO 0.02   3.25680266123384987154 99.9000000000
% @LN 0.02   3.25808129315757888378 99.9000000000
% Resuming node 83 at   3.25808129315757888378
DEBUG CONSTRNT: LP rows=30, pool->nlprows=30, pool->npend=0
DEBUG CONSTRNT: Checking 30 LP rows (pool tracks 30, total LP rows 30)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=29, expected 29
 % @PAP adding 17 rows, 71 nz to LP
DEBUG BB: Processing node 83, calling compute_good_lower_bound
  % @PL 17 rows, 24 cols, 71 nonzeros, 1 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 18 rows, 24 cols, 73 nonzeros, 1 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 7 nz to LP
  % @PL 19 rows, 24 cols, 78 nonzeros, 2 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 18 rows, 24 cols, 71 nonzeros, 0 slack, 18 tight.
  % Node 83 LP 1 Solution, length = 3664844.671047, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.454119 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.454119 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.454119 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.545881 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.545881 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.545881 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 83 is INFEASIBLE
 %      83    41    infeasible                3264777.2206    x3 U    77     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee40300
% @LO 0.02   3.25808129315757888378 99.9000000000
% @LN 0.02   3.26477722056023234032 99.9000000000
% Resuming node 45 at   3.26477722056023234032
DEBUG CONSTRNT: LP rows=18, pool->nlprows=18, pool->npend=0
DEBUG CONSTRNT: Checking 18 LP rows (pool tracks 18, total LP rows 18)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=17, expected 17
 % @PAP adding 16 rows, 69 nz to LP
DEBUG BB: Processing node 45, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 45 LP 2 Solution, length = 3264777.220560, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.322820 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.677180 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 1 fractional variables
DEBUG CG: LP optimal, z=3264777.220560, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=3264777.220560, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 45 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 45
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=1.000000
DEBUG CAREFUL: Skipping var 6: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.322820
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.322820)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=1.000000
DEBUG CAREFUL: Skipping var 11: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 1 fractional variables

  %  Carefully choosing branching variable, nfrac = 1
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
  % Initial guess is x8, Z0 = 3379045.94155347        , Z1 = 3264777.22056023        

DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: About to call try_branch(lp, 9, 1, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=1
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: try_branch returned z=3282971.150002
DEBUG EVAL: Branch var 8 = 1 gives z=3282971.150002
  % 	x8 = 1,	Z1 = 3282971.1500017         
DEBUG EVAL: First branch cutoff check: z=3282971.150002, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
DEBUG EVAL: Calling try_branch(lp, 9, 0, x, DBL_MAX, basp, bbip)
DEBUG TRY_BRANCH: Called with var=9, dir=0
DEBUG TRY_BRANCH: After decrement, var=8
DEBUG EVAL: Second branch returned z=3419150.406300
  % 	x8 = 0,	Z0 = 3419150.40630014        
DEBUG EVAL: Second branch cutoff check: z=3419150.406300, best_z=INF, threshold=INF
  %   New best:  x8, Z = 3282971.1500017         
  % Best branch is x8, Z0 = 3419150.40630014        , Z1 = 3282971.1500017         

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   87   45	x8 = 1	3282971.150002
 % @NC   88   45	x8 = 0	3419150.406300
 %      45    42  3264777.2206                3282971.1500    x1 D    39     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee45050
% @LO 0.02   3.26477722056023234032 99.9000000000
% @LN 0.02   3.28297115000169759114 99.9000000000
% Resuming node 87 at   3.28297115000169759114
DEBUG CONSTRNT: LP rows=16, pool->nlprows=16, pool->npend=0
DEBUG CONSTRNT: Checking 16 LP rows (pool tracks 16, total LP rows 16)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=15, expected 15
 % @PAP adding 16 rows, 69 nz to LP
DEBUG BB: Processing node 87, calling compute_good_lower_bound
  % @PL 16 rows, 24 cols, 69 nonzeros, 1 slack, 15 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 17 rows, 24 cols, 71 nonzeros, 1 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 7 nz to LP
  % @PL 18 rows, 24 cols, 76 nonzeros, 2 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 17 rows, 24 cols, 69 nonzeros, 0 slack, 17 tight.
  % Node 87 LP 1 Solution, length = 3701854.019252, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.437855 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.437855 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.437855 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.562145 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.562145 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.562145 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 87 is INFEASIBLE
 %      87    41    infeasible                3294902.1472    x8 U    45     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee6c2a0
% @LO 0.02   3.28297115000169759114 99.9000000000
% @LN 0.02   3.29490214719772334107 99.9000000000
% Resuming node 51 at   3.29490214719772334107
DEBUG CONSTRNT: LP rows=17, pool->nlprows=17, pool->npend=0
DEBUG CONSTRNT: Checking 17 LP rows (pool tracks 17, total LP rows 17)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=16, expected 16
 % @PAP adding 19 rows, 77 nz to LP
DEBUG BB: Processing node 51, calling compute_good_lower_bound
  % @PL 19 rows, 24 cols, 77 nonzeros, 1 slack, 18 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
  % @PL 23 rows, 24 cols, 90 nonzeros, 4 slack, 19 tight.
  % Node 51 LP 1 Solution, length = 3580375.027981, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 1.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.269552 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.730448 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.730448 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.269552 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 51 is INFEASIBLE
 %      51    40    infeasible                3308382.9094    x8 U     8     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee42f40
% @LO 0.02   3.29490214719772334107 99.9000000000
% @LN 0.02   3.30838290944821666884 99.9000000000
% Resuming node 53 at   3.30838290944821666884
DEBUG CONSTRNT: LP rows=23, pool->nlprows=23, pool->npend=0
DEBUG CONSTRNT: Checking 23 LP rows (pool tracks 23, total LP rows 23)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=22, expected 22
 % @PAP adding 19 rows, 73 nz to LP
DEBUG BB: Processing node 53, calling compute_good_lower_bound
  % @PL 19 rows, 24 cols, 73 nonzeros, 2 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
  % @PL 21 rows, 24 cols, 78 nonzeros, 4 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 18 rows, 24 cols, 72 nonzeros, 1 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 5 nz to LP
  % @PL 19 rows, 24 cols, 75 nonzeros, 1 slack, 18 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 19 rows, 24 cols, 75 nonzeros, 1 slack, 18 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 4 nz to LP
  % @PL 20 rows, 24 cols, 75 nonzeros, 1 slack, 19 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 53 LP 1 Solution, length = 3459637.707576, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.117129 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.882871 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 4 fractional variables
DEBUG CG: LP optimal, z=3459637.707576, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 53 at   3.45963770757566013714
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee43090
% @LO 0.02   3.30838290944821666884 99.9000000000
% @LN 0.02   3.32241385499754660060 99.9000000000
% Resuming node 57 at   3.32241385499754660060
DEBUG CONSTRNT: LP rows=19, pool->nlprows=19, pool->npend=0
DEBUG CONSTRNT: Checking 19 LP rows (pool tracks 19, total LP rows 19)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=18, expected 18
 % @PAP adding 17 rows, 71 nz to LP
DEBUG BB: Processing node 57, calling compute_good_lower_bound
  % @PL 17 rows, 24 cols, 71 nonzeros, 1 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 2 rows, 7 nz to LP
  % @PL 19 rows, 24 cols, 78 nonzeros, 4 slack, 15 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 16 rows, 24 cols, 69 nonzeros, 0 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 17 rows, 24 cols, 71 nonzeros, 0 slack, 17 tight.
  % Node 57 LP 1 Solution, length = 3684917.828263, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.881752 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.881752 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.118248 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.118248 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 57 is INFEASIBLE
 %      57    39    infeasible                3327728.1199    x8 U    10     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee4a040
% @LO 0.02   3.32241385499754660060 99.9000000000
% @LN 0.02   3.32772811990465955390 99.9000000000
% Resuming node 59 at   3.32772811990465955390
DEBUG CONSTRNT: LP rows=17, pool->nlprows=17, pool->npend=0
DEBUG CONSTRNT: Checking 17 LP rows (pool tracks 17, total LP rows 17)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=16, expected 16
 % @PAP adding 18 rows, 73 nz to LP
DEBUG BB: Processing node 59, calling compute_good_lower_bound
  % @PL 18 rows, 24 cols, 73 nonzeros, 0 slack, 18 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
  % @PL 22 rows, 24 cols, 86 nonzeros, 4 slack, 18 tight.
  % Node 59 LP 1 Solution, length = 3623094.966789, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.244236 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 1.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.755764 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.755764 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.244236 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 59 is INFEASIBLE
 %      59    38    infeasible                3341137.0608    x8 U    14     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee411d0
% @LO 0.02   3.32772811990465955390 99.9000000000
% @LN 0.02   3.34113706075104710536 99.9000000000
% Resuming node 47 at   3.34113706075104710536
DEBUG CONSTRNT: LP rows=22, pool->nlprows=22, pool->npend=0
DEBUG CONSTRNT: Checking 22 LP rows (pool tracks 22, total LP rows 22)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=21, expected 21
 % @PAP adding 19 rows, 75 nz to LP
DEBUG BB: Processing node 47, calling compute_good_lower_bound
  % @PL 19 rows, 24 cols, 75 nonzeros, 1 slack, 18 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
  % @PL 23 rows, 24 cols, 91 nonzeros, 3 slack, 20 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 21 rows, 24 cols, 78 nonzeros, 2 slack, 19 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 7 nz to LP
  % @PL 22 rows, 24 cols, 79 nonzeros, 3 slack, 19 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 9 nz to LP
  % @PL 22 rows, 24 cols, 82 nonzeros, 1 slack, 21 tight.
  % Node 47 LP 1 Solution, length = 4241516.582892, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.522252 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.477748 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 47 is INFEASIBLE
 %      47    37    infeasible                3345649.7864   x13 U    12     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x645cfee5ca50
% @LO 0.02   3.34113706075104710536 99.9000000000
% @LN 0.02   3.34564978635076881730 99.9000000000
% Resuming node 52 at   3.34564978635076881730
DEBUG CONSTRNT: LP rows=22, pool->nlprows=22, pool->npend=0
DEBUG CONSTRNT: Checking 22 LP rows (pool tracks 22, total LP rows 22)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=21, expected 21
 % @PAP adding 19 rows, 77 nz to LP
DEBUG BB: Processing node 52, calling compute_good_lower_bound
  % @PL 19 rows, 24 cols, 77 nonzeros, 3 slack, 16 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 20 rows, 24 cols, 79 nonzeros, 3 slack, 17 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
  % @PL 18 rows, 24 cols, 74 nonzeros, 0 slack, 18 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
  % @PL 20 rows, 24 cols, 79 nonzeros, 1 slack, 19 tight.
DEBUG COPY: Copied 14 FST + 10 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 52 LP 1 Solution, length = 3495410.323470, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 1.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
 % 0 fractional variables
DEBUG CG: LP optimal, z=3495410.323470, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG IFS: Budget mode - accepting integer solution with 4 edges covering 8 vertices
DEBUG CG: integer_feasible_solution returned: TRUE
DEBUG CG: Solution is integer feasible, returning LB_INTEGRAL
DEBUG BB: compute_good_lower_bound returned status=3
DEBUG BB: Node 52 is INTEGRAL (integer solution found)
 %  	=== 36 nodes cut off ===
 % @UO 0.02   1.49541032346968805200 -123.7278781511
 % @UN 0.02   1.49541032346968805200 -123.7278781511
DEBUG BB: Calling heuristic UB for integer solution, current best_z=1495410.323470
DEBUG BB: Heuristic did not improve integer solution
 % *    52     0  1495410.3235  1495410.3235                  x8 D     8     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=(nil)
DEBUG BB: No more nodes to process, exiting

 % Certificate of solution:
 % @C	.1435036374490092	.7633750660678332
 % @C	.1606704657889116	.1392797240736805
 % @C	.2809336405926924	.0931619940734952
%%Page: 1 1
BeginPlot
	Plot_Terminals
 % fs2: 9 2 7
	9 T	.1435036374490092	.7633750660678332	S
	.1435036374490092	.7633750660678332	2 T	S
	.1435036374490092	.7633750660678332	7 T	S
 % fs4: 5 1 0 4
	5 T	.1606704657889116	.1392797240736805	S
	.1606704657889116	.1392797240736805	1 T	S
	.1606704657889116	.1392797240736805	.2809336405926924	.0931619940734952	S
	.2809336405926924	.0931619940734952	0 T	S
	.2809336405926924	.0931619940734952	4 T	S
 % fs5: 8 7
	8 T	7 T	S
 % fs6: 2 1
	2 T	1 T	S
  (Euclidean SMT:  10 points,  length = 1.495410323469687,  0.02 seconds)
EndPlot

% @0 Euclidean SMT
% N M Nodes LPs P1CPU P2CPU TotCPU
% @1 10 14 56 65 0.00 0.02 0.02
% Z RootZ %Gap RootLPs RootCPU RedMST
% @2 1.495410323469687 2881297.503793 -92.67605 1 0.00 23.0195
% InitPRows InitPNZ InitLPRows InitLPNZ
% @3 54 170 46 149
% RootPRows RootPNZ RootLPRows RootLPNZ
% @4 54 170 13 64
% FinalPRows FinalPNZ FinalLPRows FinalLPNZ
% @5 54 170 19 65
% SMTFSTs SMTAvgFSTSz SMTMaxFSTSz #2FSTs #3FSTs ... #10FSTS #>10FSTs
% @6 4 2.750000 4 2 1 1 0 0 0 0 0 0 0
